<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pat Shaughnessy</title>
  <id>http://patshaughnessy.net</id>
  <updated>2008-09-03T00:00:00Z</updated>
  <author>
    <name></name>
  </author>
  <entry>
    <title>Two Dumb Ruby Mistakes</title>
    <link href="http://patshaughnessy.net/2016/4/2/two-dumb-ruby-mistakes" rel="alternate"/>
    <id>http://patshaughnessy.net/2016/4/2/two-dumb-ruby-mistakes</id>
    <published>2016-04-02T00:00:00Z</published>
    <updated>2016-04-02T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: right; padding: 0px 0px 20px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/4/2/rope-climber.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Coding is like climbing: You need equipment&lt;br/&gt; that will catch you when you make a mistake.&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href="https://commons.wikimedia.org/wiki/File:Free_climbing_20060701.jpg"&gt;Elke Wetzig via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;</summary>
    <content type="html">&lt;div style="float: right; padding: 0px 0px 20px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/4/2/rope-climber.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Coding is like climbing: You need equipment&lt;br/&gt; that will catch you when you make a mistake.&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href="https://commons.wikimedia.org/wiki/File:Free_climbing_20060701.jpg"&gt;Elke Wetzig via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Most Ruby blog posts show you examples of code you should write: how to solve a
certain problem, how to use some library or gem, how Ruby itself works. But
today I decided to write about a few dumb mistakes I’ve made using Ruby
recently. Read on to see two things you &lt;em&gt;should not do&lt;/em&gt; with the Ruby language,
for a change.&lt;/p&gt;

&lt;p&gt;The depressing thing about this is that I made these dumb mistakes just in the
past few weeks! I’ve been using Ruby professionally every day for eight years,
I’ve researched and written about Ruby in my spare time as a hobby, and &lt;em&gt;I still
make dumb mistakes with the language all the time!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Coding is like climbing: Sooner or later we all make mistakes and fall. What
you need to do is plan on this happening and use the appropriate equipment to
avoid disaster. Climbers use carabiners, ropes and harnesses to catch them when
they fall. Developers should use a language that will catch them when they make
dumb mistakes.&lt;/p&gt;

&lt;h2&gt;Searching For An Array Element&lt;/h2&gt;

&lt;p&gt;Let’s start with some test data. Here’s an array of &lt;span
class="code"&gt;Person&lt;/span&gt; objects, each with a first name, last name and an
insult count:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
    &lt;span class="constant"&gt;Person&lt;/span&gt; = &lt;span class="constant"&gt;Struct&lt;/span&gt;.new(&lt;span class="symbol"&gt;:first_name&lt;/span&gt;, &lt;span class="symbol"&gt;:last_name&lt;/span&gt;, &lt;span class="symbol"&gt;:insults&lt;/span&gt;)
    candidates = [ 
        &lt;span class="constant"&gt;Person&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Ted&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Cruz&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;432&lt;/span&gt;),
        &lt;span class="constant"&gt;Person&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Donald&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Trump&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;892&lt;/span&gt;),
        &lt;span class="constant"&gt;Person&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Marco&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Rubio&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;321&lt;/span&gt;)
    ]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;A couple of weeks ago (using different data of course) I wrote this line of
code to search for a specific element in the array:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/mistake1.png"/&gt;&lt;/p&gt;

&lt;div style="clear: both"&gt;&lt;/div&gt;


&lt;p&gt;What I wanted was the first person in the array named “Marco.” Instead when I
ran the code what I got was the first element of the array, but with the first
name set to “Marco:”&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
p marco
=&amp;gt; &lt;span class="comment"&gt;#&amp;lt;struct Person first_name=&amp;quot;Marco&amp;quot;, last_name=&amp;quot;Cruz&amp;quot;, insults=432&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Of course, I should have known better. The proper line of code is:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/correct1.png"/&gt;&lt;/p&gt;

&lt;p&gt;I should have used &lt;span class="code"&gt;==&lt;/span&gt; instead of &lt;span
class="code"&gt;=&lt;/span&gt;. What a dumb mistake. I can’t believe I wrote this code;
how embarrassing! I’m sure you all saw the problem right away, and maybe a few
of you have made the same mistake before. But let’s walk through what happened
when I ran the incorrect code, just to be sure we thoroughly understand the
problem.&lt;/p&gt;

&lt;p&gt;Ruby started with the &lt;span class="code"&gt;candidates&lt;/span&gt; array, and called
the &lt;span class="code"&gt;find&lt;/span&gt; method on it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/array1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;find&lt;/span&gt; method is actually a member of the &lt;span
class="code"&gt;Enumerable&lt;/span&gt; module, which Ruby includes automatically into
the &lt;span class="code"&gt;Array&lt;/span&gt; class. When &lt;span class="code"&gt;find&lt;/span&gt;
ran, it iterated over the elements of the array and called the block I
provided, passing in each element. The first element was the “Ted Cruz” person
object:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/call-block1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Now the block executed. And my dumb mistake came into play. What I intended was
for the block to return whether or not the first name of the given person was
equal to “Marco.” If the first name was “Marco” then &lt;span
class="code"&gt;Person#first_name == &amp;quot;Marco&amp;quot;&lt;/span&gt; would return true, the block
would return &lt;span class="code"&gt;true&lt;/span&gt; and &lt;span
class="code"&gt;Enumerable#find&lt;/span&gt; would return the target person. In this
case, &amp;ldquo;Ted&amp;rdquo; is not &amp;ldquo;Marco&amp;rdquo; so the block would return &lt;span
class="code"&gt;false&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;But my block didn’t check whether the person is named “Marco;” instead, it
called the &lt;span class="code"&gt;Person#first_name=&lt;/span&gt; method, setting the
person’s name to “Marco!”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/set-first-name.svg"/&gt;&lt;/p&gt;

&lt;p&gt;And now, to make matters worse, the block returned the value returned by
&lt;span class="code"&gt;Person#first_name=&lt;/span&gt;, which was the string “Marco,” the new value of the first
name attribute. Because Ruby considered “Marco” to be &lt;em&gt;truthy&lt;/em&gt;, &lt;span class="code"&gt;Enumerable#find&lt;/span&gt;
returned the first person, even though that person was originally named Ted
Cruz. My surrounding code now thinks it found Marco Rubio, but instead has Ted
Cruz, renamed to Marco Cruz. What a mess.&lt;/p&gt;

&lt;h2&gt;Why Didn’t Ruby Tell Me Something Was Wrong?&lt;/h2&gt;

&lt;div style="float: right; padding: 0px 0px 20px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/4/2/bouldering.jpg"&gt;&lt;br/&gt;
  &lt;i&gt; As a developer, you’re always just one&lt;br/&gt; keystroke away from falling off a cliff.  &lt;br/&gt;
    &lt;small&gt;(source: &lt;a href="https://commons.wikimedia.org/wiki/File:Bouldering.jpg"&gt;DecafGrub47393 via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Think about this for a moment: I used the &lt;span class="code"&gt;find&lt;/span&gt;
method, which called a block and expected that block to return &lt;span
class="code"&gt;true&lt;/span&gt; or &lt;span class="code"&gt;false&lt;/span&gt;.  But my block
returned neither &lt;span class="code"&gt;true&lt;/span&gt; nor &lt;span
class="code"&gt;false&lt;/span&gt;. It returned “Marco.”&lt;/p&gt;

&lt;p&gt;Why didn’t Ruby issue some sort of error or warning in this case? Yes, I
understand that Ruby considers all values, except for &lt;span
class="code"&gt;false&lt;/span&gt; and &lt;span class="code"&gt;nil&lt;/span&gt;, to be equivalent
to &lt;span class="code"&gt;true&lt;/span&gt;. In fact, Ruby developers quite often take
advantage of this fact to write more concise readable code: We can write: &lt;span
class="code"&gt;if value&lt;/span&gt; instead of &lt;span class="code"&gt;if value !=
false&lt;/span&gt; or &lt;span class="code"&gt;if value != nil&lt;/span&gt; or whatever.&lt;/p&gt;

&lt;p&gt;But in this case, Ruby’s silence allowed my simple coding mistake to become a
serious problem. If Ruby had given me some sort of warning or error the first
time I ran this code, I would have found the problem and fixed it in 5 seconds.
Instead, this code ran for weeks and failed every single time, and I had no
idea.&lt;/p&gt;

&lt;p&gt;When I fell, Ruby didn’t catch me, it allowed me to fall off the cliff!&lt;/p&gt;

&lt;h2&gt;Finding The Maximum Value in an Array&lt;/h2&gt;

&lt;p&gt;We all have a bad day from time to time. After making that mistake I just
continued to work on my project, trying harder not to make any more dumb
mistakes. It was my fault, I thought. I just needed to be a better programmer.&lt;/p&gt;

&lt;p&gt;But of course, it happened again! I made another dumb Ruby mistake just a few
days later. This time I wanted to sort the same array. Specifically, I wanted
to find the array element with the maximum value for some attribute. I was
using different data, of course, but we can translate the problem to our
candidate data set easily.&lt;/p&gt;

&lt;p&gt;Suppose I wanted to find the candidate with the maximum number of insults.
Easy, right? Here’s the line of code I wrote:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/mistake2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Can you spot the problem here? When I run that code I don’t get Donald Trump, who has the most insults. Instead, I get:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
p most_insulting
=&amp;gt; &lt;span class="comment"&gt;#&amp;lt;struct Person first_name=&amp;quot;Marco&amp;quot;, last_name=&amp;quot;Rubio&amp;quot;, insults=321&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Again a simple, dumb mistake. I should have called &lt;span
class="code"&gt;max_by&lt;/span&gt;, instead of &lt;span class="code"&gt;max&lt;/span&gt;. Here’s
the correct code:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/correct2.png"/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;Enumerable#max_by&lt;/span&gt; does what I thought &lt;span
class="code"&gt;Enumerable#max&lt;/span&gt; would do: It sorts the values returned by
the block, and then returns the object corresponding to the maximum value.
This is only slightly less embarrassing than my first dumb mistake. Almost all
modern programming languages use &lt;span class="code"&gt;==&lt;/span&gt; and &lt;span
class="code"&gt;=&lt;/span&gt; for equality vs. assignment. There’s no excuse for making
that mistake: It was just dumb.&lt;/p&gt;

&lt;p&gt;The difference between &lt;span class="code"&gt;max&lt;/span&gt; and &lt;span
class="code"&gt;max_by&lt;/span&gt; is not quite as obvious. But again, I’ve been using
Ruby for 8 years now. I should know better! I’m just a bad Ruby developer. But
before we blame this mistake entirely on me, let’s take a closer look at what
actually happened when I ran my bad code. Let’s step through what &lt;span
class="code"&gt;Enumerable#max&lt;/span&gt; did, just as we did before with &lt;span
class="code"&gt;Enumerable#find&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Again Ruby started by calling &lt;span class="code"&gt;Enumerable#max&lt;/span&gt; on the
candidates array:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/array2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;And again, just like &lt;/span&gt;find&lt;/span&gt;, &lt;span class="code"&gt;max&lt;/span&gt; iterates
over the array elements. However, instead of passing each person to the block
one at a time, it actually passes the array elements in pairs:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/4/2/call-block2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Why did Ruby pass two &lt;span class="code"&gt;Person&lt;/span&gt; objects to my block?
&lt;span class="code"&gt;Enumerable#max&lt;/span&gt; searches for the array element &amp;ndash; not
the return value of a block &amp;ndash; which has the maximum value. It assumes that the
values in the array can be compared, that they have a natural sort order.
&lt;span class="code"&gt;Enumerable#max&lt;/span&gt; is perfect for an array of integers or
an array of strings. Ruby can sort them automatically and find the maximum
value by returning the last element.&lt;/p&gt;

&lt;p&gt;Additionally, Ruby allows you to use &lt;span class="code"&gt;max&lt;/span&gt; when the
array elements can’t be sorted automatically, when you have an array of
objects, like my &lt;span class="code"&gt;Person&lt;/span&gt; structures. Because Ruby
doesn’t know whether one person is greater or less than another, it allows you
to pass a block to &lt;span class="code"&gt;max&lt;/span&gt; that answers that question.
The block should accept two arguments return one of three numeric values: -1, 0
or 1:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-1 if the first value is less than the second (they are in ascending order)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;0 indicates they are the same, at least in terms of their sort order, and&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1 if the first value is greater than the second (they are in descending order)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So what happened here was that by using &lt;span
class="code"&gt;Enumerable#max&lt;/span&gt; and providing a block, Ruby assumed my block
was there to determine the sort order of the Person objects, not to return an
attribute for each one.&lt;/p&gt;

&lt;p&gt;As you probably know, Ruby makes our lives easier by providing the “space ship”
operator, &lt;span class="code"&gt;&amp;lt;=&gt;&lt;/span&gt;, that compares two values and returns
this sort order number: -1, 0 or 1. The correct way to find the most insulting
candidate using &lt;span class="code"&gt;max&lt;/span&gt; would be to compare the two
values of &lt;span class="code"&gt;Person#insults&lt;/span&gt; using &lt;span
class="code"&gt;&amp;lt;=&gt;:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
most_insulting = candidates.max{|person1, person2| person1.insults &amp;lt;=&amp;gt; person2.insults}
p most_insulting
=&amp;gt; &lt;span class="comment"&gt;#&amp;lt;struct Person first_name=&amp;quot;Donald&amp;quot;, last_name=&amp;quot;Trump&amp;quot;, insults=892&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;h2&gt;Why Didn’t Ruby Tell Me Something Was Wrong?&lt;/h2&gt;

&lt;p&gt;I knew all about the space ship operator and sort order blocks, but for
whatever reason in the moment I typed in my bad code I just forgot. Maybe I was
in a rush, maybe I was just tired. Maybe I really thought I typed &lt;span
class="code"&gt;max_by&lt;/span&gt; but somehow the “_by” part just didn’t leave my
brain and make it to the keyboard.&lt;/p&gt;

&lt;p&gt;But Ruby knew I should have used &lt;span class="code"&gt;max_by&lt;/span&gt;, or least
that I should have accepted two parameters in my block. Why didn’t it tell me?&lt;/p&gt;

&lt;p&gt;That is, my block expected only one argument, not two. I wrote:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
{|person| etc…}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;and not:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
{|person1, person2| etc… }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Why didn’t Ruby complain when it tried to pass two objects, but my block
only accepted one? It turns out when you pass extra arguments to a block Ruby
silently ignores them. Note: Ruby does check the number of arguments when you
explicitly use &lt;span class="code"&gt;lambda{}&lt;/span&gt; or &lt;span
class="code"&gt;&amp;ndash;&gt;()&lt;/span&gt; and then call it using the &lt;span
class="code"&gt;Proc.call&lt;/span&gt; method.  But 99% of the time Ruby developers use
blocks in the standard, default manner and don’t create &lt;span
class="code"&gt;Proc&lt;/span&gt; objects explicitly.&lt;/p&gt;

&lt;p&gt;Ruby could have told me something was wrong by displaying a warning or an error
message, maybe: “wrong number of arguments (2 for 1) (ArgumentError).” But
instead, it remained silent. It assumed that I just didn’t need that second
block argument, that I wanted to keep my code simpler and easier to read, and
conveniently allowed me to leave it out of the block’s argument list. Ruby
assumed I was a smart, experienced developer who doesn’t make dumb mistakes
like this. Ruby was so wrong!&lt;/p&gt;

&lt;p&gt;What happened next? Ruby continued to run my block, and things got really ugly.
Take another look at the block’s code:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
{|person| person.insults}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;It returns the insult count for the given person &amp;ndash; a number! Next Ruby
interpreted the numerical value my block returned, 432, 892 or 321, as the sort
order indicator. That’s right: Ruby will accept any positive value from the
sort order block, not just 1, and consider that to mean the two objects are in
descending order. Similarly, it will take any negative value to mean the values
are in ascending order.&lt;/p&gt;

&lt;p&gt;Again, Ruby could have told me: “wrong type for block return value (Integer for
SortOrder) (TypeError).” But, of course, Ruby isn’t a statically typed
language. It doesn&amp;rsquo;t check the types of method and block arguments, or their
return values.&lt;/p&gt;

&lt;div style="float: right; padding: 70px 0px 30px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/4/2/carabiner.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Your coding equipment should catch you&lt;br/&gt;when you make a mistake and fall.&lt;/i&gt;&lt;br/&gt;
    &lt;small&gt;(source: &lt;a
href="https://commons.wikimedia.org/wiki/File:Carabiner.jpg"&gt;Marcin Jahr via
Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;Once again, Ruby erred on the side of convenience, and assumed I knew what I
was doing. It conveniently allowed me to return 321 instead of 1, just in case
I really wanted to return 321 without having to convert it to 1.  As we’ve
seen, I make dumb mistakes all the time. Ruby is very wrong to believe I know
what I am doing.&lt;/p&gt;

&lt;h2&gt;Our Programming Language Should Catch Our Dumb Mistakes&lt;/h2&gt;

&lt;p&gt;We actually make dumb mistakes all the time, not just once or twice a week, but
probably hundreds of times every day. Every time we misspell a keyword, forget
a method argument, or use an API the wrong way we have made a mistake. But we
don’t think of these mistakes as mistakes &amp;ndash; they are just how we work as
humans. When we type, we usually press the backspace key quite often. When we
use an API or run shell commands we have to check the documentation or
StackOverflow to remind ourselves what arguments or options to use.&lt;/p&gt;

&lt;p&gt;And usually our programming language, whether it’s Ruby or something else,
finds our mistakes immediately and tells us about them with a syntax error
message. We correct the mistake within seconds and continue coding, climbing
higher and higher up the cliff. But in my two examples the mistakes,
unfortunately, weren’t apparent immediately.  This incorrect code ran for weeks
before I discovered the problem. You always want to fail fast: The worst
mistakes are the ones you never notice until it’s too late.&lt;/p&gt;

&lt;p&gt;But why didn’t I discover these mistakes sooner by running tests? Don’t I use
TDD? Don’t I at least write tests to check my code after I’ve written it? Yes.
But in my actual project, these mistakes were part of my test code. They
allowed my tests to pass, but caused them to return a false positive result. My
tests were green, but actually weren’t functioning at all. Tests aren&amp;rsquo;t
perfect. They are only as good as the code you write to implement them.&lt;/p&gt;

&lt;p&gt;Maybe these two dumb Ruby mistakes were exactly that: mistakes Ruby made and
not me. I’m only human; it’s normal for me to type in nonsense and garbage all
day long into the computer. But Ruby is a programming language. It’s job &amp;ndash; it’s
most important job &amp;ndash; is to tell me when my code is incorrect as soon as
possible. In these two examples, it was the Ruby language itself that made the
dumb mistake. The bugs weren’t in my code, they were in the language itself.&lt;/p&gt;

&lt;p&gt;Of course, I could just switch to a statically typed language, like Java or Go.
These languages automatically check the types of arguments and return values
for me. If I used Swift I could take advantage of static types and use
blocks/closures. I could even use a language like Haskell where the type system
is so powerful that merely by allowing my code to run with no errors, the
compiler has mathematically proven my code is correct. (If this could only be
true!)&lt;/p&gt;

&lt;p&gt;But I love Ruby. It’s a joy to use. Ruby code has a very human elegance to it
that I haven’t seen in other programming languages. I just wish Ruby would
catch me every time I fall.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Is Your Postgres Query Starved for Memory?</title>
    <link href="http://patshaughnessy.net/2016/1/22/is-your-postgres-query-starved-for-memory" rel="alternate"/>
    <id>http://patshaughnessy.net/2016/1/22/is-your-postgres-query-starved-for-memory</id>
    <published>2016-01-22T01:00:00Z</published>
    <updated>2016-01-22T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/1/22/sphygmomanometer.png"&gt;&lt;br/&gt;
  &lt;i&gt;
Like a patient with low blood pressure, a slow SQL&lt;br/&gt;
query might not be getting the memory it needs.
  &lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;For years or even decades, I’ve heard about how important it is to optimize my
SQL statements and database schema.</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/1/22/sphygmomanometer.png"&gt;&lt;br/&gt;
  &lt;i&gt;
Like a patient with low blood pressure, a slow SQL&lt;br/&gt;
query might not be getting the memory it needs.
  &lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;For years or even decades, I’ve heard about how important it is to optimize my
SQL statements and database schema. When my application starts to
slow down, I look for missing indexes; I look for unnecessary joins; I think
about caching results with a materialized view.&lt;/p&gt;

&lt;p&gt;But instead, the problem might be my Postgres server was not installed and
tuned properly. Buried inside the &lt;span class="code"&gt;postgresql.conf&lt;/span&gt;
file is an obscure, technical setting called &lt;span
class="code"&gt;work_mem&lt;/span&gt;. This controls how much “working memory” your
Postgres server allocates for each sort or join operation. The default value
for this is only 4MB:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/work_mem.png"/&gt;&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;


&lt;p&gt;If your application ever tries to sort or join more than four megabytes worth
of data, this working memory buffer will fill up. Instead of just returning the
dataset you want, Postgres will waste time streaming excess data out to disk &amp;ndash;
only to read it back again later as the hash join or sort algorithm proceeds.&lt;/p&gt;

&lt;p&gt;Today I’ll start with a look at how Postgres scales up the hash join algorithm
for larger and larger data sets. Then I’ll measure how much slower a hash join
query is when the hash table doesn’t fit into the working memory buffer. You’ll
learn how to use the EXPLAIN ANALYZE command to find out if your slow query is
starved for memory.&lt;/p&gt;

&lt;h2&gt;Hash Tables Inside of Postgres&lt;/h2&gt;

&lt;p&gt;In my last article, I described &lt;a href="http://patshaughnessy.net/2015/11/24/a-look-at-how-postgres-executes-a-tiny-join"&gt;how Postgres implements the hash join
algorithm&lt;/a&gt;.
I showed how Postgres scans over all the records in one of the tables from the
join and saves them in a hash table.&lt;/p&gt;

&lt;p&gt;Here’s what a hash table might look like conceptually:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/table1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;On the left is an array of pointers called &lt;em&gt;buckets&lt;/em&gt;. Each of these pointers is
the head of a linked list, which I show on the right using blue rectangles. The
rectangles represent values from one of the tables in the join. Postgres groups
the values into lists based on their hash values. By organizing the values from one
table like this, Postgres can later scan over a second table and repeatedly
search the hash table to perform the join efficiently. This algorithm is known
as a &lt;em&gt;hash join&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Postgres’s hash join code gracefully scales up to process larger and larger
data sets by increasing the number of buckets. If the target table had more
records, Postgres would use 2048 buckets instead of 1024:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/table2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Before starting to execute the hash join algorithm, Postgres estimates how many
records it will need to add to the hash table, using the query plan. Then
Postgres chooses a bucket count large enough to fit all of the records.&lt;/p&gt;

&lt;p&gt;Postgres’s bucket count formula keeps the average linked list length less than
10 (the constant &lt;span class="code"&gt;NTUP_PER_BUCKET&lt;/span&gt; in the Postgres
source code), to avoid iterating over long lists. It also sets the bucket count
to a power of two, which allows Postgres to use C bitmask operations to assign
buckets to hash values. The least significant bits of the hash value for each
record becomes the bucket number.&lt;/p&gt;

&lt;p&gt;If you’re curious, Postgres implements the bucket count formula in a C function
called &lt;span class="code"&gt;ExecChooseHashTableSize&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecChooseHashTableSize&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeHash_8c.html#a5b805ac64e22306b7307b4a07ae2b34e"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2016/1/22/ExecChooseHashTableSize.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;How Large Can a Postgres Hash Table Grow?&lt;/h2&gt;

&lt;p&gt;If the table from your join query was even larger, then Postgres would use 4096
buckets instead of 2048:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/table3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;In theory, this doubling of the bucket count could continue forever: 8192
buckets, 16384 buckets, etc. With 10 records per linked list, this would
accommodate 81,920 values, 163,840 values, etc.&lt;/p&gt;

&lt;p&gt;In practice, as the total size of the data set being saved into the hash table
continues to increase Postgres will eventually run out of memory. But that
doesn’t seem to be an immediate problem, does it? Modern server hardware
contains tens or even hundreds of GBs &amp;ndash; that is plenty of room to hold an
extremely large hash table.&lt;/p&gt;

&lt;p&gt;But in fact, Postgres limits the size of each hash table to only 4MB!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/table4.svg"/&gt;&lt;/p&gt;

&lt;p&gt;The rectangle I drew around the hash table above is the working memory buffer
assigned to that table. Regardless of how much memory my server hardware
actually has, Postgres won’t allow the hash table to consume more than 4MB.
This value is the &lt;span class="code"&gt;work_mem&lt;/span&gt; setting found in the
&lt;span class="code"&gt;postgresql.conf&lt;/span&gt; file.&lt;/p&gt;

&lt;p&gt;At the same time Postgres calculates the number of buckets, it also calculates
the total amount of memory it expects the hash table to consume. If this amount
exceeds 4MB, Postgres divides the hash operation up into a series of &lt;em&gt;batches&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/batches.svg"/&gt;&lt;/p&gt;

&lt;p&gt;In this example, Postgres calculated that it would need up to 8MB to hold the
hash table. A larger join query might have many more batches, each holding 4MB
of data. Like the bucket count, Postgres sets the batch count to a power of two
also.  The first batch, shown on the left, contains the actual hash table in
memory.  The second batch, shown on the right, contains the records that won’t
fit into the 4MB hash table in the first batch.  Postgres assigns a batch
number to each record, along with the bucket number.  Then it saves the records
from the first batch into the hash table, and streams the remaining data out to
disk. Each batch gets its own temporary file.&lt;/p&gt;

&lt;p&gt;Using an algorithm known as the &lt;a href="https://en.wikipedia.org/wiki/Hash_join#Hybrid_hash_join"&gt;Hybrid hash
join&lt;/a&gt;, Postgres first
searches the hash table already in memory. Then it streams all of the data back
from disk for the next batch, builds another hash table and searches it,
repeating this process for each batch.&lt;/p&gt;

&lt;br/&gt;




&lt;blockquote&gt;
Note: Postgres actually holds a second hash table in memory, called the skew
table. For simplicity I’m not showing this in the diagram. This special hash
table is an optimization to handle hash values that occur frequently in the
data. Postgres saves the skew table inside the same 4MB working memory buffer,
so the primary hash table actually has a bit less than 4MB available to it.
&lt;/blockquote&gt;


&lt;h2&gt;Measuring Your SQL Statement’s Blood Pressure&lt;/h2&gt;

&lt;p&gt;If one of the SQL queries in your application is running slowly, use the
&lt;span class="code"&gt;EXPLAIN ANALYZE&lt;/span&gt; to find out what’s going on:&lt;/p&gt;

&lt;pre style="font-size: 10px"&gt;
&gt; explain analyze select title, company from publications, authors where author = name;

                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2579.00..53605.00 rows=50000 width=72) (actual time=66.820..959.794 rows=21 loops=1)
   Hash Cond: ((authors.name)::text = (publications.author)::text)
   -&gt;  Seq Scan on authors  (cost=0.00..20310.00 rows=1000000 width=50) (actual time=0.059..267.217 rows=1000000 loops=1)
   -&gt;  Hash  (cost=1270.00..1270.00 rows=50000 width=88) (actual time=38.054..38.054 rows=50000 loops=1)
         Buckets: 4096  Batches: 2  Memory Usage: 2948kB
         -&gt;  Seq Scan on publications  (cost=0.00..1270.00 rows=50000 width=88) (actual time=0.010..14.211 rows=50000 loops=1)
 Planning time: 0.489 ms
 Execution time: 960.482 ms
(8 rows)
&lt;/pre&gt;


&lt;p&gt;Postgres’s &lt;span class="code"&gt;EXPLAIN&lt;/span&gt; command displays the query plan, a
tree data structure containing instructions that Postgres follows when it
executes the query. By using &lt;span class="code"&gt;EXPLAIN ANALYZE&lt;/span&gt; we ask
Postgres to execute the query also, displaying time and data metrics when its
finished. We can see in this example there were one million records in the
authors table and 50 thousand records in the publications table. At the bottom
we see that the join operation took a total of 960ms to finish.&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;EXPLAIN ANALYZE&lt;/span&gt; also tells us how many buckets and
batches the hash table used:&lt;/p&gt;

&lt;pre&gt;
Buckets: 4096  Batches: 2  Memory Usage: 2948kB
&lt;/pre&gt;


&lt;p&gt;Like my diagram above, this query used 2 batches: Only half of the data fit
into the 4MB working memory buffer! Postgres saved the other half of the data
in the file buffer.&lt;/p&gt;

&lt;h2&gt;Increasing work_mem&lt;/h2&gt;

&lt;p&gt;Now let’s increase the size of the working memory buffer by editing the &lt;span
class="code"&gt;postgresql.conf&lt;/span&gt; file and restarting the Postgres server.&lt;/p&gt;

&lt;p&gt;First, I stop my Postgres server:&lt;/p&gt;

&lt;pre&gt;
$ launchctl unload homebrew.mxcl.postgresql.plist
&lt;/pre&gt;


&lt;p&gt;Then I edit &lt;span class="code"&gt;postgresql.conf&lt;/span&gt;:&lt;/p&gt;

&lt;pre&gt;
$ vim /usr/local/var/postgres/postgresql.conf
&lt;/pre&gt;


&lt;p&gt;…uncommenting and changing the setting:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/work_mem2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Finally I restart my server and repeat the test:&lt;/p&gt;

&lt;pre&gt;
$ launchctl load homebrew.mxcl.postgresql.plist
&lt;/pre&gt;




&lt;pre style="font-size: 10px"&gt;
&gt; explain analyze select title, company from publications, authors where author = name;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1895.00..32705.00 rows=50000 width=72) (actual time=59.224..624.716 rows=21 loops=1)
   Hash Cond: ((authors.name)::text = (publications.author)::text)
   -&gt;  Seq Scan on authors  (cost=0.00..20310.00 rows=1000000 width=50) (actual time=0.031..146.327 rows=1000000 loops=1)
   -&gt;  Hash  (cost=1270.00..1270.00 rows=50000 width=88) (actual time=34.436..34.436 rows=50000 loops=1)
         Buckets: 8192  Batches: 1  Memory Usage: 5860kB
         -&gt;  Seq Scan on publications  (cost=0.00..1270.00 rows=50000 width=88) (actual time=0.008..13.382 rows=50000 loops=1)
 Planning time: 0.481 ms
 Execution time: 625.796 ms
(8 rows)
&lt;/pre&gt;


&lt;p&gt;You can see the number of batches is now 1, and the memory usage increased to
5.8MB:&lt;/p&gt;

&lt;pre&gt;
Buckets: 8192  Batches: 1  Memory Usage: 5860kB
&lt;/pre&gt;


&lt;p&gt;Postgres was able to use a working memory buffer size larger than 4MB. This
allowed it to save the entire data set into a single, in memory hash table and
avoid using temporary buffer files.&lt;/p&gt;

&lt;p&gt;Because of this, the total execution time decreased from 960ms to 625ms:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2016/1/22/chart.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Too Good To Be True&lt;/h2&gt;

&lt;p&gt;If memory intensive Postgres SQL statements could run so much faster, why does
Postgres use only 4MB by default for the working memory buffer size? In this
example I increased &lt;span class="code"&gt;work_mem&lt;/span&gt; modestly from 4MB to
8MB &amp;ndash; why not increase it to 1GB or 10GB? Why not use all of your server’s
available memory to run all of your SQL statements as fast as possible, all of
the time? That’s why you bought that fat box to host your Postgres server,
isn’t it?&lt;/p&gt;

&lt;p&gt;This result seems too easy, too good to be true. And it is.&lt;/p&gt;

&lt;p&gt;Database servers like Postgres are optimized to handle many small, concurrent
requests at the same time. Each request needs its own working memory buffer.
Not only that, each SQL statement Postgres executes might require multiple
memory buffers, one for each join or sort operation the query plan calls for.&lt;/p&gt;

&lt;div style="float: right; padding: 0px 30px 50px 10px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2016/1/22/bp1.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;My Postgres server isn’t entirely dedicated to executing this one example SQL
statement and nothing else. By increasing the value of &lt;span
class="code"&gt;work_mem&lt;/span&gt;, I’ve increased it server-wide for every request,
not just for my one slow hash join. Given the same amount of total RAM
available on the server box, increasing &lt;span class="code"&gt;work_mem&lt;/span&gt;
means Postgres can handle fewer concurrent requests before running out of
memory.&lt;/p&gt;

&lt;p&gt;However, it certainly might be the case that 8MB or some larger value for &lt;span
class="code"&gt;work_mem&lt;/span&gt; is appropriate given the amount of memory I have,
and the number of concurrent connections I expect.&lt;/p&gt;

&lt;p&gt;Be smart about how you configure your Postgres server. Don’t blindly accept the
default values, or guess what they should be at the moment you install
Postgres. Instead, after your application is finished and running in
production, look for memory intensive SQL statements. Measure the SQL queries
your application actually executes. Take their blood pressure using the &lt;span
class="code"&gt;EXPLAIN ANALYZE&lt;/span&gt; command; you might find they are memory
starved!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>A Look at How Postgres Executes a Tiny Join</title>
    <link href="http://patshaughnessy.net/2015/11/24/a-look-at-how-postgres-executes-a-tiny-join" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/11/24/a-look-at-how-postgres-executes-a-tiny-join</id>
    <published>2015-11-24T01:00:00Z</published>
    <updated>2015-11-24T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/11/24/lecture-hall.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;
  Reading the Postgres source code is like attending a free&lt;br/&gt; Computer Science lecture, complete with working examples.
  &lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Aside from saving and retrieving data, the primary feature of a relational
database is the ability </summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/11/24/lecture-hall.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;
  Reading the Postgres source code is like attending a free&lt;br/&gt; Computer Science lecture, complete with working examples.
  &lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Aside from saving and retrieving data, the primary feature of a relational
database is the ability to execute join queries, to &lt;em&gt;relate&lt;/em&gt; data in one table
with data from another. While many developers are turning to NoSQL solutions,
joining one set of data values with another remains one of our most common and
important use cases while writing server code.&lt;/p&gt;

&lt;p&gt;But what does the word “join” actually mean? And what really happens when I
execute a join query?  Too often we take our tools for granted, without really
understanding what they are doing. This month I decided to look at the source
code for &lt;a href="http://www.postgresql.org"&gt;PostgreSQL&lt;/a&gt;, a popular open source
database server, to see how it implements join queries.&lt;/p&gt;

&lt;p&gt;Reading and experimenting with the Postgres source code turned out to be a
great learning experience. Today I’d like to report my observations; I&amp;rsquo;ll
show you exactly how Postgres executed a tiny join consisting of just a few
records, using the &lt;em&gt;hash join&lt;/em&gt; algorithm. In future articles I’ll show you some
interesting optimizations Postgres uses for larger joins, and other computer
science algorithms at work inside of Postgres.&lt;/p&gt;

&lt;h2&gt;What is a Join?&lt;/h2&gt;

&lt;p&gt;But before we get to the Postgres source code, let’s start by reviewing what
join queries are. Here&amp;rsquo;s an introduction from &lt;a href="http://www.postgresql.org/docs/current/static/tutorial-join.html"&gt;the excellent Postgres
documentation&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/postgres-join-tutorial.png"/&gt;&lt;/p&gt;

&lt;p&gt;The Postgres docs then explain how to use joins: inner vs. outer joins, joining
a table with itself, etc. But I’m intrigued by the highlighted disclaimer.
What is that “more efficient manner?” And how could Postgres possibly get away
with not “actually comparing each possible pair of rows?”&lt;/p&gt;

&lt;h2&gt;A Tiny Join&lt;/h2&gt;

&lt;p&gt;As an example today let’s work with two tables: &lt;em&gt;publications&lt;/em&gt;, which contains
three ground breaking computer science journal articles I never read in
college, and &lt;em&gt;authors&lt;/em&gt;, which records where each author worked.&lt;/p&gt;

&lt;pre&gt;
&gt; select * from publications;

                         title                          |   author   | year 
--------------------------------------------------------+------------+------
 A Relational Model of Data for Large Shared Data Banks | Edgar Codd | 1970
 Relational Completeness of Data Base Sublanguages      | Edgar Codd | 1972
 The Transaction Concept: Virtues and Limitations       | Jim Gray   | 1981
(3 rows)

&gt; select * from authors;

    name    |         company         
------------+-------------------------
 Edgar Codd | IBM Research Laboratory
 Jim Gray   | Tandem Computers
(2 rows)
&lt;/pre&gt;


&lt;p&gt;Today’s goal is to understand exactly what happens when Postgres joins one table with the other:&lt;/p&gt;

&lt;pre&gt;
&gt; select title, company from publications, authors where author = name;

                         title                          |         company         
--------------------------------------------------------+-------------------------
 Relational Completeness of Data Base Sublanguages      | IBM Research Laboratory
 A Relational Model of Data for Large Shared Data Banks | IBM Research Laboratory
 The Transaction Concept: Virtues and Limitations       | Tandem Computers
(3 rows)
&lt;/pre&gt;


&lt;h2&gt;A Conceptual Model for Joining Two Tables&lt;/h2&gt;

&lt;p&gt;Before we look at the algorithm Postgres actually uses, let’s review what join
queries do conceptually. Above the documentation stated that Postgres
implements joins by “comparing each possible pair of rows,” and then selecting
“the pairs of rows where these values match.”&lt;/p&gt;

&lt;p&gt;Reading this I imagine Postgres takes each publication and loops over all of
the authors, looking for that publication’s author:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan1.png"/&gt;&lt;/p&gt;

&lt;p&gt;In blue on the left are the publications, and I show the author records on the
right in green. This process of iterating over the rows in the authors table is
known as a scan in the Postgres source code. We are scanning over all of the
authors for the first publication, trying to find matching names.&lt;/p&gt;

&lt;p&gt;What do we do with each publication-author pair? We have to evaluate the &lt;span
class="code"&gt;WHERE&lt;/span&gt; clause from my example SQL statement:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/where1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Do the names match? Yes. This pair should be included in the result set. What
about the second pair?&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/where2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Do these names match? This time they don’t &amp;ndash; this pair of rows should be
filtered out.&lt;/p&gt;

&lt;p&gt;Once we have a matching pair of rows, we copy just the selected columns into a
new, joined record and return that to the client:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/select1.png"/&gt;&lt;/p&gt;

&lt;h2&gt;A Nested Loop&lt;/h2&gt;

&lt;p&gt;What’s wrong with this conceptual model? It seems like a very simple,
straightforward way of obtaining the values we need. If we proceed to scan
through the rest of the publications, it produces the same result that Postgres
does, although in a different order. (We’ll see why the order changes later.)&lt;/p&gt;

&lt;p&gt;The problem is that it’s very inefficient. First we scan over all of the
authors for the first row in the publications table:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan1b.png"/&gt;&lt;/p&gt;

&lt;p&gt;And then we repeat the same scan of the authors table for the second
publication:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan2.png"/&gt;&lt;/p&gt;

&lt;p&gt;And again for the third row. To find all of the matching pairs, in fact, we
need to loop over all the authors for each publication:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan3.png"/&gt;&lt;/p&gt;

&lt;p&gt;For my tiny query this isn’t a problem. There are 3*2 or 6 combinations of
rows; comparing names 6 times would only take a few microseconds on a modern
computer. However, as the number of rows increases in either table, the total
number of comparisons will explode. If we have 1000 publications and 1000
authors, suddenly we would have to compare name strings 1000*1000 or 1 million
times! Computer scientists describe this algorithm as O(n&lt;sup&gt;2&lt;/sup&gt;).&lt;/p&gt;

&lt;p&gt;But do we really need to search the entire authors table for each publication?
“Edgar Codd” appears in the publications table twice &amp;ndash; why do we need to scan
the authors table for the same name more than once? After we find Edgar the
first time, there should be some way of recording where he was so we can find
him again. And even if there were no repeated author names in publications, it
still seems wasteful to loop over the authors table over and over again. There
must be some way of avoiding all of these repeated scans.&lt;/p&gt;

&lt;p&gt;And there is; we can use a &lt;em&gt;hash table&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Avoiding Repeated Scans&lt;/h2&gt;

&lt;p&gt;The problem with our naive algorithm, the conceptual model from the Postgres
documentation, is that we loop over the authors table over and over again. To
avoid those repeated loops, imagine if we scanned the authors only once and
then saved them in some kind of data structure:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/bag1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now that we have the author records, what do we need to do with them? Well, we
have to scan the publications, obtain each publication’s author, and find the
matching author records, if any. In other words, we need to be able to quickly
and easily find the author record with a given name:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/bag2.png"/&gt;&lt;/p&gt;

&lt;p&gt;You’ve probably seen this data structure before; in fact, it might be something
you use everyday in your own code. If you’re a Rubyist like me, you call this a
&lt;em&gt;hash&lt;/em&gt;. If you prefer Python it’s a &lt;em&gt;dictionary&lt;/em&gt;, or in Clojure it’s &lt;em&gt;hash map&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;With all the authors organized by their names, we can scan over the
publications and quickly find out if there’s a matching author record:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/bag3.png"/&gt;&lt;/p&gt;

&lt;p&gt;But what are hash tables, exactly? And how do they work? If only we could go
back in time and sneak back into our college Computer Science classroom again.
But if you installed Postgres from source, using Homebrew or with some Linux
package manager, you already have an open source, world class implementation of
the hash table algorithm right on your computer! To learn more about it
all we have to do is read the Postgres source code.&lt;/p&gt;

&lt;h2&gt;Calculating Hashes&lt;/h2&gt;

&lt;p&gt;It turns out that for this query Postgres actually hashes the publications and
then iterates over the authors. Before starting to execute a query, Postgres
first parses the SQL we give it and generates a “query plan.” Probably because
the publications table is larger (I’m not sure), Postgres’s query planner
decides to save the publications, not the authors, in the hash table.&lt;/p&gt;

&lt;p&gt;To do this, Postgres has to scan the publications just as we did above:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan4.png"/&gt;&lt;/p&gt;

&lt;p&gt;And for each publication, Postgres selects just two of the three columns:
author and title. Postgres refers to the query plan and finds out it will need
the author for the &lt;span class="code"&gt;WHERE&lt;/span&gt; join condition, and the
title for the final &lt;span class="code"&gt;SELECT&lt;/span&gt; returning the result set.
It leaves the year values behind.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/project1.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 20px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/codd.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Edgar Codd&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;This process of selecting the desired attributes from the matching pair is
known in the Postgres C source code as a &lt;em&gt;projection&lt;/em&gt;. We “project” a few values
from one set of columns to another. (The term &lt;em&gt;project&lt;/em&gt; is actually much older
even than Postgres; Edgar Codd first used it in this context in &lt;a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf"&gt;A Relational
Model of Data for Large Shared Data
Banks&lt;/a&gt; back in 1970.)&lt;/p&gt;

&lt;p&gt;Next Postgres calculates a &lt;em&gt;hash&lt;/em&gt; based on the author string. A hash is some
integer value that can be calculated quickly in a repeatable, reproducible way.
For the same author string, e.g. “Edgar Codd,” Postgres always calculates the
same hash number. As we’ll see in a moment, Postgres uses the hash value to
decide where to save the author name in the hash table.&lt;/p&gt;

&lt;p&gt;You can find Postgres’s hash algorithm in a C file called hashfunc.c. Even if
you’re not a C developer, there are extensive code comments explaining what’s
going on, along with a link to &lt;a href="http://burtleburtle.net/bob/hash/doobs.html"&gt;an article written by Bob
Jenkins&lt;/a&gt;, who developed the
algorithm in 1997.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;hash_any&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/hashfunc_8c.html#a364b7d134ec3c770a3b40abf15b05d37"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2015/11/24/hash_any.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;In my example, Postgres passes “Edgar Codd,” the string value in the author
column in the first publication record, to &lt;span class="code"&gt;hash_any&lt;/span&gt;.
The complex bitwise calculations in &lt;span class="code"&gt;hash_any&lt;/span&gt; step
over the characters in Edgar’s name and return this hash value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/hash1.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Using a Bitmask to Choose a Hash Bucket&lt;/h2&gt;

&lt;p&gt;Now that it has a hash, what does Postgres do with it? You can see a clue above
in the C comments:&lt;/p&gt;

&lt;blockquote&gt;
The best hash table sizes are powers of 2.  There is no need to do mod a prime
(mod is sooo slow!). If you need less than 32 bits, use a bitmask.
&lt;/blockquote&gt;


&lt;p&gt;A hash table consists of an array of “buckets,” which are a series of pointers
to linked lists. Initially Postgres creates an empty array of bucket pointers
just before starting to scan the publications:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/buckets1.png"/&gt;&lt;/p&gt;

&lt;p&gt;As you can guess, Postgres saves each publication in one of the buckets in the
hash table, based on the calculated hash value. Later when it scans over the
authors, it will be able to find the publications again quickly by
recalculating the same hash values. Instead of scanning over all of the
publications again, Postgres can just look up each publication’s author using
the hash. The hash is a record of where each publication is saved in the hash
table.&lt;/p&gt;

&lt;p&gt;However, if two publications turn out to have the same author, as we have in
our example, then Postgres will have to save them both in the same bucket. This
is why each bucket is a linked list; each bucket has to save more than one
publication.&lt;/p&gt;

&lt;p&gt;Because our example has three publications, does Postgres use a hash table with
three buckets? Or with two buckets, because of the repeated author value? No.
It actually uses 1024 buckets! Why 1024? For two reasons: First, Postgres was
designed to query large amounts of data. Its hash join algorithm was optimized
to handle extremely large data sets, containing millions of records or even
more. A table containing three records is truly tiny! Postgres doesn’t bother
with small hash tables and uses a minimum size of 1024.&lt;/p&gt;

&lt;p&gt;And why a power of two? This makes it easier to decide which bucket to use for
a given hash. Instead of trying to return hash values that match the number of
buckets, it’s easier and faster to always returns very large values. What
Postgres does instead is distribute the large hash values evenly over the number
of buckets it does have. By choosing a power of two for the bucket array size,
Postgres can use a fast bitwise operation to decide which bucket to save each
publication in, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/hash2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see how Postgres decides where to put “Edgar Codd” in the hash
table: It subtracts one from the number of buckets: 1024-1 = 1023. Written in
binary this is 1111111111. Then using your microprocessor’s binary computing
circuits, Postgres quickly masks out the left bits, and keeps just the 10 least
significant or rightmost bits. This yields 0000001111 binary, or the number 15.
Using this fast calculation, Postgres decides to save Edgar in bucket #15:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/buckets2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres also saves the title string, because it will need it later to produce
the final result set. Along with the two strings, Postgres saves the hash value
and a “next” pointer that will form the linked list.&lt;/p&gt;

&lt;h2&gt;Building the Rest of the Hash Table&lt;/h2&gt;

&lt;p&gt;Postgres now continues to scan over the publications, arriving at the second
publication.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan5.png"/&gt;&lt;/p&gt;

&lt;p&gt;We have Edgar again! Clearly he was a central figure behind database theory.
Calculating the hash again for the same string will always return the same
value: 2130627599, yielding bucket #15 a second time. We know the Edgar Codd
records will always appear in bucket 15.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/buckets3.png"/&gt;&lt;/p&gt;

&lt;p&gt;Also notice that Postgres saves each new publication at the head of the linked
list &amp;ndash; this means we have the second Edgar publication first on the left, and
Edgar’s first publication second on the right. As we’ll see next, this yields
the reverse order of Edgar’s records we saw above in the conceptual algorithm.&lt;/p&gt;

&lt;p&gt;Finally Postgres continues scanning and saves the third publication in the hash
table; this time Postgres calculates a hash for “Jim Gray:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/hash3.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see this time the 10 rightmost bits of 3344886182 evaluate to 422. So
Postgres saves Jim in bucket #422. Drawing the bucket array more to scale it
might look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/buckets4.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Scanning Buckets&lt;/h2&gt;

&lt;p&gt;After saving all the publications in the hash table, Postgres can now scan over
the authors table:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan6.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now finding the matching publication is simple. Instead of scanning over all
the publications, Postgres simply calls the hash function again on the name
string from the authors table, and repeats the bitmask operation. Because the
first author record is Edgar, Postgres knows the matching publications will be
in bucket #15.&lt;/p&gt;

&lt;p&gt;In our tiny example, the only records in bucket 15 will be for Edgar Codd. But
remember in a large SQL query there might be millions of publications. It’s
possible that publications with different authors might appear in this bucket.
This would happen because either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The hash function returned the same hash number for two different author
strings. This is possible but unlikely. In Computer Science this would be known
as a &lt;em&gt;hash collision&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The 10 least significant bits of the hash were the same. For millions of
publications this would happen frequently. However, as the number of records in
the join increases Postgres uses more and more bits in the bitmask. 1024 (10
bits) was the minimum number it uses for our tiny query. Still, hash table
buckets in practice will contain multiple key values.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Therefore, Postgres has to check each author in the matching bucket to be sure
that it’s a match. This process is known as &lt;em&gt;scanning the bucket&lt;/em&gt;. To do this,
Postgres first checks the hash values:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan-buckets1.png"/&gt;&lt;/p&gt;

&lt;p&gt;This is a simple numerical comparison and so is quite fast. And if the hashes
are the same, Postgres checks the actual strings just in case the hash function
did return the same hash for different strings:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/scan-buckets2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Because the author names match, Postgres can finally perform the join!  To do
this, it projects the columns that our query selects into a single joined
record, in the desired order:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/select2.png"/&gt;&lt;/p&gt;

&lt;p&gt;This becomes the first record in our result set.&lt;/p&gt;

&lt;h2&gt;Returning Multiple Records: The Hash Join State Machine&lt;/h2&gt;

&lt;p&gt;One of the most beautiful and important aspects of the Postgres implementation
is the way it orchestrates building up and searching the hash table in the
midst of a larger enclosing SQL expression. To see this for yourself, take a
look at the hash join implementation, in nodeHashJoin.c.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecHashJoin&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeHashjoin_8c.html#a538698b031186193de7da58537820e61"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2015/11/24/ExecHashJoin.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;Postgres calls &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt; once for each record in the join result set. For
our example with 3 result records Postgres calls &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt; three times.
&lt;span class="code"&gt;ExecHashJoin&lt;/span&gt; keeps track of how many times it has been called, and what it
needs to do next, using a state machine.&lt;/p&gt;

&lt;p&gt;The best way to understand how this state machine works, and how it fits into
the larger structure of Postgres’s architecture, is to imagine that we asked
for one record at a time. For example, imagine that we select just a single
record from the join:&lt;/p&gt;

&lt;pre&gt;
select title, company from publications, authors where author = name limit 1
&lt;/pre&gt;


&lt;p&gt;By appending &lt;span class="code"&gt;limit 1&lt;/span&gt; we tell Postgres to stop after 1
record. For this query, to return just one record, &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt; will use the
following states in its state machine:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/states1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here’s what &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt; does to obtain the first joined record:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class="code"&gt;HJ_BUILD_HASHTABLE&lt;/span&gt;: This code builds the hash table by scanning over all
the publications records, as we saw above. Postgres calls publications the
“inner relation.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class="code"&gt;HJ_NEED_NEW_OUTER&lt;/span&gt;: This code starts scanning the “outer relation” or the
authors table in this example, and returns a single record.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class="code"&gt;HJ_SCAN_BUCKET&lt;/span&gt;: This code takes one outer relation record (an author) and
looks for the matching inner relation records in the hash table (publications).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now imagine that I ask Postgres for two records, by using limit 2:&lt;/p&gt;

&lt;pre&gt;
select title, company from publications, authors where author = name limit 2
&lt;/pre&gt;


&lt;p&gt;The second time Postgres calls &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt;, it only
executes &lt;span class="code"&gt;HJ_NEED_NEW_OUTER&lt;/span&gt; and &lt;span
class="code"&gt;HJ_SCAN_BUCKET&lt;/span&gt; &amp;ndash; it already created the hash table the
first time it was called:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/11/24/states2.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres pays the large price of scanning the entire inner relation and
building the hash table as soon as you ask for one record. Returning the second
and all subsequent records is much faster because Postgres already has the hash
table.&lt;/p&gt;

&lt;p&gt;If you read the C code you’ll see some interesting optimizations. For example,
Postgres actually scans the outer relation first to get a single record, just
in case it might be empty. (This is what the C comment above refers to.)
There’s no need to build a hash table if we’re not going to look up any values!
Also, the &lt;span class="code"&gt;HJ_FILL_INNER&lt;/span&gt; and &lt;span
class="code"&gt;HJ_FILL_OUTER&lt;/span&gt; states handle executing right
or left outer joins respectively. &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt;
implements these as well.&lt;/p&gt;

&lt;p&gt;By using a state machine like this Postgres can execute this join inside the
context of a large, complex SQL statement. It could be that we are joining
together result sets from complex inner SQL clauses, or that the result set
from this join becomes part of a larger expression. The state inside of &lt;span
class="code"&gt;ExecHashJoin&lt;/span&gt; allows Postgres to keep track of what is was
doing &amp;ndash; and of what it needs to do next &amp;ndash; in the appropriate place on the
execution stack.&lt;/p&gt;

&lt;h2&gt;What’s Next?&lt;/h2&gt;

&lt;p&gt;The last state value handled by &lt;span class="code"&gt;ExecHashJoin&lt;/span&gt;,
HJ_NEED_NEW_BATCH, handles the case where the hash table doesn’t fit into
the server’s memory. In this case, Postgres will create a series of hash tables
and save some of them out to disk in “batch files.” This algorithm is what the term
&lt;a href="https://en.wikipedia.org/wiki/Hash_join"&gt;Hybrid Hashjoin&lt;/a&gt; refers to.&lt;/p&gt;

&lt;p&gt;When I have time, I’d love to write about how Postgres handles a large join
instead of a tiny one: How do batch files work? What configuration settings
have an effect on batch files and join performance? And there’s also an
interesting optimization Postgres uses for frequently occurring join key
values.&lt;/p&gt;

&lt;p&gt;Postgres does some amazing things internally to speed up your queries; it’s
time to shed some light on the great work the Postgres open source community
has done over the years!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What Do Perl and Go Have in Common?</title>
    <link href="http://patshaughnessy.net/2015/9/25/what-do-perl-and-go-have-in-common" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/9/25/what-do-perl-and-go-have-in-common</id>
    <published>2015-09-25T00:00:00Z</published>
    <updated>2015-09-25T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;TL/DR:&lt;/strong&gt; &lt;em&gt;Both Perl and Go only partially implement object oriented
programming, in a confusing way. Using either language you can create
structures equivalent to objects but without using keywords such as &lt;span
class="code"&gt;class&lt;/span&gt; or &lt;span class="code"&gt;new&lt;/span&gt;.  Converting a Go
function into a method by adding a receiver reminds me of &amp;ldquo;blessing&amp;rdquo; a Perl has</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;TL/DR:&lt;/strong&gt; &lt;em&gt;Both Perl and Go only partially implement object oriented
programming, in a confusing way. Using either language you can create
structures equivalent to objects but without using keywords such as &lt;span
class="code"&gt;class&lt;/span&gt; or &lt;span class="code"&gt;new&lt;/span&gt;.  Converting a Go
function into a method by adding a receiver reminds me of &amp;ldquo;blessing&amp;rdquo; a Perl hash
reference.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It’s hard to imagine two programming languages that are more different. Larry
Wall created Perl  almost 30 years ago in 1987. Google introduced Go much more
recently in 2009. Perl is a dynamic, interpreted language while Go uses a
compiler and static types. Perl syntax is quirky, fun and sometimes bizarre,
while Go syntax is clean and simple, almost boring at times.&lt;/p&gt;

&lt;p&gt;This year, coincidentally, I tried to learn both Perl and Go around the same
time. Oddly, I found something in common between these two dramatically
different languages. They both allow you to create objects and to write
methods, but without supporting &lt;span class="code"&gt;class&lt;/span&gt;, &lt;span
class="code"&gt;new&lt;/span&gt; or other keywords found in traditional object oriented
languages like Smalltalk, Java, Ruby or Python.  Both languages leave the door
partially open to object oriented design, but don’t provide the syntax or
features you expect and need for using objects and classes.&lt;/p&gt;

&lt;h2&gt;Writing a Perl Function&lt;/h2&gt;

&lt;p&gt;Let’s suppose I want to calculate the density of Jupiter, based on its mass and
diameter. Using Perl, I could write:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl1.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 25px 8px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/9/25/vw.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;
  Writing Perl feels like riding a vintage VW bus. Things don’t&lt;br/&gt;
  work the way you expect, but you can always feel the love.
&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;As you can see, Perl’s syntax is somewhat odd: The &lt;span class="code"&gt;my&lt;/span&gt;
keyword indicates each variable belongs to the local lexical scope. The &lt;span
class="code"&gt;shift&lt;/span&gt; keywords pull the mass and radius values from an
array of values Perl implicitly passes to every function &amp;ndash; Perl functions
always take a single array argument! And you have to prefix all of the
identifiers with either a &lt;span class="code"&gt;$,&lt;/span&gt; &lt;span
class="code"&gt;@&lt;/span&gt; or &lt;span class="code"&gt;%&lt;/span&gt; character to indicate
whether it is a scalar (simple value), an array or a hash. Sometimes in more
complex Perl code you have to combine these prefixes together in cryptic
patterns, such as &lt;span class="code"&gt;@$var&lt;/span&gt;, or &lt;span
class="code"&gt;%$var&lt;/span&gt;. Thankfully in this simple function I just use
numeric values, so &lt;span class="code"&gt;$&lt;/span&gt; is sufficient.&lt;/p&gt;

&lt;p&gt;To me, Perl feels like an old-fashioned, awkward version of Ruby. And this
makes some sense. Perl was to some extent the model for both Ruby and Python,
which were created just a few years after Perl in the early 1990s. Ruby and
Python smoothed out the rough edges of Perl’s syntax (along with adding proper
support for objects among other things).&lt;/p&gt;

&lt;h2&gt;Creating a Perl Object&lt;/h2&gt;

&lt;p&gt;Now I decide to use an object oriented style instead. I want a Jupiter object
which has mass and radius attributes, and I’d like the density function to be a
method, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl2.png"/&gt;&lt;/p&gt;

&lt;p&gt;In other words, I’d like to think of &lt;span class="code"&gt;$jupiter&lt;/span&gt; as an
instance of the Planet class.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/jupiter-class.png"/&gt;&lt;/p&gt;

&lt;p&gt;By writing a &lt;span class="code"&gt;Planet&lt;/span&gt; class, I group together data
values that describe each planet (mass and radius) with the functions that use
those values (density).  Object oriented languages refer to the data values as
&lt;em&gt;instance variables&lt;/em&gt;, and the functions as &lt;em&gt;methods&lt;/em&gt;. By creating a class, I now
have a natural place to gather functions and attributes related to planets.&lt;/p&gt;

&lt;p&gt;The problem is that Perl isn’t an object oriented language. There’s no way to
declare a class, define methods or create objects which are instances of that
class. However, a few years after Perl was invented, in the mid 1990s, Larry
Wall and the Perl team introduced some support for object oriented programming
concepts in Perl 5. They converted Perl into an object oriented language after
the fact &amp;ndash; at least a partially object oriented language.&lt;/p&gt;

&lt;p&gt;To create a Perl class, I first group my planet functions together using the Perl &lt;span class="code"&gt;package&lt;/span&gt; keyword. In this example I have only one:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl3.png"/&gt;&lt;/p&gt;

&lt;p&gt;This gives me a place to put all of the methods of the &lt;span
class="code"&gt;Planet&lt;/span&gt; class &amp;ndash; the &lt;span class="code"&gt;package&lt;/span&gt;
keyword plays the same role the &lt;span class="code"&gt;class&lt;/span&gt; keyword would
in Java or Ruby, to some extent. Also notice that I’ve rewritten my function to
use object oriented syntax.  Instead of obtaining the mass and radius from the
parameters array, I get a single parameter which I call &lt;span
class="code"&gt;$self&lt;/span&gt;. Then I use &lt;span class="code"&gt;$self&lt;/span&gt; as a hash
reference to get the mass and radius values, for example: &lt;span
class="code"&gt;$self-&gt;{&amp;lsquo;mass&amp;rsquo;}&lt;/span&gt;. This is object oriented code. I’ve created
a class and added a method to it.&lt;/p&gt;

&lt;p&gt;However, let’s think about this for another moment:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice there’s a difference between what I want to say, and the words I have to
use to say it. The Perl language doesn’t include the &lt;span
class="code"&gt;class&lt;/span&gt; keyword; instead, I need to use &lt;span
class="code"&gt;package&lt;/span&gt;. We’ll see this again in a moment.&lt;/p&gt;

&lt;p&gt;To create an instance of my new &lt;span class="code"&gt;Planet&lt;/span&gt; class, an
object, I need to create a hash (technically a reference to a hash) and then
“bless” it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl4.png"/&gt;&lt;/p&gt;

&lt;p&gt;This creates a connection between the hash (the object) and the package that
contains the methods I want to use (the class). Now I can use syntax such as
&lt;span class="code"&gt;$jupiter-&gt;density()&lt;/span&gt;. I’ve done it! I’ve created an object using Perl.&lt;/p&gt;

&lt;p&gt;However, once again the language doesn’t supply the words I want to use to
express the idea I’m thinking of:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words2.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Expressing Object Oriented Concepts Using Perl&lt;/h2&gt;

&lt;p&gt;Here’s the complete, object oriented version of my example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl5.png"/&gt;&lt;/p&gt;

&lt;p&gt;To me, the Perl code I wrote above seems very confusing. But it’s not Perl’s
strange, old-fashioned syntax that confuses me. After a while, all the &lt;span
class="code"&gt;$&lt;/span&gt; symbols and the use of &lt;span class="code"&gt;shift&lt;/span&gt;
start to make sense. Writing Perl code is a bit like writing Ruby code while on
drugs &amp;ndash; I start with Ruby and just keep adding &lt;span class="code"&gt;$&lt;/span&gt; and
semicolon characters until it works.&lt;/p&gt;

&lt;p&gt;The real problem in this example is that Perl allows me to create objects and
classes, but doesn’t refer to them as objects or classes. Instead, I have
“blessed references” and “packages.” Perl allows me to get the object oriented
behavior I want, but doesn’t let me use the words I want to use to describe
what I’m doing. Perl’s partial support of object oriented programming is
confusing at best.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: Perl 6, under development for the last fifteen years and still not
released, is planning to introduce more explicit support for objects using the
&lt;span class="code"&gt;class&lt;/span&gt; and &lt;span class="code"&gt;new&lt;/span&gt; keywords.&lt;/em&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 25px 8px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/9/25/driverless-car.png"&gt;&lt;br/&gt;
  &lt;i&gt;
Writing Go code feels like riding in a Google driverless car:&lt;br/&gt;
the compiler and &lt;span class="code"&gt;gofmt&lt;/span&gt; tool are in complete control.
  &lt;/i&gt;
&lt;/div&gt;


&lt;h2&gt;Creating a Go Object&lt;/h2&gt;

&lt;p&gt;Perl was invented many years ago. Now let’s try using a modern, new programming
language to write the same example: Go. Along the way I’ll compare the Go
version with the Perl code I wrote above.&lt;/p&gt;

&lt;p&gt;Earlier using Perl I had to use the &lt;span class="code"&gt;package&lt;/span&gt; keyword
to define a place to put my class’s methods. In Go, I define a group of
methods in a different way: by associating them with a type. Therefore, I’ll
start my Go code by creating a &lt;span class="code"&gt;Planet&lt;/span&gt; type:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/go1.png"/&gt;&lt;/p&gt;

&lt;p&gt;The two versions look very different. In Go I define a static type that always
consists of mass and radius values, while in Perl I dynamically create a hash
that might contain any values.&lt;/p&gt;

&lt;p&gt;Once again, however, I’m forced to think about my code one way and write it
another:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words3.png"/&gt;&lt;/p&gt;

&lt;p&gt;What Go and Perl really have in common is this: Neither language contains the
words and syntax I really would like to use to express the object oriented
concepts I’m trying to use.&lt;/p&gt;

&lt;p&gt;So far I’ve created a type, a static collection of values. Let’s take the next
step and convert that into a class:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/go2.png"/&gt;&lt;/p&gt;

&lt;p&gt;In Go I don’t need to connect my instance data with the class; the mass and
radius values are already contained inside the &lt;span class="code"&gt;Planet&lt;/span&gt;
struct type. Instead, I need to create a connection between the method and the
class. I do this by typing in a receiver for the Density function, &lt;span
class="code"&gt;func (p Planet) Density()&lt;/span&gt;, converting it into a method of
the Planet type.&lt;/p&gt;

&lt;p&gt;In Perl I “bless” a hash by connecting it to a group of functions in a package.
A blessed hash is an object in Perl. In Go I “bless” a function by connecting
it to a type containing instance data. A blessed function combined with a type
is a class in Go. The two languages both use special syntax tricks to allow for
object oriented programming, but they make the connection between instance
variables and methods from opposite directions.&lt;/p&gt;

&lt;p&gt;Once again, however, there’s an impedance mismatch between the concepts I’m
imagining and the words I have to use to to express them:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Go doesn’t provide me with the vocabulary I want to use. I want to type &lt;span
class="code"&gt;class&lt;/span&gt;, but Go only allows me to use &lt;span class="code"&gt;type
struct&lt;/span&gt;. And because there’s no &lt;span class="code"&gt;class&lt;/span&gt; keyword,
my blessed function, my method, could be anywhere and not necessary right next
to my type definition.&lt;/p&gt;

&lt;h2&gt;Expressing Object Oriented Concepts Using Go&lt;/h2&gt;

&lt;p&gt;Here’s the complete, object oriented version of my example in Go:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/go3.png"/&gt;&lt;/p&gt;

&lt;p&gt;I find this Go code just as confusing and misleading as the Perl version above,
and for the same reason. Both Perl and Go take the first step towards object
oriented programming, but stop short of providing a complete solution. Instead
of objects, Go gives us C-style static structures which can have methods
associated with them. And Go doesn’t provide classes at all: There’s no natural
place to gather all of the methods belonging to a given type.&lt;/p&gt;

&lt;p&gt;We can guess that Perl 5 didn’t introduce proper support for object oriented
programming either because it was too difficult to add it to an existing
language, or for backward compatibility reasons. But the &lt;a href="http://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html"&gt;designers of Go
decided from the very
beginning&lt;/a&gt;
not to support classes or objects. Then, why support methods at all? Why allow
developers to create object-like structures, but with a confusing syntax? Or
why not go all the way and introduce the &lt;span class="code"&gt;class&lt;/span&gt;
keyword to properly support object structures?&lt;/p&gt;

&lt;div style="float: right; padding: 25px 8px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/9/25/jupiter.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;
The density of Jupiter is 1,326 kg/m&lt;sup&gt;3&lt;/sup&gt;, only &lt;br/&gt;
1/4th the density of Earth. (source: &lt;a
href="http://nssdc.gsfc.nasa.gov/planetary/factsheet/jupiterfact.html"&gt;NASA&lt;/a&gt;).
&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Go’s tepid, partial support for object oriented programming reminds me of Perl.
Writing a Go function and making it special &amp;ndash; “blessing” it &amp;ndash; by assigning it a
receiver reminds me of how I would bless a hash in a Perl program. Perhaps
Google used Perl as design inspiration for Go; perhaps they wanted to include a
small bit of Perl’s quirky, bizarre but lovable behavior in Go.&lt;/p&gt;

&lt;p&gt;Regardless, don’t stretch your programming language by using it in ways it
wasn’t intended to be used. And certainly don’t change your ideas and solutions
to fit any given programming language. Choose the programming language that has
keywords and syntax that allow you to express your ideas in a natural,
straightforward manner. The only purpose of a language, whether a human
language or programming language, is to express our abstract thoughts using
words in simple, or even beautiful, ways.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Don’t Let Your Data Out of the Database</title>
    <link href="http://patshaughnessy.net/2015/6/18/dont-let-your-data-out-of-the-database" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/6/18/dont-let-your-data-out-of-the-database</id>
    <published>2015-06-18T00:00:00Z</published>
    <updated>2015-06-18T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/escape.png"&gt;&lt;br/&gt;
  &lt;i&gt;Don’t let your data escape from your database&lt;br/&gt;
  and cause unintended performance mistakes.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Keep your data in the database, not for security reasons but to avoid
performance mistakes. Often the best way to speed up your applicati</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/escape.png"&gt;&lt;br/&gt;
  &lt;i&gt;Don’t let your data escape from your database&lt;br/&gt;
  and cause unintended performance mistakes.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Keep your data in the database, not for security reasons but to avoid
performance mistakes. Often the best way to speed up your application is to let
your database server do what it was designed to do: operate on data.&lt;/p&gt;

&lt;p&gt;Most modern programming languages and frameworks hide databases behind an
elegant, beautiful layer of abstraction. Developers today don’t need to write
or even understand Structured Query Language (SQL), the native language of
database servers. We view SQL as a low-level, technical relic of 1970s Computer
Science, best left behind in academic journals and college classrooms.&lt;/p&gt;

&lt;p&gt;However, not learning and thoroughly understanding SQL would be a tremendous
mistake. In fact, many data related performance problems are a result of using
a high level language, such as Ruby or Python, to work with data instead of
SQL. Keep your data where it belongs… in the database. Use your database server
to operate on your data in place, and then fetch the result your application
actually needs.&lt;/p&gt;

&lt;p&gt;Let me show you what I mean with a simple example.&lt;/p&gt;

&lt;div style="clear: both"&gt;&lt;/div&gt;


&lt;h2&gt;Posts and Comments&lt;/h2&gt;

&lt;p&gt;Suppose I have data in a one-many relationship: one post has many comments.
Using ActiveRecord, the popular Ruby ORM, I implement a one-many association by
writing:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Post&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Base&lt;/span&gt;
  has_many &lt;span class="symbol"&gt;:comments&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Comment&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Base&lt;/span&gt;
  belongs_to &lt;span class="symbol"&gt;:post&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Ruby’s powerful dynamic behavior allows me to query the comments for a given
post in a very natural, human way:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post = &lt;span class="constant"&gt;Post&lt;/span&gt;.find(&lt;span class="integer"&gt;1&lt;/span&gt;)
post.comments
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;But remember ActiveRecord isn’t a magic framework. It doesn’t have a secret
connection to the tables in my database. It has to speak to the database server
like everyone else, using the server’s language: SQL. Reading my log file, I
can see how ActiveRecord translates &lt;span class="code"&gt;post.comments&lt;/span&gt; into SQL:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="class"&gt;select&lt;/span&gt; comments.* &lt;span class="keyword"&gt;from&lt;/span&gt; comments &lt;span class="keyword"&gt;where&lt;/span&gt; comments.post_id = &lt;span class="integer"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;After executing this SQL statement, ActiveRecord converts the result set into
an array of Ruby objects which I can then use in my code. For example, if I
want the latest comment for a post I can write:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Post&lt;/span&gt;
  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;latest_comment&lt;/span&gt;
    comments.max {|a, b| a.updated_at &amp;lt;=&amp;gt; b.updated_at }
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Here I ask Ruby to sort the comment objects and return the latest one, the
comment with the maximum &lt;span class="code"&gt;updated_at&lt;/span&gt; value. Now I can
find the person who wrote the latest comment for a post just by writing:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post.latest_comment.author
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;





&lt;div style="float: right; padding: 7px 0px 50px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/open-cell.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;h2&gt;Where Is My Data?&lt;/h2&gt;

&lt;p&gt;The problem with this approach is that it doesn’t scale. Suppose this post has
hundreds or even thousands of comments; in this case, ActiveRecord will convert
them all into Ruby objects just so I can iterate through them in the
&lt;span class="code"&gt;latest_comment&lt;/span&gt; method.&lt;/p&gt;

&lt;p&gt;My mistake was to let my data out of the database. Instead, I should have asked
the database do the work for me.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at how &lt;span class="code"&gt;latest_comment&lt;/span&gt; works:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/filter-sort.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the right, I start with all of the comments in the database, tens of
thousands of them let’s say. Next, I need to search for the comments associated
with my post, filtering on the &lt;span class="code"&gt;post_id&lt;/span&gt; column. This
yields a subset, hundreds of comments for example. Finally, I sort these
filtered comments and take the last one, yielding the latest one on the left.&lt;/p&gt;

&lt;p&gt;The problem with my Ruby solution is that I perform the filtering in the
database, but the sorting in Ruby. In between, the entire subset of comments
for a post have to be transmitted from the database server to my Ruby
application server:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/ruby-sort.png"/&gt;&lt;/p&gt;

&lt;p&gt;To transmit all of these records, the database needs to serialize them to some
binary format, which my Ruby code (or my DB driver actually) later needs to
unpack. Finally, ActiveRecord has to convert this binary data into Ruby
objects.&lt;/p&gt;

&lt;p&gt;This process takes time; in particular, creating hundreds or thousands of Ruby
objects involves allocating a series of memory structures and placing them into
a large array. Using a process called “garbage collection,” Ruby might even
have to find and recycle older unused Ruby objects to hold the comments, which
would take even more time.&lt;/p&gt;

&lt;h2&gt;Databases Are Faster Than You Are&lt;/h2&gt;

&lt;p&gt;The solution is obvious: perform the search inside the database and only return
the latest comment. But how do I ask my database server to search for the
latest comment? By using ActiveRecord methods such as &lt;span class="code"&gt;where&lt;/span&gt;,
&lt;span class="code"&gt;order&lt;/span&gt; and &lt;span class="code"&gt;first&lt;/span&gt; to describe
what I want, instead of writing my own code in Ruby. This line will do the
trick:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post.comments.order(&lt;span class="key"&gt;updated_at&lt;/span&gt;: &lt;span class="symbol"&gt;:desc&lt;/span&gt;).first
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;ActiveRecord translates this into SQL code as follows:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="class"&gt;select&lt;/span&gt; comments.* &lt;span class="keyword"&gt;from&lt;/span&gt; comments
&lt;span class="keyword"&gt;where&lt;/span&gt; comments.post_id = &lt;span class="integer"&gt;1&lt;/span&gt;
&lt;span class="keyword"&gt;order&lt;/span&gt; &lt;span class="keyword"&gt;by&lt;/span&gt; comments.updated_at &lt;span class="directive"&gt;desc&lt;/span&gt; limit &lt;span class="integer"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;This will run much faster than my previous solution, because my database only
transmits one comment record over the network to my Ruby server: the latest
one. And Ruby only creates one Ruby object, for the latest comment:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/db-sort.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now highly optimized C code, running on the same server that holds the comments
table data, filters the comments by post, and sorts the matches by timestamp.
This code has been used and tested by millions of developers around the world
for years; don’t try to reinvent the wheel by rewriting the sort yourself using
Ruby.&lt;/p&gt;

&lt;h2&gt;Caching the Latest Comment&lt;/h2&gt;

&lt;p&gt;Suppose in my user interface I always show the author of the latest comment
next to each post. Now to display my page, I need to perform this comment
search over and over again for every post. One way to avoid the comment query
altogether would be to cache the latest comment’s author right inside the posts
table. That way I’ll get the latest comment’s author automatically when I load
the posts. No need for repeated searches, or any queries on the comments table
at all!&lt;/p&gt;

&lt;p&gt;In practice, if I’ve remembered to create indexes on the &lt;span
class="code"&gt;post_id&lt;/span&gt; and &lt;span class="code"&gt;updated_at&lt;/span&gt; columns,
the comment search SQL above will run very quickly, even if I execute it many
times. I could even load the latest comments for all the posts using single SQL
query, but for the sake of argument today, let’s explore a caching solution anyway.&lt;/p&gt;

&lt;p&gt;Again ActiveRecord makes this easy. All I need to do is write a migration like
this:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;AddLatestCommentAuthorToPosts&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Migration&lt;/span&gt;
  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;change&lt;/span&gt;
    add_column &lt;span class="symbol"&gt;:posts&lt;/span&gt;, &lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, &lt;span class="symbol"&gt;:string&lt;/span&gt;
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Now I just need to be sure to update the post each time a user writes a new
comment:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post.update_attribute(&lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;user name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;h2&gt;Data Migration Using Ruby&lt;/h2&gt;

&lt;p&gt;Of course, I forgot something important. Using &lt;span
class="code"&gt;update_attribute&lt;/span&gt; I save the author for any new comments,
but what about all of the existing comments? How do I set this column’s initial
value for all the comments already in my database?&lt;/p&gt;

&lt;p&gt;Simple enough: I just add a method to my migration that calls &lt;span class="code"&gt;update_attribute&lt;/span&gt;.
Here’s how to do it:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;AddLatestCommentAuthorToPosts&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Migration&lt;/span&gt;
  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;change&lt;/span&gt;
    add_column &lt;span class="symbol"&gt;:posts&lt;/span&gt;, &lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, &lt;span class="symbol"&gt;:string&lt;/span&gt;
    populate_latest_comment_authors
  &lt;span class="keyword"&gt;end&lt;/span&gt;

  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;populate_latest_comment_authors&lt;/span&gt;
   &lt;span class="constant"&gt;Post&lt;/span&gt;.all.each &lt;span class="keyword"&gt;do&lt;/span&gt; |post|
      latest_author = post.comments.order(&lt;span class="key"&gt;updated_at&lt;/span&gt;: &lt;span class="symbol"&gt;:desc&lt;/span&gt;).first.author
      post.update_attribute(&lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, latest_author)
    &lt;span class="keyword"&gt;end&lt;/span&gt;
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Because you write migrations in Ruby, ActiveRecord makes it simple to perform
complex transformations in a simple, elegant way. Using Ruby I get all the
posts, iterate over each one, lookup the latest comment for that post, and
update the latest comment author field.&lt;/p&gt;

&lt;p&gt;But I’ve made the same performance mistake as before! Looking at my Rails log
after running this migration, I find a series of repeated SQL statements:&lt;/p&gt;

&lt;pre&gt;
SELECT  "comments".* FROM "comments"  WHERE "comments"."post_id" = $1  ORDER BY "comments"."updated_at" DESC LIMIT 1  [["post_id", 2]]
UPDATE "posts" SET "latest_comment_author" = $1, "updated_at" = $2 WHERE "posts"."id" = 2  [["latest_comment_author", "Harry"], ["updated_at", "2015-06-17 13:58:42.512160"]]
SELECT  "comments".* FROM "comments"  WHERE "comments"."post_id" = $1  ORDER BY "comments"."updated_at" DESC LIMIT 1  [["post_id", 3]]
UPDATE "posts" SET "latest_comment_author" = $1, "updated_at" = $2 WHERE "posts"."id" = 3  [["latest_comment_author", "Harry"], ["updated_at", "2015-06-17 13:58:42.514676"]]
SELECT  "comments".* FROM "comments"  WHERE "comments"."post_id" = $1  ORDER BY "comments"."updated_at" DESC LIMIT 1  [["post_id", 1]]
UPDATE "posts" SET "latest_comment_author" = $1, "updated_at" = $2 WHERE "posts"."id" = 1  [["latest_comment_author", "Harry"], ["updated_at", "2015-06-17 13:58:42.516071"]]
&lt;/pre&gt;


&lt;p&gt;Again, I’ve let my data out of the database. By loading all of the posts using
&lt;span class="code"&gt;Post.all&lt;/span&gt;, and iterating over them using &lt;span
class="code"&gt;each&lt;/span&gt;, I’ve triggered this series of repeated SQL commands.
Now I’m transmitting all of the post data, and then more data back and forth
for each post between my database and my Ruby application:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/ruby-iterate.png"/&gt;&lt;/p&gt;

&lt;p&gt;Just like my previous code, this migration will perform poorly. If I have just
a few posts it probably doesn’t matter. But imagine if there are thousands or
even 100,000s of post records: This migration might take minutes or even hours
to complete! My database server and Ruby need to serialize, transmit and
deserialize data for each one of these SQL commands.&lt;/p&gt;

&lt;p&gt;There must be a better way.&lt;/p&gt;

&lt;h2&gt;Data Migration Using SQL&lt;/h2&gt;

&lt;p&gt;The solution is the same as before: Don’t let your data out of the database.
Instead of writing Ruby code to update each post record, ask the database
server to do it. My database server already has all my post data in an
optimized format, likely loaded into memory. It can iterate over the posts and
update them very quickly.&lt;/p&gt;

&lt;div style="float: right; padding: 17px 0px 10px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/prison.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;But how? How do I ask the database server to update all the posts? I need to
speak the database’s language: SQL. By writing SQL directly, I can be sure the
database is doing exactly what I want, that it’s using the most efficient
algorithm possible. I can be sure my database and I understand each other.&lt;/p&gt;

&lt;p&gt;Here’s one way to update all the posts using SQL:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="class"&gt;update&lt;/span&gt; posts &lt;span class="class"&gt;set&lt;/span&gt; latest_comment_author = (
  &lt;span class="class"&gt;select&lt;/span&gt; author &lt;span class="keyword"&gt;from&lt;/span&gt; comments
  &lt;span class="keyword"&gt;where&lt;/span&gt; comments.post_id = posts.id
  &lt;span class="keyword"&gt;order&lt;/span&gt; &lt;span class="keyword"&gt;by&lt;/span&gt; comments.updated_at &lt;span class="directive"&gt;desc&lt;/span&gt;
  limit &lt;span class="integer"&gt;1&lt;/span&gt;
)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;This tiny SQL program actually uses SQL commands similar to the what I found
repeated in my log file. But there’s an important difference: This SQL code
doesn’t refer to hard coded post id values, such as 1 or 2. Here I’ve updated
all of the posts with a single command!&lt;/p&gt;

&lt;p&gt;How does this work? Let’s take a look:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/db-iterate.png"/&gt;&lt;/p&gt;

&lt;p&gt;Using a SQL migration, my Ruby code sends a single SQL command to the database
server, which is transmitted over the network to the database. Then, on the
right, my database server performs the same iteration over the posts table,
selecting the latest comment for each one.&lt;/p&gt;

&lt;p&gt;This looks similar, but there’s a crucial difference: The iteration happens
entirely inside the database server. No data needs to be packed, transmitted to
the Ruby server and unpacked again. In fact, the C code performing the repeated
&lt;span class="code"&gt;SELECT&lt;/span&gt; statements has been compiled to native machine
language and will run very quickly. Once it fetches the latest comment, it can
directly update each post because the posts table is stored nearby on the same
server’s hard drive, or even in memory.&lt;/p&gt;

&lt;h2&gt;Why Does the SQL Code Iterate?&lt;/h2&gt;

&lt;p&gt;You might wonder why I drew an iteration inside the database server above.
After all, I sent the database a simple command containing 1 &lt;span
class="code"&gt;UPDATE&lt;/span&gt; statement and 1 &lt;span class="code"&gt;SELECT&lt;/span&gt;
statement. Why does my database need to execute the select over and over again?&lt;/p&gt;

&lt;p&gt;The reason why is that my SQL code uses a &lt;a href="https://en.wikipedia.org/wiki/Correlated_subquery"&gt;correlated
subquery&lt;/a&gt;, because the inner
&lt;span class="code"&gt;SELECT&lt;/span&gt; uses a value from the outer query. Here’s the
SQL again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/correlated-subquery.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice the inner &lt;span class="code"&gt;SELECT&lt;/span&gt; statement refers to &lt;span
class="code"&gt;posts.id&lt;/span&gt;, a value from the surrounding &lt;span
class="code"&gt;UPDATE&lt;/span&gt; statement.  This requires the database server to
iterate over all of the posts, executing the inner select for each row. I’ll
leave it as an exercise for the reader to rewrite this using an &lt;span
class="code"&gt;UPDATE-FROM&lt;/span&gt; statement, a &lt;span class="code"&gt;JOIN&lt;/span&gt; or
even Postgres window functions, which would avoid the repeated &lt;span
class="code"&gt;SELECT&lt;/span&gt;s.&lt;/p&gt;

&lt;p&gt;However, remember if there are indexes on the columns in the comments table,
the iteration selecting the latest comment for each post will be very fast. It
will certainly be thousands of times faster than sending repeated &lt;span
class="code"&gt;SELECT&lt;/span&gt; and &lt;span class="code"&gt;UPDATE&lt;/span&gt; SQL statements
from your Ruby server over the network.&lt;/p&gt;

&lt;h2&gt;Do You Need to Learn SQL?&lt;/h2&gt;

&lt;p&gt;In reality I could have written this data migration using Ruby code.
ActiveRecord provides a rich set of methods, even allowing for sophisticated
queries employing subselects. And in the rare case when
ActiveRecord can’t generate the SQL I need, I can always resort to using the
underlying &lt;a href="https://github.com/rails/arel"&gt;Arel&lt;/a&gt; Ruby library. In practice,
it’s rare that you will actually need to write SQL code inside a Rails
application.&lt;/p&gt;

&lt;p&gt;Then why learn SQL? You should learn SQL because it will give you tremendous
insight into how database servers actually work. You’ll learn what database
servers can really do, and what they can’t. You won’t try to reinvent the wheel
when you already have a server that uses algorithms more powerful and
sophisticated that any you could write.&lt;/p&gt;

&lt;p&gt;Use the database server for what it was designed to do: to solve your data
problems. Whether you write SQL directly or use a tool like ActiveRecord to
generate SQL automatically, perform the search, sort, or calculation you need
right inside the database.&lt;/p&gt;

&lt;p&gt;Don’t let your data out of the database until you need to… until you have just
the values your application really needs.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Mark Methods Private When You Don’t Test Them</title>
    <link href="http://patshaughnessy.net/2015/2/16/mark-methods-private-when-you-dont-test-them" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/2/16/mark-methods-private-when-you-dont-test-them</id>
    <published>2015-02-16T01:00:00Z</published>
    <updated>2015-02-16T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/2/16/plaza-de-la-merced.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;My father in law once lived in same building where Picasso&lt;br/&gt;was born, near the Plaza de la Merced in Málaga, Spain.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;In Ruby and many other languages, you write private methods to implement
internal logic you don’t want</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/2/16/plaza-de-la-merced.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;My father in law once lived in same building where Picasso&lt;br/&gt;was born, near the Plaza de la Merced in Málaga, Spain.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;In Ruby and many other languages, you write private methods to implement
internal logic you don’t want to expose. You want the freedom to rename,
repurpose or even delete them without worrying about impacting anything else.
The &lt;span class="code"&gt;private&lt;/span&gt; keyword signals other developers: Don’t rely on this; don’t call
it; it might change. This is especially important when writing framework or
library code that many other developers will use.&lt;/p&gt;

&lt;p&gt;But which methods should you make private? Sometimes this is obvious; sometimes
it isn’t. A good rule of thumb to use is: If you’re not testing a method, it
should be private.&lt;/p&gt;

&lt;br/&gt;


&lt;br/&gt;


&lt;p&gt;But wait a minute! Aren’t we supposed to test everything? Isn’t 100% code
coverage the nirvana every Ruby developer seeks? Let me clarify. You should
mark methods private when you test them indirectly by calling the other, public
methods in the same class. Use the &lt;span class="code"&gt;private&lt;/span&gt; keyword to help organize your code,
to remind yourself what you still need to test, and what you don’t.&lt;/p&gt;

&lt;h2&gt;Three Paintings&lt;/h2&gt;

&lt;p&gt;A simple example will make this clear. Suppose I have a class that describes a
painting:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="constant"&gt;Painting&lt;/span&gt; = &lt;span class="constant"&gt;Struct&lt;/span&gt;.new(&lt;span class="symbol"&gt;:name&lt;/span&gt;, &lt;span class="symbol"&gt;:year&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Now I can create a list of three paintings in a &lt;span
class="code"&gt;Minitest::Spec&lt;/span&gt; file like this:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
let(&lt;span class="symbol"&gt;:one&lt;/span&gt;) { &lt;span class="constant"&gt;Painting&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1900&lt;/span&gt;) }
let(&lt;span class="symbol"&gt;:two&lt;/span&gt;) { &lt;span class="constant"&gt;Painting&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1937&lt;/span&gt;) }
let(&lt;span class="symbol"&gt;:three&lt;/span&gt;) { &lt;span class="constant"&gt;Painting&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1958&lt;/span&gt;) }
let(&lt;span class="symbol"&gt;:paintings&lt;/span&gt;) { [one, two, three] }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Suppose my first requirement is to return the first painting from the list.
Simple enough:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 200px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  list.first
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;should return the first element&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).must_equal one
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;I just call &lt;span class="code"&gt;Array#first&lt;/span&gt; and I’m done. Returning the
rest of the list is slightly more interesting:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 200px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = list
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest of the elements&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).must_equal [two, three]
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Using &lt;a href="http://devblog.avdi.org/2010/01/31/first-and-rest-in-ruby/"&gt;a trick I learned from
Avdi&lt;/a&gt;, &lt;span
class="code"&gt;rest&lt;/span&gt; always returns an array even if the input list was
empty or had only one element. So far, so good. I’ve written two methods and
two tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests.png"/&gt;&lt;/p&gt;

&lt;h2&gt;A New Requirement&lt;/h2&gt;

&lt;p&gt;Now suppose my business requirement changes slightly and I instead need to
return the first painting sorted alphabetically by name. Once again, it’s not
hard to do.&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt;.first
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;should return the first element&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).name.must_equal &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;


&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;And I need &lt;span class="code"&gt;rest&lt;/span&gt; to use the same sort order, so I repeat the call to &lt;span class="code"&gt;sort&lt;/span&gt;:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt; 
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest of the elements&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).map(&amp;amp;&lt;span class="symbol"&gt;:name&lt;/span&gt;).must_equal [
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ]
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;I’ve implemented new behavior, but still have two methods and two tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Extracting a Method&lt;/h2&gt;

&lt;p&gt;Because both of my methods are covered by tests, I’m free to refactor them. I
decide to extract a new method, &lt;span class="code"&gt;sorted_by_name&lt;/span&gt;:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  sorted_by_name(list).first
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = sorted_by_name(list)
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;




&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;sorted_by_name&lt;/span&gt;(list)
  list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;





&lt;div class="CodeRay" style="display: inline-block; width: 400px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the element with the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).name.must_equal &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;

it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest after the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).map(&amp;amp;&lt;span class="symbol"&gt;:name&lt;/span&gt;).must_equal [
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ]
&lt;span class="keyword"&gt;end&lt;/span&gt;







&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Here I’ve simply moved the call to sort into a utility method called
&lt;span class="code"&gt;sorted_by_name&lt;/span&gt;. Now &lt;span class="code"&gt;first&lt;/span&gt;
and &lt;span class="code"&gt;rest&lt;/span&gt; both call &lt;span
class="code"&gt;sorted_by_name&lt;/span&gt;, making the code a bit clearer and DRY-er. But
now I have three methods and only two tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests-three-methods.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Mark Methods Private When You Don’t Test Them&lt;/h2&gt;

&lt;p&gt;Notice I didn’t bother writing a test for &lt;span class="code"&gt;sorted_by_name&lt;/span&gt;. I know it works
because my other tests still pass. The existing tests are sufficient; I am
testing &lt;span class="code"&gt;sorted_by_name&lt;/span&gt; indirectly. Because I extracted &lt;span class="code"&gt;sorted_by_name&lt;/span&gt; from
&lt;span class="code"&gt;first&lt;/span&gt; and &lt;span class="code"&gt;rest&lt;/span&gt;, because I
refactored my code without adding any new behavior, no new test were required.&lt;/p&gt;

&lt;p&gt;In this scenario, take the time to mark the new, untested method as private:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  sorted_by_name(list).first
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = sorted_by_name(list)
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;



private

&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;sorted_by_name&lt;/span&gt;(list)
  list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;





&lt;div class="CodeRay" style="display: inline-block; width: 400px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the element with the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).name.must_equal &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;

it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest after the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).map(&amp;amp;&lt;span class="symbol"&gt;:name&lt;/span&gt;).must_equal [
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ]
&lt;span class="keyword"&gt;end&lt;/span&gt;








&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;The &lt;span class="code"&gt;private&lt;/span&gt; keyword here reminds me I’ve already tested &lt;span
class="code"&gt;sorted_by_name&lt;/span&gt;, that I don’t need to write new tests for
it. Now &lt;span class="code"&gt;private&lt;/span&gt; is helping me organize my code; it’s helping me remember
which methods I don’t need to test… and which methods are missing important
tests.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests-three-methods-private.png"/&gt;&lt;/p&gt;

&lt;p&gt;If my tests don’t need to know about &lt;span class="code"&gt;sorted_by_name&lt;/span&gt;, then certainly other
developers don’t. It should be private. Marking it private reminds me that it
is being tested indirectly, that I didn’t just forget to write a test for it.
Marking it private tells other developers about what I’ve learned from my own
test suite.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using Rake to Generate a Blog</title>
    <link href="http://patshaughnessy.net/2015/1/8/using-rake-to-generate-a-blog" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/1/8/using-rake-to-generate-a-blog</id>
    <published>2015-01-08T01:00:00Z</published>
    <updated>2015-01-08T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/1/8/power-rake.png"&gt;&lt;br/&gt;
  &lt;i&gt;Jim Weirich showing a real power rake at &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;GORUCO 2012&lt;/a&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last year I needed to replace the software I use to serve this web site.
Instead of just using &lt;a href="h</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/1/8/power-rake.png"&gt;&lt;br/&gt;
  &lt;i&gt;Jim Weirich showing a real power rake at &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;GORUCO 2012&lt;/a&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last year I needed to replace the software I use to serve this web site.
Instead of just using &lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt;,
&lt;a href="https://middlemanapp.com"&gt;Middleman&lt;/a&gt;, &lt;a href="http://nanoc.ws"&gt;Nanoc&lt;/a&gt; or one of the
&lt;a href="https://www.ruby-toolbox.com/categories/static_website_generation"&gt;many other available
options&lt;/a&gt;, I
decided to implement my own &lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io"&gt;custom blog
software&lt;/a&gt;. After a
fair amount of work, I was able to implement a static blog site generator using
only &lt;a href="https://github.com/jimweirich/rake"&gt;Rake&lt;/a&gt; and a handful of simple Ruby classes. Although it took a bit longer,
it was a lot of fun and I learned a few tricks which I’d like to pass along
today.&lt;/p&gt;

&lt;p&gt;I first got the idea of using Rake as a static site generator from a
presentation called &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;Power Rake&lt;/a&gt;,
given by the late Jim Weirich at GORUCO 2012. This was one of the first Ruby
conferences I had ever attended, and was also the first time I had ever seen
Jim speak in public. It still stands out in my memory as one of the best
conference presentations I&amp;rsquo;ve ever seen. Funny, engaging, interesting, but most
of all &lt;em&gt;genuine&lt;/em&gt;, Jim had me and the rest of the audience enthralled as he talked
about &lt;a href="https://github.com/jimweirich/rake"&gt;Rake&lt;/a&gt;, his Ruby reinterpretation of
the old C make utility from the 1970s.&lt;/p&gt;

&lt;p&gt;The key idea behind using Rake to generate a static site is to generate and
manipulate files using Rake file tasks. What are file tasks? How are they
different from standard Rake tasks? To find out watch Jim’s presentation, or
read &lt;a href="http://devblog.avdi.org/2014/04/21/rake-part-1-basics/."&gt;an excellent series of articles and
screencasts&lt;/a&gt; by Avdi
Grimm. Today I’ll explain how I used Rake to create this blog. But first, let’s review
what a blog really is.&lt;/p&gt;

&lt;h2&gt;A Blog or a Static Web Site?&lt;/h2&gt;

&lt;p&gt;Most of the blogs in the world consist of a few dynamically generated web pages
served by either &lt;a href="http://wordpress.com"&gt;wordpress.com&lt;/a&gt; or
&lt;a href="http://blogger.com"&gt;blogger.com&lt;/a&gt;. To be honest, I should just use one of these
two free services for my site as well. However, I have a few years worth of
markdown files that contain all of my old content which would be a hassle to
import into whatever format Wordpress or Google uses. Plus using these sites
would be no fun at all; instead, I was looking for an excuse to write some Ruby
code and to learn more about Rake.&lt;/p&gt;

&lt;p&gt;What I really needed was an automated process for converting my markdown source
files into a series of static HTML files that were navigable using URL patterns that
readers expect. That is, I wanted a Rake task that would do this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/convert-file.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the top is one of my markdown files; on the bottom is the HTML version. I
needed a way to generate the bottom file from the top one. I needed to write a Rake
task that would iterate over all of the markdown files in the “posts” directory,
and generate the corresponding HTML files in the proper target directory.  The
markdown file name (“posts/2014-10-13-…”) was a naming convention I used to stay
organized. However, the name and path of the HTML file was what readers would see
in the post’s URL online &amp;ndash; for example:
&lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals&lt;/a&gt;.
This was a problem well suited to Rake file tasks, because they allow you to
create a series of dependencies between source and target files.&lt;/p&gt;

&lt;p&gt;But before I was ready to use file tasks, I needed to use a few tricks to make
those tasks easier to write.&lt;/p&gt;

&lt;h2&gt;Iterating Over Files Using Rake::FileList&lt;/h2&gt;

&lt;p&gt;Ruby objects are easier to work with than text files are, so the first thing I
decided to do was to write a Ruby class that represented one of my markdown
files. I called it &lt;span class="code"&gt;Post&lt;/span&gt; because each markdown file represented a single blog
post.&lt;/p&gt;

&lt;p&gt;Next, I needed to create a post object for each of the files in the posts
directory, by listing the files and iterating over them. It turns out Rake
provides a very simple way to do this: the &lt;span class="code"&gt;Rake::FileList&lt;/span&gt; class. To quote &lt;a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/rake/rdoc/Rake/FileList.html"&gt;the
documentation&lt;/a&gt;:&lt;/p&gt;

&lt;br/&gt;




&lt;blockquote&gt;
A FileList is essentially an array with a few helper methods defined to make file manipulation a bit easier.
&lt;/blockquote&gt;


&lt;p&gt;I like things that are easier. Here’s how I used &lt;span class="code"&gt;FileList&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/mapping-posts.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the left are my markdown files with the corresponding post objects on the right. My
code above first created a &lt;span class="code"&gt;FileList&lt;/span&gt;, using the &lt;span class="code"&gt;posts/*.markdown&lt;/span&gt; pattern. You
can think of the &lt;span class="code"&gt;FileList&lt;/span&gt; as an array of files that match the given pattern.
Once I had this array, I &lt;em&gt;mapped&lt;/em&gt; the array to a second array of ruby objects using
&lt;span class="code"&gt;Enumerable#map&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Blog Post Routing&lt;/h2&gt;

&lt;p&gt;Now that I had a &lt;span class="code"&gt;Post&lt;/span&gt; object for each source markdown file, I could add methods
to the &lt;span class="code"&gt;Post&lt;/span&gt; class to make manipulating the markdown files easier. Most
importantly, what I needed to know for each markdown file is where its HTML
should go in the generated site. That is, I needed to know the URL of the post:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/post-url.png"/&gt;&lt;/p&gt;

&lt;p&gt;This did the trick. The &lt;span class="code"&gt;date&lt;/span&gt; and &lt;span class="code"&gt;title&lt;/span&gt; methods parsed some metadata values I
saved in the markdown file along with the text. The &lt;span class="code"&gt;url&lt;/span&gt; method returned a string using
the year/month/day pattern most people are familiar with. The &lt;span class="code"&gt;slugize&lt;/span&gt; method
removed characters from the title that weren’t compatible with URL strings. As I
explained earlier, the URL is also the file system path for each post’s HTML
file: The single line of code above mapped the posts to an array of strings, each
one the path to an HTML file, the URL of that post appended with a file
extension.&lt;/p&gt;

&lt;h2&gt;Grouping Two Arrays Together&lt;/h2&gt;

&lt;p&gt;Now I had two arrays: &lt;span class="code"&gt;Post&lt;/span&gt; objects and HTML file paths. I was almost ready to
write a Rake file task that would convert the posts into HTML files. But, as
you&amp;rsquo;ll see in a minute, writing a file task requires two files: a source file
and a target file. Somehow I needed to convert these two separate arrays into a
single array of pairs, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/zipping.png"/&gt;&lt;/p&gt;

&lt;p&gt;As you can see, Ruby’s &lt;span class="code"&gt;Enumerable#zip&lt;/span&gt; method was
perfect solution. It yielded object pairs, one object taken from the receiver
(&lt;span class="code"&gt;html_files&lt;/span&gt;) and the other object taken from the
argument (&lt;span class="code"&gt;posts&lt;/span&gt;). If you pass in 2, 3 or more
arguments, it will yield triplets, quadruplets or n-tuples to the block
instead. I first learned about &lt;span class="code"&gt;zip&lt;/span&gt; from Jim Weirich’s
2012 Power Rake presentation; he used it in his static web site example in a
very similar way.  Of course, you can use &lt;span class="code"&gt;zip&lt;/span&gt; to
process multiple arrays for any purpose. It’s one of Ruby’s most beautiful
features I think.&lt;/p&gt;

&lt;h2&gt;Writing Rake File Tasks&lt;/h2&gt;

&lt;p&gt;As you probably know, a standard Rake task runs when you execute the task
directly, or when you run another task that depends on it. A file task,
however, will only execute the Ruby code inside the block if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The source file is newer than the target file, or&lt;/li&gt;
&lt;li&gt;The target file doesn’t exist at all.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This behavior is ideal for generating a static web site, or for any other job
that requires generating a file from another file. Rake will build the target
file for the first time if it doesn’t exist, or update it if the source file
has changed.&lt;/p&gt;

&lt;p&gt;Now that I had pairs of HTML paths and &lt;span class="code"&gt;Post&lt;/span&gt; objects,
it was easy for me to write a file task using one of these pairs. Here’s what I
came up with:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/file-task.png"/&gt;&lt;/p&gt;

&lt;p&gt;By calling &lt;span class="code"&gt;file&lt;/span&gt; inside of the &lt;span class="code"&gt;zip&lt;/span&gt; block, I created a file task for each one
of the paths in &lt;span class="code"&gt;html_files&lt;/span&gt;. Now if I created a single, standard Rake task that
depended on the array of html file paths, I could test whether any or all of the
HTML files needed to be generated:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/rake-posts.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now I could generate all of my blog posts with one command: &lt;span class="code"&gt;rake posts&lt;/span&gt;!&lt;/p&gt;

&lt;h2&gt;Rendering Each Post Using ERB&lt;/h2&gt;

&lt;p&gt;What did the code inside the file task do? It generated the HTML file for a
single post using &lt;span class="code"&gt;ERB&lt;/span&gt;, using a method I wrote called &lt;span class="code"&gt;Layout#render&lt;/span&gt;. If you’re
interested, here’s the &lt;span class="code"&gt;Layout&lt;/span&gt; class (&lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/lib/layout.rb"&gt;github&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/layout.png"/&gt;&lt;/p&gt;

&lt;p&gt;I won’t explain this line by line, but there were a couple of interesting tricks
here also. First, the &lt;span class="code"&gt;contents&lt;/span&gt; method used nested calls to
ERB to render a page layout surrounding the post, along
with the article text itself. This required I call &lt;span
class="code"&gt;yield&lt;/span&gt; somewhere inside my &lt;span class="code"&gt;layout.erb&lt;/span&gt; file in just the same
way I would in &lt;span class="code"&gt;application.html.erb&lt;/span&gt; for a Rails app.&lt;/p&gt;

&lt;p&gt;The complex line of code at the bottom that uses &lt;span class="code"&gt;instance_eval&lt;/span&gt; and
&lt;span class="code"&gt;binding&lt;/span&gt; seems impossible to understand at first. But actually it’s fairly
standard boilerplate Ruby metaprogramming code that evaluates the ERB template
in the context of the &lt;span class="code"&gt;page&lt;/span&gt; object and the current method.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/metaprogramming.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the left I show the the &lt;span class="code"&gt;page&lt;/span&gt; object, an instance of the &lt;span class="code"&gt;Post&lt;/span&gt; class, in the
center the code running the ERB transformation, and on the right the Ruby call
stack.&lt;/p&gt;

&lt;p&gt;The arrow from ERB going to the left represents the use of &lt;span class="code"&gt;instance_eval&lt;/span&gt;. This
method, built into the Ruby language, resets the &lt;span class="code"&gt;self&lt;/span&gt; pointer to the
receiver or the &lt;span class="code"&gt;page&lt;/span&gt; object in this example. This allows the ERB code to access
the instance variables of the &lt;span class="code"&gt;page&lt;/span&gt; object and the methods of the &lt;span class="code"&gt;Post&lt;/span&gt; class.&lt;/p&gt;

&lt;p&gt;The arrow from ERB going to the right, in turn, represents the call to &lt;span class="code"&gt;binding&lt;/span&gt;.
The &lt;span class="code"&gt;binding&lt;/span&gt; method, also part of the Ruby core language, refers to the
current Ruby stack frame allowing the ERB code to access all of the local
variables present there, such as &lt;span class="code"&gt;recent_posts&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;My Rakefile&lt;/h2&gt;

&lt;p&gt;Of course, I’m glossing over some other important details here, such as
generating the index or home page, the RSS feed and a few other things. For
reference, here’s my entire Rakefile (&lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/Rakefile"&gt;github&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/rakefile.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the call to &lt;span class="code"&gt;Layout#render&lt;/span&gt; and the &lt;span class="code"&gt;rake :posts&lt;/span&gt; task I described
above. Here are some other coding details, if you’re interested:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;After creating the &lt;span class="code"&gt;posts&lt;/span&gt; array, I sort it by date, reversed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I generate the home page using another file task: &lt;span class="code"&gt;index.html&lt;/span&gt;, and a &lt;span class="code"&gt;HomePage&lt;/span&gt; class.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I generate the RSS in a similar way using a third file task: &lt;span class="code"&gt;index.xml&lt;/span&gt;, and a &lt;span class="code"&gt;Feed&lt;/span&gt; class.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Ideas, Not Code&lt;/h2&gt;

&lt;p&gt;If you’re interested in using this code for your own site, it’s on &lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io"&gt;github&lt;/a&gt;.
However, I wouldn’t recommended using it: It’s always a better idea to use a
well tested, robust free service such as wordpress.com or Jekyll.&lt;/p&gt;

&lt;p&gt;Instead of using this code, use the ideas behind it! Take the time to use
&lt;span class="code"&gt;Rake::FileList&lt;/span&gt; and Rake file tasks in whatever application you’re working on. And
please take the time to watch the &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;PowerRake presentation&lt;/a&gt;. You’ll learn more about one
of Ruby’s most powerful tools &amp;ndash; and you’ll be able spend some time with Jim.
Jim’s bright personality and sense of humor can live on in our memory, at
least.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Koichi Sasada Encourages Us To Contribute To Ruby</title>
    <link href="http://patshaughnessy.net/2014/12/17/koichi-sasada-encourages-us-to-contribute-to-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/12/17/koichi-sasada-encourages-us-to-contribute-to-ruby</id>
    <published>2014-12-17T01:00:00Z</published>
    <updated>2014-12-17T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div class="epigraph"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/17/microscope.png"&gt;
  &lt;div class="epigraph-text"&gt;Ruby処理系開発コミュニティは、&lt;br/&gt;あなたの挑戦を歓迎する。&lt;/div&gt;
  &lt;div class="epigraph-caption"&gt;
  The Ruby core community welcomes your challenge.
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Today I’m happy to post an English translation of a new appendix to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ru</summary>
    <content type="html">&lt;div class="epigraph"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/17/microscope.png"&gt;
  &lt;div class="epigraph-text"&gt;Ruby処理系開発コミュニティは、&lt;br/&gt;あなたの挑戦を歓迎する。&lt;/div&gt;
  &lt;div class="epigraph-caption"&gt;
  The Ruby core community welcomes your challenge.
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Today I’m happy to post an English translation of a new appendix to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt; written by
Koichi Sasada (&lt;a href="https://twitter.com/_ko1"&gt;@_ko1&lt;/a&gt;), included in the Japanese
edition last month. As you probably know, Koichi is the developer behind the
virtual machine used by Ruby since Ruby 1.9 was released, known as “YARV.” He
writes about the early days of YARV (apparently he wrote the first version
during a single vacation week!) as well as some interesting aspects of its
technical design.&lt;/p&gt;

&lt;p&gt;But what struck me the most about this essay &amp;ndash; what I found encouraging and
inspiring &amp;ndash; was the story about how Koichi first became involved in Ruby
core development. He writes about how certain Ruby meetups and book
clubs created an environment that enabled him to learn and innovate. This
environment lead directly to the development of YARV, which enables all our
Ruby programs to run faster today.&lt;/p&gt;

&lt;p&gt;He concludes with a message for all of us: We should follow in his footsteps
and not be afraid to contribute to Ruby, to create “yet another Ruby
implementation.” Thinking about his story, to do this maybe we need to seek out
&amp;ndash; or to create &amp;ndash; the right learning environment, like the one Koichi found in
Japan 10 years ago. Thanks for writing this, Koichi! I’m happy and proud that
RUM now concludes with this message.&lt;/p&gt;

&lt;p&gt;Japanese-language edition copyright &amp;copy; 2014 by Ohmsha, Ltd. Reproduced with
permission of the copyright owner.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;




&lt;div class="appendix"&gt;A&lt;/div&gt;


&lt;div class="appendix-title"&gt;さらにそのほかの&lt;br/&gt;Ruby仮想マシン&lt;/div&gt;


&lt;br/&gt;


&lt;div class="appendix-translation"&gt;
Yet More Ruby Virtual Machines
&lt;/div&gt;




&lt;div class="jp"&gt;
&lt;p&gt;今回、私（笹田）がYARV：Yet Another RubyVMの開発者であるという縁で、本書の付録にYARVについて寄稿する機会を得た。本書では、多くのページを割いてYARVの中身を解説していただいている。しかも、原著は英語の著作であるので、世界中で読まれていることになる。ソフトウェア開発者として、たいへん光栄であると共に、読みながら実装の非効率な部分などを見つけてしまい、恥ずかしい思いもある。本稿では、YARVについて少し補足する。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;I (Koichi Sasada) am thankful to have a chance to write about YARV in this
appendix as a developer of YARV: Yet Another Ruby VM. Many pages of this book
describe the internals of YARV. Furthermore, the original edition is written in
English and has been read by people all over the world. I am greatly honored by
that as a software developer, although it humbles me to have found several
inefficiencies in YARV’s implementation while reading the book. In this appendix,
I will give some supplemental information and background on the design and
implementation of YARV.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARV: Yet Another RubyVM&lt;/h2&gt;
&lt;p&gt;YARVは、2004年の正月に、その当時より興味のあったRuby向け仮想マシンとして開発に着手し、簡単なものを1週間程度で開発した。おそらく、暇だったのだと思う。最初のアナウンスメール（[ruby-dev:22494]）を見ると、フィボナッチ数を求めるプログラムは動いていたようである。&lt;/p&gt;
&lt;p&gt;開発当初、YARVはRuby 1.8向けの拡張ライブラリとして実装していた。つまり、実行エンジンをすべて差し替えるのではなく、Ruby 1.8処理系から、指定したRubyプログラムをYARV上で実行する、という構造としていた。Ruby 1.8処理系の上に、もう1つRuby処理系を重ねていたことになる。この構造により、十分に安定しているRuby 1.8処理系を用いて、YARVの試験を比較的容易に行うことができた。また、GCやC APIなどの関数といった基盤コードをそのまま利用することもできた。そして、開発が進んだ後、スレッドなどをサポートするため、一気にRuby 1.8処理系のコア部分を取り除き、YARVに置き換えた。しかし、GCなどの基盤コードはその後も流用を続けた。当初より、Rubyインタプリタ（MRI/CRuby）はC言語と親和性の高い処理系として知られているが、YARVもその特長を受け継いでいる。そして、置き換えたものがRuby 1.9としてリリースされ、2014年現在も、RubyVMとして利用されている。&lt;/p&gt;
&lt;p&gt;よく、YARV：Yet Another RubyVMは、公式に取り込まれたので、Yet Anotherな処理系ではないのではないか、という指摘を受けるが、なんとなく語呂が良いので利用を続けている。ただし、ファイル名やクラス名には利用しないようにしている。開発当時、Ruby向け仮想マシンは、既にいくつか提案されていた。特に、Rubyの生みの親であるまつもと氏によるRiteVM、そしてByteCodeRubyというプロジェクトが知られていたと思う。そのため、“Yet Another”という名前を付けた。もちろん、yaccに代表されるように、この業界では“Yet Another”なものが多く利用されることも多かったため、同じようにYARVも多く利用されるよう、願をかけたということもある。ちなみに、RiteVMは、まつもと氏が鋭意開発しているmrubyの仮想マシンの名前となっている。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;YARV: Yet Another RubyVM&lt;/h2&gt;

&lt;p&gt;I started the development of YARV during the New Year&amp;rsquo;s holiday in 2004. I had
already been interested in a virtual machine for Ruby at that time. I built a
simple prototype within about a week. I must have had plenty of time to kill
back then. According to the first announcement ([ruby-dev:22494]), it was
capable of running a program to calculate Fibonacci numbers.&lt;/p&gt;

&lt;p&gt;In its early stages of development, I implemented YARV as an extension library
for Ruby 1.8. Instead of replacing the whole runtime engine, I designed it to
be used by Ruby 1.8 as a VM to run specific programs. In other words, it was
another Ruby implementation on top of the Ruby 1.8 implementation. This
architecture allowed us to test YARV with relative ease using Ruby 1.8, which
was sufficiently stable. We could continue using the base mechanisms of Ruby
1.8, such as GC, C APIs and so on. After finishing a substantial part of the
development, the Ruby 1.8 core was removed and replaced with YARV all at once,
in order to support features such as threads. However, we kept using
infrastructure code, such as GC, after that. The Ruby interpreter (MRI/CRuby)
is known to have an affinity to the C programming language. YARV inherits that
characteristic as well. Then a new version of Ruby containing YARV at its core
was released as Ruby 1.9. As of this writing in 2014, YARV has been used as the
Ruby VM since then.&lt;/p&gt;

&lt;p&gt;People often point out that YARV is not &amp;ldquo;Yet Another&amp;rdquo; anymore, because it is
the official VM now. Though we still use the name because it somehow sounds
familiar, we make it a rule not to use &amp;ldquo;YARV&amp;rdquo; in file names or class names. When
I started working on YARV, there had already been several proposals for the
development of new virtual machines for Ruby. RiteVM by Matz, the creator of
Ruby, and ByteCodeRuby were the most well known projects then, as far as I can
remember. That lead me to prefix the name of our VM with “Yet Another.” Of
course, I named it so hoping it would become popular. There are many examples
of software programs that have “Yet Another” in their names and nevertheless became
popular: for example yacc. By the way, RiteVM is now the name of the mruby VM
which Matz is actively developing.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARVの設計方針&lt;/h2&gt;
&lt;p&gt;YARVは当時の最新版であるRuby 1.8の仕様を踏襲するのではなく、その次の版である、Ruby 1.9の仕様を実装することとした。当時はRuby 1.9の仕様をどうするか議論していた。YARVではそのRuby 1.9の仕様のもとで開発を進めることにした。別の戦略として、Ruby 1.8に完全互換の仮想マシンを開発することで、多くの人に、即座に利用してもらうこともできた。しかし、いくつかのRuby 1.8の仕様がYARVで用いているスタックマシンでは実現困難であろうと思われたため、新しい仕様をベースに実装しつつ、困難な仕様は仕様変更できないか、交渉しながら開発を進めることとした。この戦略により、Ruby 1.9を実現するRubyインタプリタのひとつとなることができた。後に公式処理系としてマージされた理由のひとつだろうと思う。&lt;/p&gt;
&lt;p&gt;YARVの詳細設計は本書で解説しているとおりである。ただし、本書で説明している設計に辿り着くまでには紆余曲折があった。特に思い浮かぶのは仮想マシンのスタックの構造である。本書では、2重スタックマシンと表現されているが、当初は1つのスタックしか用いていなかった。仮想ではない現実のプロセッサでは、1つのスタックの上に、計算領域と関数呼び出しフレーム構造を交互に確保する。YARVも当初はそのような構造であったが、あまりに複雑となってしまい、性能を犠牲にしても、2つのスタックを用いて管理しよう、という結論に至った。ブロックをクロージャとして取り出す仕組みを実装するとき、特に操作が複雑となったためである。幸いにして本書ではこのあたりの説明をうまく回避しており、読者がこのような複雑さに悩まなくて済むようになっている。ただ、一番難しく、苦労した部分でもあるため、機会があれば解説してみたい。ちなみに、2つのスタックを持つ、ということは、スタックオーバーフローのチェックコストも2倍になる、ということである。そこで、2つのスタックを、1つのメモリブロックで下端から上へ伸ばすスタック、上端から下へ伸ばすスタックとして実装した。この工夫により、2つのスタックのスタックオーバフローのチェックは、2つのスタックポインタの位置関係を1度確認するだけでよく、若干軽量にすることができた。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;Design Principles of YARV&lt;/h2&gt;

&lt;p&gt;We chose to implement YARV for the Ruby 1.9 specification, instead of 1.8. At
the time, Ruby 1.9 was the next version, and we were discussing its
specification. We targeted YARV at that specification. We also had the option
of implementing it for Ruby 1.8, thereby supporting a large number of users
instantly. But some of the Ruby 1.8 features seemed difficult to implement with
the stack machine which YARV is based on. So I decided to implement my VM for
the newer spec, while negotiating with Ruby developers to change the parts of
the specification that were hard to implement. This strategy worked well, and
YARV became one of the interpreters to run Ruby 1.9. I think that was one of
the reasons that it was finally merged in as an official VM.&lt;/p&gt;

&lt;p&gt;This book correctly explains YARV’s design details. I would, however, like to add
that it was not so straightforward to get to the current design. One of the
things I remember is the stack structure of the virtual machine. The book
describes YARV as a &amp;ldquo;double stack machine,&amp;rdquo; but it was using only one stack at
first.  Actual microprocessors allocate a calculation area and a function call
frame one after another on a single stack. YARV used a similar architecture at
first, but it became too complicated. Later I concluded that it should have two
stacks, even if I had to give up some efficiency. YARV’s operation became too
complex especially when implementing the extraction of a block as a closure.
Because this book cleverly avoids such hairy details, readers fortunately do
not have to confront this sort of complexity. I hope, though, I have chance to
explain that, because it was one of the most difficult parts to implement. By
the way, having two stacks means that the cost of checking for stack overflows
also doubles. So I implemented them both in the same memory block: one going
from bottom to top and the other going from top to bottom.  This trick somewhat
reduced the cost of checking for stack overflows, because we only have to check
the positions of two stack pointers once.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARVの開発までの経緯&lt;/h2&gt;
&lt;p&gt;開発に至った経緯についても触れておく。もともと、私は言語処理系の実装に興味があったため、Javaの仮想マシンを2つほど開発したことがあった。そのため、オブジェクト指向言語処理系に必要となる仮想マシンに必要な要件を、既にいくつか知っていた。そのころ、「計算機プログラムの構造と解釈」、通称SICPの読書会が山下伸夫氏により定期的に開催されており、これに参加することで、Schemeの言語処理系についての知見を得ることができた。本書の第8章で紹介されているように、RubyのブロックはLispの関数にあたるものであったため、この知見は重要なものであった。&lt;/p&gt;
&lt;p&gt;2002年12月に青木峰郎氏による、Rubyのソースコードを逐一解説するという異色の書、「Rubyソースコード完全解説」、通称RHGが発売された。そして、高橋征義氏によりRHG読書会が企画され、月1度程度の頻度で開催された。参加者で本書を読み上げていく、というスタイルであったが、不明点は著者である青木氏を含めた参加者で議論できたため、Ruby処理系の詳細を知ることができた。余談だが、SICP読書会、およびRHG読書会は、当時山下氏が勤めていた、新宿にある株式会社タイムインターメディアの会議室で行われていた。私は、これらの読書会に参加するために、月に数回、タイムインターメディアに通っていたことになる。このような大切な機会を与えてくれた諸氏に深く感謝したい。&lt;/p&gt;
&lt;p&gt;RHGによってRuby処理系の構造を学べば、Rubyプログラムを実行する心臓部となる評価器が、Java仮想マシンなどに比べ、あまりに非効率であることは明らかであった。そのため、Rubyの文法を適切に、高速に評価する仮想マシンはどのようなものであるか、ということに興味を持ち、検討を続けた。そして、正月休みの機会に一気に書き上げた。その頃は、まさかRuby 1.9の一部としてリリースされることになるとは思わなかった。最初の動機が性能向上であったため、最初から性能のことを強く意識したソースコードであった。今思えば、早すぎる最適化といえると思う。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;YARV Development Prehistory&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;d like to describe the history of how I came to develop YARV. Because earlier
I had been interested in programming language processors, I had the experience
of implementing two Java virtual machines. That gave me some knowledge of what
was required to implement virtual machines intended for object-oriented
programming languages. At the time, Mr.  Nobuo Yamashita was periodically
holding meetups to read the book &lt;i&gt;The Structure and Interpretation of
Computer Programs&lt;/i&gt; (or SICP). Attending them, I acquired knowledge and
insight about implementations of Scheme. This insight was important since
Ruby&amp;rsquo;s block design was based on Lisp functions, as Chapter 8 of this book
points out.&lt;/p&gt;

&lt;p&gt;It was December 2002 when &lt;i&gt;Ruby Source Code Kanzen Kaisetsu&lt;/i&gt; (the &lt;i&gt;Ruby
Hacking Guide&lt;/i&gt;, or RHG), by Mr. Minero Aoki was published, which is a unique
book that explains the entire Ruby source code. Mr. Masayoshi Takahashi held
meetings to read RHG about once a month. We took turns in a reading group, but
because the author Aoki-san himself was one of the members the other members
could talk with him in person when they had questions. In this way, we learned
the implementation details of Ruby very well. Let me add that both of these
meetups are held in the meeting rooms at Time Intermedia, Ltd., where Mr.
Yamashita was working then. I attended the meetups frequently: several times a
month. I wish to express my deep gratitude to the people who provided such an
environment for learning.&lt;/p&gt;

&lt;p&gt;After reading RHG and learning more about the structure of Ruby’s
implementation, it became clear to me that the evaluation module Ruby used to
run programs &amp;ndash; the heart of the Ruby interpreter &amp;ndash; was not efficient enough. I
kept on studying and thinking about the ideal design of a virtual machine to run
Ruby programs precisely and efficiently, which I finally implemented all at
once during that New Year&amp;rsquo;s holiday. I didn’t foresee that it would be released
as a part of Ruby 1.9. My first motivation was performance improvement &amp;ndash; my
source code surely reflected that. In hindsight, it was such an early
optimization.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;さらにそのほかのRuby仮想マシン&lt;/h2&gt;
&lt;p&gt;本書では、YARVの構造を既知のものとして紹介しており、もしかしたら、このように実装するのが正しいRuby処理系だ、とも読めるかもしれない。しかし、本稿で紹介したとおり、YARVをはじめ、Ruby処理系は人間が試行錯誤しながら、なんとか作り上げてきたソフトウェアにすぎない。本書はRuby 2.0をベースに紹介しているが、Ruby 2.1では、さらに品質を向上するためにさまざまな修正を行った。そして、これからリリースする予定であるRuby 2.2を、より良いものにするため、改善を続けている。&lt;/p&gt;
&lt;p&gt;たとえば、キーワード引数の改善である。本書の第4章では、キーワード引数の実装方法について紹介している。簡単に要約すると、呼び出しにおいて、キーワード引数として渡した名前と値の対を、1つのHashオブジェクトとしてまとめ、通常の引数として渡す。受け側はそのHashオブジェクトから必要な値を読み出すコードをコンパイル時に暗黙に展開する。さて、キーワード引数はRuby 2.0から導入された新機能なので、利用頻度が低いようであり、問題になっていないが、この実装は非効率である。メソッド呼び出しごとにHashオブジェクトが生成されることになり、Hashオブジェクト生成、およびGCのコストがかかる。また、暗黙に展開されるHashオブジェクトの読み込みも、複数のメソッド呼び出しを含むため、遅い。&lt;/p&gt;
&lt;p&gt;この問題を改善するため、Ruby 2.2から、可能な限りHashオブジェクトを生成しないようにキーワード引数を実装し直した。その代わり、コンパイル時にキーワード引数の名前をまとめておき、呼び出し側では値のみ渡すことにした。そして、受け側では渡された値と、コンパイル時に作成した名前を用いて対を復元するようにした。この工夫によりキーワード引数を用いるメソッド呼び出しを、場合によっては10倍以上高速化することができた。今後も、実行速度を含む、Ruby処理系の品質向上を続けていきたい。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;Yet More Ruby Virtual Machines&lt;/h2&gt;

&lt;p&gt;This book explains the current architecture of YARV, which you might conclude
is the correct way of implementing Ruby. But, as I have explained in this
appendix so far, all of Ruby’s implementations, including YARV, are not much
different from any other software application: they are all developed through
trial and error by humans. While this book covers Ruby 2.0, we have already
made various improvements for Ruby 2.1. And we are working on even more
improvements that will make the forthcoming Ruby 2.2 even better.&lt;/p&gt;

&lt;p&gt;For example, keyword arguments will be more efficient. Chapter 4 explains the
implementation of keyword arguments. Quickly summarizing: Ruby first passes a
hash object containing keyword name and value pairs as a normal argument. Then,
at compile time, the receiver implicitly expands code that reads the values
from the argument hash. Users don’t seem to be complaining about its
performance for now. I assume keyword arguments are not widely used, because it
is a new feature introduced in Ruby 2.0. But this implementation is not
efficient. Hash objects are created every time, incurring object creation and
GC costs. Also, reading from Hash objects using the implicitly expanded code is
slow, because it involves multiple method calls.&lt;/p&gt;

&lt;p&gt;In order to address this problem, we are reimplementing how Ruby 2.2 handles
keyword arguments to avoid creating Hash objects as much as possible.
Meanwhile, we are implementing a new design that will collect the names of
keyword arguments at compile time, so that caller need only pass the values at
runtime. The callee will then recombine the values with the names collected
by the compiler. This design change will allow Ruby to process keyword
arguments 10 times faster. I would like to keep on improving the quality of
Ruby&amp;rsquo;s implementation, including runtime efficiency.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;p&gt;もし、本書によってYARV、そしてRuby処理系に興味を持ち、改良方法を思いついたら、ぜひ「さらにそのほかのRuby処理系」として実装し、試してほしい。Ruby処理系開発コミュニティは、あなたの挑戦を歓迎する。
&lt;br/&gt;
&lt;br/&gt;
2014年11月&lt;br/&gt;
笹田耕一&lt;br/&gt;
Heroku, Inc.
&lt;/div&gt;


&lt;p&gt;If you become interested in YARV and Ruby implementations after reading this
book, if you have ideas for improving them, I encourage you to develop your own
“Yet Another Ruby Implementation.” The Ruby core community will welcome your
challenge.&lt;/p&gt;

&lt;p&gt;November 2014&lt;br/&gt;
Koichi Sasada&lt;br/&gt;
Heroku, Inc.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Matz’s Foreword to Ruby Under a Microscope</title>
    <link href="http://patshaughnessy.net/2014/12/15/matzs-forward-to-ruby-under-a-microscope" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/12/15/matzs-forward-to-ruby-under-a-microscope</id>
    <published>2014-12-15T01:00:00Z</published>
    <updated>2014-12-15T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/15/rumja_cover.png"&gt;&lt;br/&gt;
  &lt;i&gt;&lt;a href="http://shop.ohmsha.co.jp/shopdetail/000000004065/"&gt;A Japanese translation&lt;/a&gt; of Ruby Under a&lt;br/&gt;Microscope was published last month.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Matz wrote a new foreword to &lt;a href="http://patshaughnessy.net/ruby-under-a-micros</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/15/rumja_cover.png"&gt;&lt;br/&gt;
  &lt;i&gt;&lt;a href="http://shop.ohmsha.co.jp/shopdetail/000000004065/"&gt;A Japanese translation&lt;/a&gt; of Ruby Under a&lt;br/&gt;Microscope was published last month.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Matz wrote a new foreword to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt;, which was
included in the Japanese version of the book published just last month. Today
I’d like to share a translation so everyone has a chance to read it. The
Japanese edition also includes a new appendix written by Koichi Sasada about
YARV, Ruby’s virtual machine. I’ll post a translation of that tomorrow.&lt;/p&gt;

&lt;p&gt;I love Matz’s sentiment about inspiring someone to work on Ruby… I hope that
might happen too. Thank you for writing this, Matz! You’ve already inspired so
many of us for years with your personality, your philosophy and with the
beautiful programming language you created.&lt;/p&gt;

&lt;p&gt;Japanese-language edition copyright &amp;copy; 2014 by Ohmsha, Ltd. Reproduced with
permission of the copyright owner.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;




&lt;div class="jp"&gt;
&lt;h2&gt;日本語版序文&lt;/h2&gt;
&lt;p class="jp"&gt;
私が小学生のときに読んで記憶に残っている一冊として、マーク・トウェインによる「アーサー王とあった男」&lt;sup&gt;*1&lt;/sup&gt;というSF作品があります。1880年代のアメリカ人がアーサー王時代にタイムスリップしてしまうものの、現代（出版当時）の知識を活用して活躍するというストーリーです。5世紀に電話や自転車、銃などの知識を持ち込めばさぞかし無敵でしょう。しかし、仮に21世紀の我々が5世紀にタイムスリップしたとして、我々の持っている知識をどれだけ活用することができるでしょう。自転車くらいならともかく、何もないところからコンピュータやネットワークを構築することなどできそうもありません。現代のテクノロジーは個人レベルで再現するには高度化しすぎています。普段はなにげなく使っている技術でも中身までは理解していないものです。
&lt;/p&gt;
&lt;/div&gt;




&lt;h2&gt;Foreword for Japanese Edition&lt;/h2&gt;


&lt;p&gt;The science fiction novel &lt;cite class="book"&gt;A Connecticut Yankee in King Arthur's
Court&lt;/cite&gt;&lt;sup&gt;*1&lt;/sup&gt; by Mark Twain is one of the books I still remember reading from my
elementary school days. It is the story of an American living in the 1880s who accidentally
time travels to King Arthur era England and nonetheless survives, taking
advantage of his knowledge from the modern (1880) era. Surely you would be very
powerful in the 5th century if you had knowledge of telephones, bicycles, and
guns.  But if we time travelled from the 21st century to the 5th century, how
much of our knowledge could we utilize?  Bicycles are okay, but how about
computers? It seems almost impossible to build computers and networks from
scratch ourselves.  Modern technology products are too advanced for individuals
to reproduce. We don't know how technologies work even when we use them in our
everyday lives.&lt;/p&gt;




&lt;div class="jp"&gt;
&lt;p&gt;
私たちが普段使っているRubyもそのような現代テクノロジーのひとつです。Rubyを便利に使っていても、その中がどうなっていて、どのように実行されているのか、あるいはRubyのような言語をどうすれば再現できるのか正確な知識を持っている人はほとんどいないでしょう。本書はそのような謎に包まれている「Rubyの中身」を明らかにしてくれる一冊です。
&lt;/p&gt;
&lt;p&gt;
本書はRubyのソフトウェア構造から、オブジェクトシステムの構成、性能を向上させるための工夫まで解説されています。さらにCRubyだけでなく、JRubyやRubiniusについてまでカバーしています。このような知識を学べる書籍はなかなかありません。日本には類書として「Rubyソースコード完全解説」&lt;sup&gt;*2&lt;/sup&gt;がありますが、入手困難になって久しいですし、対象のRubyバージョンも1.7と古いので、YARVのような新しい技術については当然解説されていません。このような書物の登場は、Rubyの内部知識の一般化に貢献すると信じます。
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Ruby is one such technology. Even though we use it every day, not many of us
seem to know what it looks like on the inside, how it runs internally, or how
one could recreate such a programming language. This book sheds light on this and
reveals the mystery of Ruby internals.&lt;/p&gt;

&lt;p&gt;This book explains the software architecture of Ruby, the structure of its
object system, and tips for performance improvement. In addition to that, it
covers not only CRuby but also JRuby and Rubinius as well. I know of few books
where you can find this type of knowledge. Though we have the &lt;cite
class="book"&gt;Ruby Hacking Guide&lt;/cite&gt;&lt;sup&gt;*2&lt;/sup&gt; in Japan, it&amp;rsquo;s been
difficult to obtain a copy for a long time. It explains a version of Ruby as
old as 1.7 and naturally does not cover newer technologies like YARV. I believe
RUM will contribute to a wider understanding of Ruby internals.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;p&gt;
本書の知識をもとにして、もしかすると本書の読者のうちの誰か、もしかするとあなたがRubyの開発に関わるようになるかもしれませんし、そうなれば我々は大歓迎します。あるいは、次世代の言語処理系を開発するきっかけになるかもしれません。そのような未来が見たいものです。
&lt;/p&gt;
&lt;p&gt;
&lt;br/&gt;
2014年10月、松江にて&lt;br/&gt;
まつもと ゆきひろ
&lt;/p&gt;
&lt;br/&gt;
&lt;hr align="left"/&gt;
&lt;small&gt;*1 マーク・トウェーン作、亀山龍樹訳「アーサー王とあった男」（岩崎書店、1971）&lt;br/&gt;
*2 青木峰郎著「Rubyソースコード完全解説」（インプレス、2002）&lt;/small&gt;
&lt;/div&gt;


&lt;p&gt;In the future someone inspired by this book may join the development of Ruby.
It may be you. We will definitely welcome that. Or, he/she may begin creating a
next generation programming language. I hope to see that happen.&lt;/p&gt;

&lt;p&gt;In Matsue, October 2014&lt;br/&gt;
Yukihiro Matsumoto&lt;/p&gt;

&lt;br/&gt;


&lt;hr align="left"/&gt;


&lt;p&gt;&lt;small&gt;*1 Twain, Mark, A Connecticut Yankee in King Arthur’s Court. (Kameyama Nagarjuna translation, Iwasaki Bookstore, 1971)&lt;br/&gt;
*2 Aoki Minero al., Ruby Hacking Guide. (Impress, 2002)&lt;/small&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Discovering the Computer Science Behind Postgres Indexes</title>
    <link href="http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes</id>
    <published>2014-11-11T01:00:00Z</published>
    <updated>2014-11-11T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/engineering-plans.png"&gt;&lt;br/&gt;
  &lt;i&gt; Captain Nemo and Professor Aronnax discussing the&lt;br/&gt;engineering and science behind
  the Nautilus.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;&lt;b&gt; This is the last post in a series based on a
  presentation I did at the &lt;a href="http://www.baruco.org"&gt;Barcelona</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/engineering-plans.png"&gt;&lt;br/&gt;
  &lt;i&gt; Captain Nemo and Professor Aronnax discussing the&lt;br/&gt;engineering and science behind
  the Nautilus.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;&lt;b&gt; This is the last post in a series based on a
  presentation I did at the &lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt;
  called “20,000 Leagues Under ActiveRecord.” (other posts:
  &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;one&lt;/a&gt;
  &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;two&lt;/a&gt;
  &lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;three&lt;/a&gt;
  and &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).  &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;We all know indexes are one of the most powerful and important features of
relational database servers. How do you search for a value quickly? Create an
index. What do you have to remember to do when joining two tables together?
Create an index. How do you speed up a SQL statement that’s beginning to run
slowly? Create an index.&lt;/p&gt;

&lt;p&gt;But what are indexes, exactly? And &lt;em&gt;how&lt;/em&gt; do they speed up our database searches?
To find out, I decided to read the C source code inside the PostgreSQL database
server, to follow along as it searched an index for a simple string value. I
expected to find sophisticated algorithms and efficient data structures. And I
did. Today I’ll show you what indexes look like inside Postgres and explain how
they work.&lt;/p&gt;

&lt;p&gt;What I didn’t expect to find &amp;ndash; what I discovered for the first time reading the
Postgres C source code &amp;ndash; was the Computer Science theory behind what it was
doing. Reading the Postgres source was like going back to school and taking
that class I never had time for when I was younger. The C comments inside
Postgres not only explain what Postgres does, but &lt;em&gt;why&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Sequence Scans: A Mindless Search&lt;/h2&gt;

&lt;p&gt;When we left the crew of the Nautilus, they were exhausted and beginning to
faint: the Postgres sequence scan algorithm was mindlessly looping over all of
the records in the users table! Recall in &lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;my last
post&lt;/a&gt;
we had executed this simple SQL statement to find Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/select-users.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres first parsed, analyzed and planned the query. Then
&lt;a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html#af80d84501ff7621d2ef6249b148e7f44"&gt;ExecSeqScan&lt;/a&gt;,
the C function inside of Postgres that implements the sequence scan (SEQSCAN)
plan node, quickly found Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan4.png"/&gt;&lt;/p&gt;

&lt;p&gt;But then inexplicably Postgres continued to loop through the entire user table,
comparing each name to “Captain Nemo,” even though we had already found what we
were looking for!&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan5.png"/&gt;&lt;/p&gt;

&lt;p&gt;Imagine if our users table had millions of records; this could take a very long
time. Of course, we could have avoided this by removing the sort and rewriting
our query to accept the first name, but the deeper problem here is the
inefficient way Postgres searches for our target string. Using a sequence scan
to compare every single value in the users table with “Captain Nemo” is slow,
inefficient and depends on the random order the names appear in the table. What
are we doing wrong? There must be a better way!&lt;/p&gt;

&lt;p&gt;The answer is simple: We forgot to create an Index. Let’s do that now.&lt;/p&gt;

&lt;h2&gt;Creating an Index&lt;/h2&gt;

&lt;p&gt;Creating an index is straightforward &amp;ndash; we just need to run this command:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/create-index.png"/&gt;&lt;/p&gt;

&lt;p&gt;As Ruby developers, of course, we would use the &lt;span class="code"&gt;add_index&lt;/span&gt; ActiveRecord
migration instead; this would run the same &lt;span class="code"&gt;CREATE INDEX&lt;/span&gt; command behind the
scenes. When we rerun our select statement, Postgres will create a plan tree as usual &amp;ndash;
but this time the plan tree will be slightly different:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/11/11/indexscan-plan.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice at the bottom Postgres now uses INDEXSCAN instead of SEQSCAN. Unlike
SEQSCAN, INDEXSCAN won’t iterate over the entire users table. Instead, it will
use the index we just created to find and return the Captain Nemo records
quickly and efficiently.&lt;/p&gt;

&lt;p&gt;Creating an index has solved our performance problem, but it’s also left us with many interesting, unanswered questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;What&lt;/em&gt; is a Postgres index, exactly?&lt;/li&gt;
&lt;li&gt;If I could go inside of a Postgres database and take a close look at an index, &lt;em&gt;what would it look like&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;And &lt;em&gt;how&lt;/em&gt; does an index speed up searches?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Let’s try to answer these questions by reading the Postgres C source code.&lt;/p&gt;

&lt;h2&gt;What Is a Postgres Index, Exactly?&lt;/h2&gt;

&lt;p&gt;We can get started with a look at the
&lt;a href="http://www.postgresql.org/docs/9.3/static/sql-createindex.html"&gt;documentation&lt;/a&gt;
for the CREATE INDEX command.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/documentation.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see all of the options we can use to create an index, such as
&lt;span class="code"&gt;UNIQUE&lt;/span&gt; and &lt;span class="code"&gt;CONCURRENTLY&lt;/span&gt;. Notice there’s an option called &lt;span class="code"&gt;USING method&lt;/span&gt;. This
tells Postgres what kind of index we want. Farther down the same page is some
information about &lt;span class="code"&gt;method&lt;/span&gt;, the argument to the &lt;span class="code"&gt;USING&lt;/span&gt; keyword:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/method.png"/&gt;&lt;/p&gt;

&lt;p&gt;It turns out Postgres implements four different types of indexes. You can use
them for different types of data and in different situations. Because we didn’t
specify &lt;span class="code"&gt;USING&lt;/span&gt; at all, our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index is a “btree” (or B-Tree) index,
the default type.&lt;/p&gt;

&lt;p&gt;This is our first clue: a Postgres index is a B-Tree. But what is a B-Tree?
Where can we find one? Inside of Postgres, of course! Let’s search the Postgres
C source code for files containing “btree:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/find.png"/&gt;&lt;/p&gt;

&lt;p&gt;The key result is in bold: “./backend/access/nbtree.” Inside this directory is
a README file; let’s read it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/readme.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/atlantis.png"&gt;&lt;br/&gt;
  &lt;i&gt;Nemo found the lost continent of Atlantis&lt;br/&gt;next to an underwater
  volcano.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Amazingly, this README file turns out to be an extensive 12 page document! The
Postgres source code not only contains helpful and interesting C comments, it
also contains documentation about the theory and implementation of the database
server. Reading and understanding the code in open source projects can often be
intimidating and difficult, but not for Postgres. The developers behind
Postgres have gone to great lengths to help the rest of us understand their
work.&lt;/p&gt;

&lt;p&gt;The title of the README document, “Btree Indexing,” confirms this directory
contains the C code that implements Postgres B-Tree indexes. But the first
sentence is even more interesting: it’s a reference to an academic paper that
explains what a B-Tree is, and how Postgres indexes work: &lt;a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf"&gt;Efficient Locking for
Concurrent Operations on B-Trees&lt;/a&gt;, by Lehman and Yao.&lt;/p&gt;

&lt;p&gt;We’ll find our first look at a B-Tree inside this academic paper.&lt;/p&gt;

&lt;h2&gt;What Does a B-Tree Index Look Like?&lt;/h2&gt;

&lt;p&gt;Lehman and Yao’s paper explains an innovation they made to the B-Tree algorithm
in 1981. I’ll discuss this a bit later. But they start with a simple
introduction to the B-Tree data structure, which was actually invented 9 years
earlier in 1972. One of their diagrams shows an example of a simple B-Tree:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/11/11/figure2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The term B-Tree actually stands for “balanced tree.” B-Trees make searching
easy and fast. For example, if we wanted to search for the value 53 in this
example, we first start at the root node which contains the value 40:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node1.png"/&gt;&lt;/p&gt;

&lt;p&gt;We compare our target value of 53 with the value we find in the tree node. Is
53 greater than or less than 40? Because 53 is greater than 40 we follow the
pointer down to the right. If we were searching for 29, we would go down to the
left. Pointers on the right lead to larger values; pointers on the left to
smaller ones.&lt;/p&gt;

&lt;p&gt;Following the pointer down the tree to the next child tree node, we encounter a
node that contains 2 values:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node2.png"/&gt;&lt;/p&gt;

&lt;p&gt;This time we compare 53 with both 47 and 62, and find that 47 &amp;lt; 53 &amp;lt; 62. Note
the values in the tree node are sorted, so this will be easy to do. This time
we follow the center pointer down.&lt;/p&gt;

&lt;p&gt;Now we get to another tree node, this one with 3 values in it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node3.png"/&gt;&lt;/p&gt;

&lt;p&gt;Looking through the sorted list of numbers, we find 51 &amp;lt; 53 &amp;lt; 56, and follow
the second of four pointers down.&lt;/p&gt;

&lt;p&gt;Finally, we come to a leaf node in the tree:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node4.png"/&gt;&lt;/p&gt;

&lt;p&gt;And we’ve found the value 53!&lt;/p&gt;

&lt;p&gt;B-Trees speed up searches because:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They sort the values (known as &lt;em&gt;keys&lt;/em&gt;) inside of each node.&lt;/li&gt;
&lt;li&gt;They are &lt;em&gt;balanced&lt;/em&gt;: B-Trees evenly distribute the keys among the nodes,
minimizing the number of times we have to follow a pointer from one node to
another. Each pointer leads to a child node that contains more or less the
same number of keys each other child node does.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;What Does a Postgres Index Look Like?&lt;/h2&gt;

&lt;p&gt;Lehman and Yao drew this diagram over 30 years ago &amp;ndash; what does it have to do
with how Postgres works today? Astonishingly, the &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index we created earlier looks very
similar to Figure 2: We created an index in 2014 that looks just like a diagram
from 1981!&lt;/p&gt;

&lt;p&gt;When we executed the &lt;span class="code"&gt;CREATE INDEX&lt;/span&gt; command, Postgres
saved all of the names from our users table into a B-Tree. These became the
keys of the tree. Here’s what a node inside a Postgres B-Tree index looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Each entry in the index consists of a C structure called &lt;span class="code"&gt;IndexTupleData&lt;/span&gt;, and is
followed by a bitmap and a value. Postgres uses the bitmap to record whether
any of the index attributes in a key are NULL, to save space. The actual values
in the index appear after the bitmap.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at the &lt;span class="code"&gt;IndexTupleData&lt;/span&gt;
structures:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see each IndexTupleData structure contains:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class="code"&gt;t_tid&lt;/span&gt;: This is a pointer to either another index
tuple, or to a database record. Note this isn&amp;rsquo;t a C pointer to physical
memory; instead, it contains numbers Postgres can use to find the referenced
value among its memory pages.&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;t_info&lt;/span&gt;: This contains information about the index
tuple, such as how many values it contains, and whether or not there are null
values.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To understand this better, let’s show a few entries from our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Now I’ve replaced “value” with some names from my users table. The upper tree
node includes the keys “Dr. Edna Kunde” and “Julius Powlowski,” while the lower
tree node contains “Julius Powlowski” and “Juston Quitzon.” Notice that, unlike
Lehman and Yao’s diagram, Postgres repeats the parent keys in each child node.
Here “Julius Powlowski” is a key in the upper node and in the child node. The
&lt;span class="code"&gt;t_tid&lt;/span&gt; pointer from Julius in the upper node
references the same Julius name in the lower node.&lt;/p&gt;

&lt;p&gt;To learn more about exactly how Postgres stores key values into a B-Tree node,
refer to the itup.h C header file:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;IndexTupleData&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/itup_8h_source.html"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/itup.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Finding the B-Tree Node Containing Captain Nemo&lt;/h2&gt;

&lt;p&gt;Now let’s return to our original SELECT statement again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/select-users.png"/&gt;&lt;/p&gt;

&lt;p&gt;How exactly does Postgres search our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index for “Captain Nemo?” Why is
using the index faster than the sequence scan we saw in my last post? To find
out, let’s zoom out a bit and take a look at some of the user names in our
index:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/root-names1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;This is the root node of the &lt;span class="code"&gt;index_users_on_name&lt;/span&gt;
B-Tree. I’ve turned the tree on its side so the names would fit. You can see 4
names and a NULL value. Postgres created this root node when I created
&lt;span class="code"&gt;index_users_on_name&lt;/span&gt;. Note that, aside from the
first NULL value which represents the beginning of the index, the other 4 names
are more or less evenly distributed in alphabetical order.&lt;/p&gt;

&lt;p&gt;Remember that a B-Tree is a balanced tree. In this example, the B-Tree has 5 child nodes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the names that appear before Dr. Edna Kunde alphabetically&lt;/li&gt;
&lt;li&gt;names that appear between Dr. Edna Kunde and Julius Powlowski&lt;/li&gt;
&lt;li&gt;names that appear between Julius Powlowski and Monte Nicolas&lt;/li&gt;
&lt;li&gt;etc…&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Because we’re searching for Captain Nemo, Postgres follows the first, top arrow
to the right. This is because Captain Nemo comes before Dr. Edna Kunde
alphabetically:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/root-names2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;You can see on the right that Postgres has found the B-Tree node that contains
Captain Nemo. For my test I added 1000 names to the users table; this child
node in the B-Tree contained about 200 names (240 actually). The B-Tree has
narrowed down Postgres’s search considerably.&lt;/p&gt;

&lt;p&gt;To learn more about the precise algorithm Postgres uses to search for the
target B-Tree node among all of the nodes in the tree, read the &lt;span
class="code"&gt;_bt_search&lt;/span&gt; function.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;_bt_search&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nbtsearch_8c.html#a9053c37f2c25187580f3f690ad41bf01"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/bt_search.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Finding Captain Nemo Inside a Single B-Tree Node&lt;/h2&gt;

&lt;p&gt;Now that Postgres has narrowed down the search to a B-Tree node containing
about 200 names, it still has to find Captain Nemo… how does it do this? Does
it perform a sequence scan on this shorter list?&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;No. To search for a key value inside of a tree node, Postgres switches to use a
binary search algorithm. It starts by comparing the key that appears at the 50%
position in the tree node with “Captain Nemo:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Because Captain Nemo comes after Breana Witting alphabetically, Postgres
jumps down to the 75% position and performs another comparison:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;This time Captain Nemo comes before Curtis Wolf, so Postgres jumps back a bit.
Skipping a few more steps (it actually took Postgres 8 comparisons to find
Captain Nemo in my example), Postgres eventually finds what we are looking for:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search4.svg"/&gt;&lt;/p&gt;

&lt;p&gt;To learn more about exactly how Postgres searches for a value in a single
B-Tree node, read the &lt;span class="code"&gt;_bt_binsrch&lt;/span&gt; function:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;_bt_binsrch&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nbtsearch_8c.html#acd3770ac6d3bc26d6f319d3255721280"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/bt_binsrch.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;So Much More to Learn&lt;/h2&gt;

&lt;p&gt;I don’t have space in this blog post to cover many other fascinating details
about B-Trees, database indexes or Postgres internals… maybe I should write
&lt;em&gt;Postgres Under a Microscope&lt;/em&gt; :) But for now, here are just a few interesting
bits of theory you can read about in &lt;a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf"&gt;Efficient Locking for Concurrent
Operations on B-Trees&lt;/a&gt; or in
the other academic papers it references.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Inserting into B-Trees: The most beautiful part of the B-Tree algorithm has
to do with inserting new keys into a tree. Key are inserted in sorted order
into the proper tree node &amp;ndash; but what happens when there’s no more room for a
new key? In this situation, Postgres splits the node into two, inserts the
new key into one of them, and also adds the key from the split point into the
parent node, along with a pointer to the new child node. Of course, the
parent node might also have to be split to fit its new key, resulting in a
complex, recursive operation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Deleting from B-Trees: The converse operation is also interesting. When
deleting a key from a node, Postgres will combine sibling nodes together when
possible, removing a key from their parent. This can also be a recursive
operation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B-Link-Trees: Lehman and Yao’s paper actually discusses an innovation they
researched related to concurrency and locking when multiple threads are using
the same B-Tree. Remember, Postgres’s code and algorithms need to be
multithreaded because many clients could be searching or modifying the same
index at the same time. By adding another pointer from each B-Tree node to
the next sibling node &amp;ndash; the so-called “right arrow” &amp;ndash; one thread can search a
tree even while a second thread is splitting a node without locking the
entire index:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/right-arrow.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Don’t Be Afraid To Explore Beneath The Surface&lt;/h2&gt;

&lt;div style="float: right; padding: 22px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/at-the-helm.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo at the helm&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Professor Aronnax risked his life and career to find the elusive Nautilus and
to join Captain Nemo on a long series of amazing underwater adventures. We
should do the same: Don’t be afraid to dive underwater &amp;ndash; inside and underneath
the tools, languages and technologies that you use every day. You may know all
about how to use Postgres, but do you really know how Postgres itself works
internally? Take a look inside; before you know it, you’ll be on an underwater
adventure of your own.&lt;/p&gt;

&lt;p&gt;Studying the Computer Science at work behind the scenes of our applications
isn’t just a matter of having fun, it’s part of being a good developer. As
software development tools improve year after year, and as building web sites
and mobile apps becomes easier and easier, we shouldn’t loose sight of the
Computer Science we depend on. We’re all standing on the shoulders of giants &amp;ndash;
people like Lehman and Yao, and the open source developers who used their
theories to build Postgres. Don’t take the tools you use everyday for granted &amp;ndash;
take a look inside them! You’ll become a wiser developer and you’ll find
insights and knowledge you could never have imagined before.&lt;/p&gt;
</content>
  </entry>
</feed>

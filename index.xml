<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pat Shaughnessy</title>
  <id>http://patshaughnessy.net</id>
  <updated>2008-09-03T00:00:00Z</updated>
  <author>
    <name></name>
  </author>
  <entry>
    <title>A Rule of Thumb for Strong Parameters</title>
    <link href="http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters</id>
    <published>2014-06-16T00:00:00Z</published>
    <updated>2014-06-16T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/6/16/security.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;It can be hard to open the Strong Parameters&lt;br/&gt;door and let permitted values into your Rails 4 app.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last week I banged my head against the wall for a few hours trying to figure
out how to whitelist input values for my Rails 4 app</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/6/16/security.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;It can be hard to open the Strong Parameters&lt;br/&gt;door and let permitted values into your Rails 4 app.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last week I banged my head against the wall for a few hours trying to figure
out how to whitelist input values for my Rails 4 app using the &lt;a href="http://edgeguides.rubyonrails.org/action_controller_overview.html#strong-parameters"&gt;Strong
Parameters&lt;/a&gt;
feature. Calling &lt;span class="code"&gt;permit&lt;/span&gt; when you have a simple
attributes hash for a single new object is straightforward, but figuring out
how to call &lt;span class="code"&gt;permit&lt;/span&gt; for a complex, nested set of attributes can be nearly
impossible.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;TL;DR:&lt;/b&gt; Use this rule of thumb when trying to figure out how to whitelist nested attributes:&lt;/p&gt;

&lt;blockquote&gt;To Permit a Hash, Pass an Array&lt;br/&gt;
  To Permit an Array, Pass a Hash&lt;/blockquote&gt;


&lt;p&gt;After studying the problem for a while, I noticed this curious pattern: To whitelist a simple hash of attributes, you pass
&lt;span class="code"&gt;permit&lt;/span&gt; an array. To whitelist an array of nested objects, you pass it a hash,
including that hash in the surrounding array.&lt;/p&gt;

&lt;p&gt;Not familiar with Strong Parameters yet? What do I mean by “whitelist?” Why do
you need this rule of thumb? My post today will explain.&lt;/p&gt;

&lt;h2&gt;To Permit a Hash, Pass an Array&lt;/h2&gt;

&lt;p&gt;Rails 4 requires you to whitelist or authorize input values for your app. This
important new feature, known as Strong Parameters, adds an extra layer of
security that prevents attackers from posting harmful or garbage information to
your site.&lt;/p&gt;

&lt;p&gt;Here’s how it works: Suppose you have a &lt;span class="code"&gt;Post&lt;/span&gt; model
with title and body columns. Using Rails 4, you would write a create controller
action like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/simple_controller.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you first tell Rails which attributes are allowed for new post objects &amp;ndash;
title and body in this example &amp;ndash; and then you create the new post. This is
simple enough and quite readable. You are telling Rails: “data for a post is
required and it’s attributes may only include title and body attributes.”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/diagram1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In the diagram above you can see the post attribute hash on the left, and the
arguments for &lt;span class="code"&gt;permit&lt;/span&gt; on the right. Notice the arguments are actually a
single array (internally Rails processes the arguments as an array). Each key/value pair on the left maps to an array element on the
right. You permit a hash by passing an array.&lt;/p&gt;

&lt;h2&gt;Strong Parameters Confusion&lt;/h2&gt;

&lt;p&gt;However, now suppose you add a second model to your app, &lt;span
  class="code"&gt;Comment&lt;/span&gt;. Let’s suppose a post has many comments, and each
comment has a single text attribute.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/has-many.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because your app is a REST-ful JSON service (what else do people use Rails for
these days?) you have a requirement to create a post and its comments from a
single JSON string:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/json.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because the comment array is named “comments” you assume ActiveRecord will
create the associated comment models along with the new post. That is,
ActiveRecord should call &lt;span class="code"&gt;comments=&lt;/span&gt; on the new post
and pass in the comment attributes. But it doesn’t work. Instead, using the
code from earlier you get:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/warning.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Ah &amp;ndash; you forgot to whitelist the comments attribute. You try adjusting the call
to &lt;span class="code"&gt;permit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/permit-comments.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;It still doesn’t work. You get the same warning:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/warning.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Clearly Rails isn’t listening! You just told it comments is permitted &amp;ndash; why
does Rails give you the same warning again? Maybe you need to create the
comment objects yourself, as a separate step:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/create-comments.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now things are even worse: Rails raises an exception!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/exception.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The problem here is that the &lt;span class="code"&gt;Comment&lt;/span&gt; model is
complaining that you haven’t whitelisted its attributes. Somehow each
ActiveRecord model has knowledge about which attributes were whitelisted and
which weren’t!&lt;/p&gt;

&lt;p&gt;If you happened to know that Rails 4 saves the parameters inside an &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object, you could try
creating a separate instance of this class for each comment, and whitelist it&amp;rsquo;s text attribute directly:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/permit-comments2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But you’ll still get the same “Unpermitted parameters” warning when you try to
create the post next &amp;ndash; not to mention that your code has become incredibly
confusing and verbose. What’s going on here? There must be some way of creating
nested objects without warnings or exceptions.&lt;/p&gt;

&lt;h2&gt;To Permit an Array, Pass a Hash&lt;/h2&gt;

&lt;p&gt;The solution is to permit all the post and comment attributes with a single
call to &lt;span class="code"&gt;ActionController::Parameters#permit&lt;/span&gt;, like
this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/nested-solution.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;What? What does the complex argument list to &lt;span class="code"&gt;permit&lt;/span&gt; mean? How in the world
would anyone know to pass that in?&lt;/p&gt;

&lt;p&gt;My rule of thumb can help. In this example, you are permitting an array of
comments by passing a hash. Imagine if your app received a post with two
comments, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/diagram2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left you see the nested attributes for the post and its comments. Rails
has parsed this for you from a JSON string. On the right are the arguments you
pass to &lt;span class="code"&gt;permit&lt;/span&gt;. Notice how the hash of post
attributes contains an array for the comments &amp;ndash; in the call to &lt;span class="code"&gt;permit&lt;/span&gt; you
replace this array with a hash! To permit an array, pass a hash.&lt;/p&gt;

&lt;p&gt;This hash, in turn, contains an array listing the attributes of each comment
object (just &lt;span class="code"&gt;[:text]&lt;/span&gt; here).&lt;/p&gt;

&lt;h2&gt;Whitelisting Rails Nested Attributes&lt;/h2&gt;

&lt;p&gt;Note: if your Rails app was in fact a web site, you might use the Rails nested
attributes feature with a complex HTML form. In this case, you would declare
that posts accept nested attributes for comments, directing ActiveRecord to
automatically create the comment objects for you:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/accepts-nested.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;To make this work you will need to adjust your call to &lt;span
class="code"&gt;permit&lt;/span&gt; slightly:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/nested-attribs-permit.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;With &lt;span class="code"&gt;accepts_nested_attribute_for&lt;/span&gt;, Rails expects the
comments to be saved as &lt;span class="code"&gt;comments_attributes&lt;/span&gt;. Also,
each comment must have an &lt;span class="code"&gt;id&lt;/span&gt; attribute in order for
the web forms to update existing comments properly. (Also, Rails represents the
comment array as a hash, with the id as the key for each comment.)&lt;/p&gt;

&lt;p&gt;But the syntax is almost the same, and the same rule applies: to permit an
array of comments you call &lt;span class="code"&gt;permit&lt;/span&gt; with a hash.&lt;/p&gt;

&lt;h2&gt;Under the Hood&lt;/h2&gt;

&lt;p&gt;Internally, Rails uses a trick to tell ActiveRecord which attributes were
permitted and which weren’t. Here’s how it works:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/hashes.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left is a normal hash &amp;ndash; you can create an ActiveRecord model using this
hash without worrying about whitelisting parameters. On the right is an &lt;span
class="code"&gt;ActionController::Parameters&lt;/span&gt; object; notice it looks almost
the same.  &lt;span class="code"&gt;ActionController::Parameters&lt;/span&gt; is actually a
subclass of &lt;span class="code"&gt;Hash&lt;/span&gt; (via &lt;span
class="code"&gt;ActiveSupport::HashWithIndifferentAccess&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;But on the right notice that the &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object contains a &lt;span class="code"&gt;permitted?&lt;/span&gt;
method. This tells ActiveRecord whether the attributes in that hash were
whitelisted or not.&lt;/p&gt;

&lt;p&gt;When you create a new post or any &lt;span class="code"&gt;ActiveRecord::Base&lt;/span&gt;
object, code inside of Rails checks whether the attributes hash implements the
&lt;span class="code"&gt;permitted?&lt;/span&gt; method or not:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/internals1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because a normal hash doesn’t respond to &lt;span class="code"&gt;permitted?&lt;/span&gt;,
ActiveRecord creates the new post without complaining.&lt;/p&gt;

&lt;p&gt;However, if you try to create a post from an &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object, Rails finds the
&lt;span class="code"&gt;permitted?&lt;/span&gt; method:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/internals2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;If you didn’t whitelist this hash using a call to &lt;span class="code"&gt;permit&lt;/span&gt;, &lt;span class="code"&gt;permitted?&lt;/span&gt; will
return &lt;span class="code"&gt;false&lt;/span&gt; and Rails will raise the &lt;span class="code"&gt;ActiveModel::ForbiddenAttributesError&lt;/span&gt;
exception.&lt;/p&gt;

&lt;h2&gt;Still Confused? Just Use a Normal Hash&lt;/h2&gt;

&lt;p&gt;If all of this is still confusing you &amp;ndash; if you’re still having trouble figuring
out the call to &lt;span class="code"&gt;permit&lt;/span&gt; properly for your complex JSON input &amp;ndash; then remember you
can always just use normal hashes instead of &lt;span class="code"&gt;ActionController::Parameters&lt;/span&gt;
objects.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/normal-hashes.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you are whitelisting or permitting each attribute manually by copying them
into normal hashes. Since &lt;span class="code"&gt;Hash&lt;/span&gt; doesn&amp;rsquo;t implement &lt;span
class="code"&gt;permitted?&lt;/span&gt;, ActiveRecord won’t raise a &lt;span
class="code"&gt;ActiveModel::ForbiddenAttributesError&lt;/span&gt; exception.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using a Ruby Class To Write Functional Code</title>
    <link href="http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code</id>
    <published>2014-04-08T00:00:00Z</published>
    <updated>2014-04-08T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet.jpg"&gt;&lt;br/&gt;
    &lt;i&gt;The time sheets I used at my first programming&lt;br/&gt;
    job in the Summer of 1986 looked just like this.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Recently I’ve been spending some of my free time studying Clojure and Haskell.
I’ve been learning how a program built with a</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet.jpg"&gt;&lt;br/&gt;
    &lt;i&gt;The time sheets I used at my first programming&lt;br/&gt;
    job in the Summer of 1986 looked just like this.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Recently I’ve been spending some of my free time studying Clojure and Haskell.
I’ve been learning how a program built with a series of small, pure functions
can be very robust and maintainable. However, I don’t want to give up on Ruby.
I want to keep the expressiveness, beauty and readability of Ruby, while
writing simple functions with no side effects.&lt;/p&gt;

&lt;p&gt;But how can this be possible? Unlike functional languages, Ruby encourages you
to hide state inside of objects, and to write functions (methods) that have
side effects, modifying an instance variable for example. Isn’t using an object
oriented language like Ruby, Python, or Java a decision to abandon the benefits
of functional programming?&lt;/p&gt;

&lt;p&gt;No. In fact, a couple of weeks ago Ruby’s object model helped me refactor one
confusing function into a series of small simple ones. Today I’ll show you what
happened, how using a Ruby class helped me write more functional code.&lt;/p&gt;

&lt;div style="clear: left"/&gt;&lt;/div&gt;


&lt;h2&gt;Parsing Timesheet Data&lt;/h2&gt;

&lt;p&gt;Let’s suppose you are a ScrumMaster&amp;trade; and want to make sure your team of
developers, including me, is putting in enough hours on your project (instead
of taking long lunches or writing blog posts). For example, suppose I report my
hours like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet-data.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You could parse my timesheet data using this simple Ruby program:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is simple enough to understand and works fine. &lt;span
class="code"&gt;parse1&lt;/span&gt; is small function; if you remove the calls to &lt;span class="code"&gt;puts&lt;/span&gt;
it only contains 3 lines of code, two simple calls to &lt;span class="code"&gt;split&lt;/span&gt;. How could this be
any simpler?&lt;/p&gt;

&lt;h2&gt;A First Pass at a Functional Solution&lt;/h2&gt;

&lt;p&gt;Next you decide to look for a more functional solution by &lt;a href="http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby"&gt;asking Ruby for what
you want, instead of telling it what to
do&lt;/a&gt;.
You try to break the problem up into small functions that return what you need.
But what functions should you write? What values should they return? In this
simple example, the answer is obvious: you can write a function to parse each
value in the timesheet data.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/asking.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You have divided the problem up into small pieces. Each function will return a
predictable value based on some input and doesn’t have any side effects. These
will be &lt;em&gt;pure&lt;/em&gt; functions: They will always return the same result given the same
arguments. You know that if you pass a line from my timesheet, &lt;span
  class="code"&gt;last_name&lt;/span&gt; will always return “Shaughnessy.” You’ve turned
the problem around; you’ve phrased the problem as a series of questions rather
than as a list of instructions.&lt;/p&gt;

&lt;p&gt;Refactoring &lt;span class="code"&gt;parse1&lt;/span&gt; above, you implement the
functions, at least in a somewhat verbose and ugly fashion:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/refactoring.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Testing Pure Functions&lt;/h2&gt;

&lt;p&gt;As a Certified ScrumMaster&amp;trade;, you believe in TDD and other extreme
programming practices. Originally, while writing &lt;span
  class="code"&gt;parse1&lt;/span&gt; above, it didn’t even occur to you to write tests
(and if it had, it would have been very difficult).  However, now after
breaking the problem up into a series of functions, it seems natural to write
tests for them.&lt;/p&gt;

&lt;p&gt;Next, you express your expectations for these functions using Minitest specs,
for example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/spec.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because the functions are small, the tests are small. Because the tests are
small, you actually take the time to write them. Because the functions are
decoupled from each other, it’s easy for you to decide which tests to write.&lt;/p&gt;

&lt;p&gt;To your surprise, you actually find a bug!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/spec-fails.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Earlier in &lt;span class="code"&gt;parse1&lt;/span&gt;, the extra space was lost in the
&lt;span class="code"&gt;puts&lt;/span&gt; output and you didn’t notice it. Separating this into a small function and
carefully testing it revealed a minor problem. You adjust two of the functions
to remove the extra space:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/fixing-bug.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Pushing Ruby Out Of Its Comfort Zone&lt;/h2&gt;

&lt;p&gt;You’re happy with your new tests. Ruby allowed you describe the behavior of the
functions in a very natural, readable way. Ruby at its best. As an added bonus,
the tests now also pass!&lt;/p&gt;

&lt;p&gt;However, your functions aren’t so pretty. There is a lot of obvious
duplication: The &lt;span class="code"&gt;office&lt;/span&gt;, &lt;span
  class="code"&gt;employee_id&lt;/span&gt; and &lt;span class="code"&gt;last_name&lt;/span&gt;
functions all call &lt;span class="code"&gt;line.split(&amp;#39;,&amp;#39;)&lt;/span&gt;. To fix this, you
decide to extract &lt;span class="code"&gt;line.split(&amp;#39;,&amp;#39;)&lt;/span&gt; into a separate
function, removing the duplication:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/extracting-method.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This doesn&amp;rsquo;t look any better; in fact, there’s a deeper problem here. To see
what I mean let’s refactor &lt;span class="code"&gt;parse1&lt;/span&gt; from earlier to use
our new functions:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is clean and easy to follow, but now you have a performance bug: Each time
around the loop, your code passes the same line to &lt;span
class="code"&gt;employee_id&lt;/span&gt;, &lt;span class="code"&gt;office&lt;/span&gt; and &lt;span
class="code"&gt;last_name&lt;/span&gt;. Now Ruby will call the &lt;span class="code"&gt;values&lt;/span&gt; function over and
over again. This is unnecessary and needless; in fact, our original &lt;span
  class="code"&gt;parse1&lt;/span&gt; code didn’t have this problem. By introducing
functions we have slowed down our code.&lt;/p&gt;

&lt;p&gt;However, because these are simple, pure functions, you know they will always
return the same value given the same input argument, the same line of text in
this example. This means theoretically you can avoid calling &lt;span
class="code"&gt;split&lt;/span&gt; over and over again by caching the results.&lt;/p&gt;

&lt;p&gt;At first, you try to cache the return value of &lt;span class="code"&gt;split&lt;/span&gt;
by using a hash table like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/hash1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This looks straightforward: The keys in &lt;span class="code"&gt;split_lines&lt;/span&gt;
are the lines and the values are the corresponding split lines. You use Ruby’s
elegant &lt;span class="code"&gt;||=&lt;/span&gt; operator either to return a cached value
from the hash or actually call &lt;span class="code"&gt;split&lt;/span&gt;, updating the
hash.&lt;/p&gt;

&lt;p&gt;The only problem with this is that it doesn’t work. The code inside of the
&lt;span class="code"&gt;values&lt;/span&gt; function can’t access the &lt;span
class="code"&gt;split_lines&lt;/span&gt; hash, located outside the method.  And if you
move &lt;span class="code"&gt;split_lines&lt;/span&gt; inside of &lt;span class="code"&gt;values&lt;/span&gt;, it would become a
local variable and not retain values across method calls.&lt;/p&gt;

&lt;p&gt;To work around this problem you could pass the cache as an additional argument
to &lt;span class="code"&gt;values&lt;/span&gt;, but this would make your program even more
verbose than it is now.  Or you could create the &lt;span
class="code"&gt;values&lt;/span&gt; method using &lt;span
class="code"&gt;define_method&lt;/span&gt;, instead of &lt;span class="code"&gt;def&lt;/span&gt;,
like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/hash2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This confusing Ruby syntax allows the code inside of the new &lt;span class="code"&gt;values&lt;/span&gt; method to
access the surrounding scope, including the hash table.&lt;/p&gt;

&lt;p&gt;However, taking a step back, something about your program now feels wrong.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/step-back.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Instead of making your code simpler and easier to understand, functional
programming has started to make your Ruby code more confusing and harder to
read. You’ve introduced a new data structure to cache results, and resorted to
confusing metaprogramming to make it work. And your functions are still quite
repetitive.&lt;/p&gt;

&lt;p&gt;What’s gone wrong? Possibly Ruby isn’t the right language to use with
functional programming.&lt;/p&gt;

&lt;h2&gt;Introducing a Ruby Class&lt;/h2&gt;

&lt;p&gt;Next, you decide to forget all about functional programming and to try again by
using a Ruby class. You write a &lt;span class="code"&gt;Line&lt;/span&gt; class,
representing a single line of text from the timesheet text file:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;And you decide to move your functions into the new &lt;span class="code"&gt;Line&lt;/span&gt; class:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now you have a lot less noise. The biggest improvement is that now there’s no
need to pass the line of text around as a parameter to each function. Instead,
you hide it away in an instance variable, making the code much easier to read.
Also, your functions have become methods. Now you know all the functions
related to parsing lines are in the &lt;span class="code"&gt;Line&lt;/span&gt; class. You
know where to find them, and more or less what they are for. Ruby has helped
you organize your code using a class, which is really just a collection of
functions.&lt;/p&gt;

&lt;p&gt;Continuing to simplify, you refactor the &lt;span class="code"&gt;value&lt;/span&gt; method at the bottom to remove
the confusing &lt;span class="code"&gt;define_method&lt;/span&gt; syntax:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/refactor-values.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now each instance of the &lt;span class="code"&gt;Line&lt;/span&gt; class, each line of text you program uses, will
have its own copy of &lt;span class="code"&gt;@values&lt;/span&gt;. By using a Ruby class, you don’t need to
resort to a hash table to map between lines (keys) and split lines (values).
Instead you employ a very common Ruby idiom, combining an instance variable
&lt;span class="code"&gt;@values&lt;/span&gt;, with the &lt;span class="code"&gt;||=&lt;/span&gt;
operator. Instance variables are the perfect place to cache information such as
method return values.&lt;/p&gt;

&lt;h2&gt;Breaking All the Rules&lt;/h2&gt;

&lt;p&gt;Now your code is much easier to read. Using an object oriented instead of a
functional design turned out to be a good idea.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;With your object oriented solution, you have broken some of the most important
rules of functional programming: First, you created hidden state, the &lt;span
class="code"&gt;@line&lt;/span&gt; instance variable, wrapping it up and hiding it
inside the &lt;span class="code"&gt;Line&lt;/span&gt; class. The &lt;span class="code"&gt;@values&lt;/span&gt; instance
variable holds even more state information. And second, the &lt;span class="code"&gt;initialize&lt;/span&gt; and
&lt;span class="code"&gt;values&lt;/span&gt; methods have side effects: They change the value of &lt;span
class="code"&gt;@line&lt;/span&gt; and &lt;span class="code"&gt;@values&lt;/span&gt;. Finally,
all the other methods of &lt;span class="code"&gt;Line&lt;/span&gt; are no longer pure functions! They return values
that depend on state located outside of each function: the &lt;span
class="code"&gt;@line&lt;/span&gt; variable. In fact, they can return different values
even though they take no arguments at all.&lt;/p&gt;

&lt;p&gt;But I believe these are technicalities. You haven’t lost the benefits of
functional programming with this refactoring. While the methods of &lt;span
  class="code"&gt;Line&lt;/span&gt; depend on external state (&lt;span
  class="code"&gt;@line&lt;/span&gt; and &lt;span class="code"&gt;@values&lt;/span&gt;), that state
  isn’t located very far away. It’s still easy to predict, understand and test
  what these small functions do. Also, while &lt;span class="code"&gt;@line&lt;/span&gt; is
  technically a mutable string that you change in your program, in practice it
  isn’t. You set it once using &lt;span class="code"&gt;initialize&lt;/span&gt; and then
  never change it again. While you may update &lt;span class="code"&gt;@values&lt;/span&gt;
  each time &lt;span class="code"&gt;values&lt;/span&gt; is called, it&amp;rsquo;s just a performance
  optimization. It doesn’t change the overall behavior of values.&lt;/p&gt;

&lt;p&gt;You’ve broken the rules and rewritten your pure, functional program is a more
idiomatic, Ruby manner. However, you haven’t lost the spirit of functional
programming. Your code is just as easy to understand, maintain and test.&lt;/p&gt;

&lt;h2&gt;Creating an Object Pipeline&lt;/h2&gt;

&lt;p&gt;Wrapping up, you refactor your original program to use your new &lt;span
class="code"&gt;Line&lt;/span&gt; class like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Of course, there’s not much difference here. You simply added a line of code to
create new line objects, and then called its methods instead of your original
functions.&lt;/p&gt;

&lt;p&gt;Finally, you decide to take one step further and refactor again by mapping the
array of text lines to an array of line objects:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/object-pipeline.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 80px 0px 25px 20px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/factory.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Again, not much difference in the code. However, the way you think about your
program has changed dramatically. Now your code implements a pipeline of sorts,
passing data through a series of operations or transformations. You start with
an array of text lines from a file, convert them into an array of Ruby objects,
and finally process each object using your parse functions.&lt;/p&gt;

&lt;p&gt;This pattern of passing data through a series of operations is common in
languages such as Haskell and Clojure. What’s interesting here is how Ruby
objects are the perfect target for these operations. You’ve used a Ruby class
to implement a functional programming pattern.&lt;/p&gt;

&lt;br/&gt;


&lt;br/&gt;


&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; &lt;a href="https://twitter.com/orend"&gt;Oren Dobzinski&lt;/a&gt; suggested adding a
&lt;span class="code"&gt;to_s&lt;/span&gt; method to &lt;span class="code"&gt;Line&lt;/span&gt;, which
would allow us to push the object pipeline idea even further. Thanks Oren! See
Dave Thomas&amp;rsquo;s article &lt;a href="http://pragdave.me/blog/2014/02/11/telling-asking-and-the-power-of-jargon/"&gt;Telling, Asking, and the Power of
Jargon&lt;/a&gt;
for more background on &amp;ldquo;Tell, Don&amp;rsquo;t Ask.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse5.png"&gt;&lt;br/&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Use An Ask, Don’t Tell Policy With Ruby</title>
    <link href="http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby</id>
    <published>2014-02-10T01:00:00Z</published>
    <updated>2014-02-10T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/2/10/innisfree.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Innisfree is an actual island in Lough Gill, County Sligo, Ireland&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;The next time you need to develop a new algorithm, ask Ruby for what you want,
don’t tell it what to do. Don’t think of your code as a series of instructions
for t</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/2/10/innisfree.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Innisfree is an actual island in Lough Gill, County Sligo, Ireland&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;The next time you need to develop a new algorithm, ask Ruby for what you want,
don’t tell it what to do. Don’t think of your code as a series of instructions
for the computer to follow. Instead, ask Ruby for what you need: Your code
should state the solution to your problem, even if you’re not sure what that
solution is yet! Then dive into more and more detail, filling in your
solution’s gaps as you do. This can lead to a more expressive, functional
solution that you might not find otherwise.&lt;/p&gt;

&lt;p&gt;Too often over the years I’ve written code that consists of instructions for
the computer to follow. Do this, do that, and then finish by doing this third
thing. As I write code I imagine I am the computer, in a way, asking myself:
What do I need to do first to solve this problem? When I decide, this becomes
the first line of code in my program. Then I continue, writing each line of
code as another instruction for the computer to follow.&lt;/p&gt;

&lt;p&gt;But what does “Ask, Don’t Tell” mean exactly? And how could Ruby possibly know
the answer when I ask it something? An example will help you understand what I
mean.&lt;/p&gt;

&lt;h2&gt;Parsing a Yeats Poem&lt;/h2&gt;

&lt;p&gt;Last week I needed to parse a text file to obtain the lines of text that
appeared after a certain word. My actual task was very boring (separating blog
articles from their metadata), so instead let’s work with something more
beautiful, &lt;em&gt;The Lake Isle Of Innisfree&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;




&lt;blockquote&gt;
  I will arise and go now, and go to Innisfree,&lt;br/&gt;
  And a small cabin build there, of clay and wattles made:&lt;br/&gt;
  Nine bean-rows will I have there, a hive for the honeybee,&lt;br/&gt;
  And live alone in the bee-loud glade.&lt;br/&gt;
  &lt;br/&gt;
  And I shall have some peace there, for peace comes dropping slow,&lt;br/&gt;
  Dropping from the veils of the morning to where the cricket sings;&lt;br/&gt;
  There midnight's all a glimmer, and noon a purple glow,&lt;br/&gt;
  And evening full of the linnet's wings.&lt;br/&gt;
  &lt;br/&gt;
  I will arise and go now, for always night and day&lt;br/&gt;
  I hear lake water lapping with low sounds by the shore;&lt;br/&gt;
  While I stand on the roadway, or on the pavements grey,&lt;br/&gt;
  I hear it in the deep heart's core.&lt;br/&gt;
&lt;/blockquote&gt;


&lt;p&gt;My task is to write a Ruby script to return the line that contains a given
word, along with the following lines:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/console.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Telling Ruby What To Do&lt;/h2&gt;

&lt;p&gt;When I first wrote this script, I put myself in the computer’s shoes: What do I
need to do to find the target word? I started writing instructions for Ruby to
follow.&lt;/p&gt;

&lt;p&gt;First I need to open the file and read in the poem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/one.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here &lt;span class="code"&gt;File#readlines&lt;/span&gt; saves all the lines of text into an array, which the &lt;span class="code"&gt;parse&lt;/span&gt;
method will process, returning the result in another array. Later I join the
result lines together and print them out.&lt;/p&gt;

&lt;p&gt;How do I implement &lt;span class="code"&gt;parse&lt;/span&gt;? Again, I imagine that I am the computer, that I am
Ruby. How do I find the lines that follow &lt;em&gt;glimmer&lt;/em&gt;? Well, obviously I need to
loop through the array looking for the target word.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/two.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Once I find the word, I’ll start saving the lines into a new array called
&lt;span class="code"&gt;result&lt;/span&gt;. Since I want to save all the following lines and not just the matching
line, I’ll also use a boolean flag to keep track of whether I’ve already seen
the target.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/three.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;What’s wrong with this code? Nothing really. It works just fine, and it’s
even somewhat idiomatic Ruby. In the past, I would have probably considered
this done and moved on.&lt;/p&gt;

&lt;p&gt;However, I can do better than this. I can ask Ruby for what I want, instead of
telling Ruby what to do.&lt;/p&gt;

&lt;h2&gt;Ask Ruby For What You Want&lt;/h2&gt;

&lt;p&gt;Don’t imagine you are the computer. Don’t think about how to solve a problem by
figuring out what Ruby should do and then writing down instructions for it to
follow. Instead, start by asking Ruby for the answer.&lt;/p&gt;

&lt;p&gt;What should my method return? An array of the lines that appear after the
target word. To reflect this, I’ll rename my method from &lt;span class="code"&gt;parse&lt;/span&gt; (telling Ruby
what to do) to &lt;span class="code"&gt;lines_after&lt;/span&gt; (asking Ruby for what I want).&lt;/p&gt;

&lt;p&gt;This might seem like an unimportant detail, but naming methods is one of the
most difficult and important things a programmer does. Picking a name for a
method gives the reader a hint about what the method does, about what your
intentions were when you wrote it. Think of writing code the same way you would
think of writing an essay or story. You want your readers to understand what
you are saying, and to be able to follow along. (You also want them to enjoy
reading enough that they consider the code to be their own someday.)&lt;/p&gt;

&lt;p&gt;To get started I’ll write the new method to return an empty array.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/four.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Notice on the left I changed the label from “Instructions:” to “What do I
want?” This reflects my new way of thinking about the problem.&lt;/p&gt;

&lt;p&gt;Now, what does “appear after the target word” mean exactly? It means the lines
that appear in the array after (and including) the line containing the target.
Ah… in other words, the &lt;span class="code"&gt;lines_after&lt;/span&gt; method should return a subset or slice of the
array. Rewriting the problem in a different way lead me towards a solution I
hadn&amp;rsquo;t thought of before.&lt;/p&gt;

&lt;p&gt;Now I can rewrite the “What do I want?” text like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/five.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I rewrote what I want from Ruby to be more specific: I want a “portion of the
array” and I want the portion “including and following the line containing the
target.” I haven’t written much code yet, but I’ve taken a big step forward in
how I think about the problem.&lt;/p&gt;

&lt;p&gt;On the right, I’ve written code to return a subset of the array,
&lt;span class="code"&gt;lines[target_index..-1]&lt;/span&gt;. But my solution is still incomplete; what should
&lt;span class="code"&gt;target_index&lt;/span&gt; be?&lt;/p&gt;

&lt;p&gt;Thinking about this a bit, it’s easy to see how to find the line containing the
target string: I can use &lt;span class="code"&gt;detect&lt;/span&gt; to find the line that includes the target word.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/six.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But I’m still not done. I need the index of the line containing the target, not
the line itself. How can I find &lt;span class="code"&gt;target_index&lt;/span&gt;? Again, I shouldn’t tell Ruby what
to do (maybe create a local variable and loop through the lines checking each
one). Instead, I should ask Ruby for what I need. What do I need? I need the
index which corresponds to the line containing the target. In other words, I
need to find (to detect) the target index, not the target line.&lt;/p&gt;

&lt;p&gt;Here’s how to do it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/seven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here I use Ruby’s &lt;span class="code"&gt;detect&lt;/span&gt; method to search a range of index values, not lines.
Inside the block I check whether the line corresponding to each index
(&lt;span class="code"&gt;lines[i]&lt;/span&gt;) contains the target. At the bottom I return the correct slice of the
array if I found the target, or an empty array if I didn’t.&lt;/p&gt;

&lt;h2&gt;Learning From Functional Languages&lt;/h2&gt;

&lt;p&gt;In my opinion this code is better than what I showed earlier. Why? They both
work equally well. What’s the difference? Let&amp;rsquo;s take a look at them side-by-side.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/compare.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;First of all, I have simpler, more terse code. Less code is better. The &lt;span class="code"&gt;lines_after&lt;/span&gt;
method contains just 4 lines of code while the &lt;span class="code"&gt;parse&lt;/span&gt; method
contains 9. Of course, I could find ways to rewrite &lt;span class="code"&gt;parse&lt;/span&gt; to use
fewer lines, but any way you look at it &lt;span class="code"&gt;lines_after&lt;/span&gt; is simpler than &lt;span class="code"&gt;parse&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;parse&lt;/span&gt; method contains two local variables which are changed, or &lt;em&gt;mutated&lt;/em&gt;, by
code inside the loop. This makes the method harder to understand. What is the
value of &lt;span class="code"&gt;flag&lt;/span&gt;? What about &lt;span class="code"&gt;result&lt;/span&gt;? To really understand how &lt;span class="code"&gt;parse&lt;/span&gt; works you
almost need to simulate the loop inside your head, thinking about how the flag
and result values change over time.&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;lines_after&lt;/span&gt; method also contains two local variables. However, they aren’t used
in the same way &amp;ndash; they aren’t changed as the program runs. The block
parameter, &lt;span class="code"&gt;i&lt;/span&gt;, while different each time the block is called, doesn’t change
inside the block. It’s meaning is clear and unambiguous while that block is
running. Similarly, the &lt;span class="code"&gt;target_index&lt;/span&gt; variable is set once to an intermediate
value, not changed once each time around a loop.&lt;/p&gt;

&lt;p&gt;Terse, simple code that doesn’t change values while it is running is the
hallmark of functional programming languages like Haskell or Clojure. While
these languages allow you to write concurrent code without using locks, their
chief benefit is that they encourage (Clojure) or even force you (Haskell) to write simple, terse
code. Code that asks the computer for what you need, not code that tells the
computer what to do.&lt;/p&gt;

&lt;p&gt;But, as we’ve seen, you don’t need to abandon Ruby to write functional code.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; Simon Kröger and Josh Cheek both suggested using &lt;span
  class="code"&gt;drop_while&lt;/span&gt;, which gives us an even more readable,
functional solution:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/eight.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I also decided to rename the &lt;span class="code"&gt;after&lt;/span&gt; method to &lt;span
  class="code"&gt;lines_after&lt;/span&gt;, based on the comments from TenderGlove and
John Kary. I agree with them &lt;span class="code"&gt;after&lt;/span&gt; would make more sense if I
called it as a method on an object containing the lines (e.g. &lt;span class="code"&gt;lines.after&lt;/span&gt;). But as a simple
function like in this example &lt;span class="code"&gt;lines_after&lt;/span&gt; is more
expressive.&lt;/p&gt;

&lt;p&gt;Thanks guys!&lt;/p&gt;

&lt;h2&gt;Learning From Sandi Metz&lt;/h2&gt;

&lt;p&gt;In her famous book, &lt;a href="http://www.poodr.com"&gt;Practical Object-Oriented Design in Ruby&lt;/a&gt;, Sandi Metz
mentions the Ask, Don’t Tell policy also, but using slightly different words.
With her brilliant bicycle examples, Sandy shows us in Chapter 4 of
POODR why we should be &lt;em&gt;Asking for &amp;ldquo;What&amp;rdquo; Instead of Telling &amp;ldquo;How&amp;rdquo;&lt;/em&gt;. When you
send a message to an object, you should ask it for what you want, not tell it
what to do or make assumptions about how it works internally. Sandi shows us
how this policy &amp;ndash; along with other important design principles &amp;ndash; helps us write
classes that are more independent and decoupled one from the other.&lt;/p&gt;

&lt;p&gt;The Ask, Don’t Tell policy applies equally well to functional programming and
object oriented programming. At a lower level, it helps us write more terse,
functional Ruby methods. Stepping back, it can also help us design object
oriented applications that are easier to maintain and extend.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update #2:&lt;/b&gt; Apparently I’ve (unknowingly) conflated “Ask, Don’t Tell” with the
“Tell, Don’t Ask,” advice Dave Thomas has been giving us for years to make a
different but related point about object oriented design.  Dave explains here:
&lt;a href="http://pragdave.me/blog/2014/02/11/telling-asking-and-the-power-of-jargon/"&gt;Telling, Asking, and the Power of
Jargon&lt;/a&gt;.
He also disagrees with my opinion that the &lt;span
  class="code"&gt;parse_lines&lt;/span&gt; example was written in a functional style.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What does (((λ f . (λ x . (f x))) (λ a . a)) (λ b . b)) mean?</title>
    <link href="http://patshaughnessy.net/2014/1/30/what-does-f-x-f-x-a-a-b-b-mean" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/1/30/what-does-f-x-f-x-a-a-b-b-mean</id>
    <published>2014-01-30T01:00:00Z</published>
    <updated>2014-01-30T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;p&gt;This week I’ve been spending some free time between projects working on my
function programming skills. I’m a Ruby developer but have always been
fascinated by functional languages such as Haskell, Clojure and of course Lisp.
I was excited this morning when I stumbled across a fascinating article called
&lt;a href="http://matt.might.net/articles/implementing-a-programming-language/"&gt;7 lines of code</summary>
    <content type="html">&lt;p&gt;This week I’ve been spending some free time between projects working on my
function programming skills. I’m a Ruby developer but have always been
fascinated by functional languages such as Haskell, Clojure and of course Lisp.
I was excited this morning when I stumbled across a fascinating article called
&lt;a href="http://matt.might.net/articles/implementing-a-programming-language/"&gt;7 lines of code, 3 minutes: Implement a programming language from scratch&lt;/a&gt;. The
author, &lt;a href="https://twitter.com/mattmight"&gt;Matthew Might&lt;/a&gt;, touches on Lambda Calculus notation before implementing
a simple interpreter for Lambda Calculus using just seven lines of Scheme code.
He later proceeds to write a Scheme interpreter in about 100 lines of code,
using a dialect of Scheme called &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Matthew starts by introducing the basics of Lambda Calculus notation like this:&lt;/p&gt;

&lt;div style="margin: 20px 0 0 100px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/30/basics.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Matthew explains that all of Lambda Calculus is based on these two simple
concepts, along with variable references. He then shows a couple of simple examples:&lt;/p&gt;

&lt;div style="margin: 20px 0 0 100px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/30/examples.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;&amp;hellip;and then asks the reader this simple question:&lt;/p&gt;

&lt;div style="margin: 20px 0 0 100px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/30/question.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;In this post I’ll try to answer this question using a series of diagrams. I’m a
visual learner, and teacher. For me drawing something makes it much easier to
understand and to explain to someone else. Lambda Calculus experts (“Lambda
Mathematicians?”) probably have accepted styles for drawing these concepts
which I’m not aware of. I’ll just draw what comes naturally to me.&lt;/p&gt;

&lt;h2&gt;Getting Rid of All Those Parentheses&lt;/h2&gt;

&lt;p&gt;If I had a whiteboard, I’d rewrite the complex Lambda Calculus expression above
with circles instead of parentheses. This makes it much easier for me to see
the nesting and order of operations. An even better visualization might be a tree structure, but I&amp;rsquo;ll keep things inline with cirlces today.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/one.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;For me, the biggest challenge to understanding Lisp or Scheme has always been
all the nested parentheses. This picture is still cryptic and meaningless, but
now at least I can see the order of operations and nesting more easily.&lt;/p&gt;

&lt;h2&gt;Start From the Inside and Work Your Way Out&lt;/h2&gt;

&lt;p&gt;To understand what’s going on here, I started with the innermost lambda
expression:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/two.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Referring to Matthew’s explanation above, &lt;span class="code"&gt;(f x)&lt;/span&gt; means evaluate the function &lt;span class="code"&gt;f&lt;/span&gt;
on the argument &lt;span class="code"&gt;x&lt;/span&gt;. Therefore, this expression represents an anonymous function
that applies some function &lt;span class="code"&gt;f&lt;/span&gt; to its argument, &lt;span class="code"&gt;x&lt;/span&gt;. The oval on the left is the
function and I’ve written this explanation on the right: what the function
does.&lt;/p&gt;

&lt;p&gt;I usually visualize functions with inputs and outputs, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/three.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see the input &lt;span class="code"&gt;x&lt;/span&gt; comes from the left, and I’ve shown the anonymous
function in the center using a half-oval. It applies a function &lt;span class="code"&gt;f&lt;/span&gt;, which is
almost like a second input value, to &lt;span class="code"&gt;x&lt;/span&gt; and returns an output value on the
right.&lt;/p&gt;

&lt;h2&gt;Higher Order Functions&lt;/h2&gt;

&lt;p&gt;Now let’s substitute this simple function back into the complex expression:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/four.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see I’ve pasted the text “Apply f to my argument” into the center of
the expression where the previous lambda was located. Working my way out, let’s
take a look at what the next lambda expression means:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/five.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see a definition for another anonymous function, another lambda
expression, which takes &lt;span class="code"&gt;f&lt;/span&gt; as an argument. The body of the function is our
previous expression.&lt;/p&gt;

&lt;p&gt;What this boils down to, therefore, is a function that takes a function as an
argument and returns a second function as a result. Here’s what this might look
like using my input/output diagram style:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/six.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left you can see the function takes a function, &lt;span class="code"&gt;f&lt;/span&gt;, as input. On the
right the dashed rectangle represents a single output value: another function.
This is an example of a higher order function, a function that can use other
functions as inputs or outputs.&lt;/p&gt;

&lt;p&gt;In this example, the output is a new function which applies &lt;span class="code"&gt;f&lt;/span&gt;, the input of the
higher order function, to its argument &lt;span class="code"&gt;x&lt;/span&gt;. We don’t have a value for &lt;span class="code"&gt;x&lt;/span&gt; yet, but
we have a new function which later can take an input &lt;span class="code"&gt;x&lt;/span&gt;. It will apply the
present input, &lt;span class="code"&gt;f&lt;/span&gt;, to whatever argument it receives later, &lt;span class="code"&gt;x&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The other subtle detail to think about here is that above, when we looked at
the innermost lambda expression, the value &lt;span class="code"&gt;f&lt;/span&gt; was undefined. The inner lambda
applied &lt;span class="code"&gt;f&lt;/span&gt; to its input &lt;span class="code"&gt;x&lt;/span&gt;, not knowing what &lt;span class="code"&gt;f&lt;/span&gt; was. Now &lt;span class="code"&gt;f&lt;/span&gt; has been provided by
the surrounding expression, the outer lambda. &lt;span class="code"&gt;f&lt;/span&gt; is the input to the outer
lambda. I’m not sure about this, but I suspect lambda mathematicians would say
the outer lambda is a closure around the free variable, &lt;span class="code"&gt;f&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Identity Functions&lt;/h2&gt;

&lt;p&gt;Substituting again, here’s the entire expression simplified:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/seven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The two lambdas on the right are easier to follow. These are examples of the
identity function, a function that returns its argument. Matthew showed this
syntax as one of his examples.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/eight.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see here the identity function simply passes its input along as an
output:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/nine.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Evaluating a Function&lt;/h2&gt;

&lt;p&gt;Substituting again, here’s what we have now:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/ten.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Earlier we saw the higher order function on the left returns a function that
will later operate on an argument, which I showed as &lt;span class="code"&gt;x&lt;/span&gt;. Now its time has come.
Recall that &lt;span class="code"&gt;(f x)&lt;/span&gt; in Lambda Calculus means “evaluate the function &lt;span class="code"&gt;f&lt;/span&gt; on the
argument &lt;span class="code"&gt;x&lt;/span&gt;.”&lt;/p&gt;

&lt;p&gt;In other words, this expression:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/eleven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;… means: “evaluate the higher order function on the left, providing the
function on the right as an argument.”&lt;/p&gt;

&lt;p&gt;The higher order function will take one function (the identity function) and
return another:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/twelve.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The output is a new function which will apply the identity function (the
argument) to its own argument &lt;span class="code"&gt;x&lt;/span&gt;. Of course, this is equivalent to the identity
function itself!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/thirteen.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;There must be some Lambda Calculus axiom (the “lambda identity axiom?”) behind
this deduction, but I’m not sure. I’ll consider it obvious and just move on.&lt;/p&gt;

&lt;h2&gt;The Result&lt;/h2&gt;

&lt;p&gt;Substituting this result back into the original expression, we’re left with
this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/fourteen.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Reapplying the “lambda identity axiom” again it’s
obvious this is equivalent to the identity function:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/fifteen.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;That is, the identity function is also a higher order function. It returns the
same functions you pass to it, unchanged.&lt;/p&gt;

&lt;p&gt;Stepping back and taking stock, we’ve deduced that:&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;(((λ f . (λ x . (f x))) (λ a . a)) (λ b . b))&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Is equivalent to:&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;(λ x . x)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Or the identity function.&lt;/p&gt;

&lt;h2&gt;What Did I Get Wrong?&lt;/h2&gt;

&lt;p&gt;As I mentioned, I’m just learning about functional programming and lambda
calculus. If you have some computer science training and see something wrong
here, let me know. Or if you know the real name for the “lambda identity axiom”
or have examples of better diagrams for representing lambda expressions, please
pass along a link.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby Multiplies Like a Fourth Grader</title>
    <link href="http://patshaughnessy.net/2014/1/24/ruby-multiplies-like-a-fourth-grader" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/1/24/ruby-multiplies-like-a-fourth-grader</id>
    <published>2014-01-24T01:00:00Z</published>
    <updated>2014-01-24T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 40px 0px; text-align: center;"&gt; &lt;img
  src="http://patshaughnessy.net/assets/2014/1/24/multiply.jpg"&gt;&lt;br/&gt; &lt;i&gt;Ruby
    multiplies large integers using the same&lt;br/&gt; algorithm we learned in
    elementary school.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;Imagine yourself as an 8 or 9 year old at a chalkboard learning to multiply.
Your teacher asks you to write one number over anothe</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 40px 0px; text-align: center;"&gt; &lt;img
  src="http://patshaughnessy.net/assets/2014/1/24/multiply.jpg"&gt;&lt;br/&gt; &lt;i&gt;Ruby
    multiplies large integers using the same&lt;br/&gt; algorithm we learned in
    elementary school.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;Imagine yourself as an 8 or 9 year old at a chalkboard learning to multiply.
Your teacher asks you to write one number over another, and then to draw an “x”
and a line below. Next you multiply the numbers one digit at a time, using the
multiplication table you memorized the year before. Your teacher also shows you
how to “carry” values from one column to the next when they don’t fit as a
single digit.&lt;/p&gt;

&lt;p&gt;After studying Ruby’s multiplication algorithm, I was surprised to find out
that Ruby multiplies large numbers (&lt;span class="code"&gt;Bignum&lt;/span&gt;’s) the
same way you learned in fourth grade: one “digit” at a time. My post today will
give you a quick refresher course on fourth grade math, and then explain how
Ruby’s &lt;span class="code"&gt;Bignum&lt;/span&gt; class uses the same classic, long
multiplication algorithm you learned in elementary school!&lt;/p&gt;

&lt;h2&gt;A Crash Course in Fourth Grade Math&lt;/h2&gt;

&lt;p&gt;We all remember multiplication tables: memorizing them was either a fun mental
exercise &amp;ndash; or a painful form of torture &amp;ndash; depending on our mathematical
aptitude and the personality of our grade school teacher. Regardless, there
were two reasons for memorizing simple products such as 5 x 6 = 30 or 9 x 7 =
63.  First, these simple problems occur frequently; and second, they help us
later when multiplying larger numbers.&lt;/p&gt;

&lt;p&gt;Maybe you flunked out of school before the fourth grade, or more likely you’ve
become so dependent on your iPhone’s calculator app you don’t remember how to
multiply by hand. Before we look at how Ruby multiplies numbers, let’s review
the classic long multiplication algorithm.&lt;/p&gt;

&lt;p&gt;Here’s a sample problem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now walk up to the chalkboard and write the two numbers one above the other,
the larger number on top:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 40px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/24/mult-tables.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Remember what to do next? For me fourth grade was in the 1970s, but somehow it
still comes back to me! Start by multiplying the rightmost digits from each
number together (2 x 9 = 18), placing the product below the line:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;However, since 18 is too large to fit into a single digit you “carry” the 1 up
to the top of the next column, and leave the 8 behind:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Next multiply 9 again by the next digit from the top number, 3 in this example,
adding  the 1 you carried from the last step. So you calculate (9x3)+1 = 28.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here I’ve written the 28 below the line, to the left of the previous 8 value.
So far you’ve calculated that 9x32 = 288.&lt;/p&gt;

&lt;p&gt;Remember what to do next? I know it’s been a long time! Repeat the process with
the next digit from the lower number, 2. In other words, you calculate 2x32=64.
However, this time you write the product farther below, shifted to the left
like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample6.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You shift the numbers to the left because the 2 from 29 is actually a 20. Now
all you need to do is add the two intermediate products together, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample7.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Drop the first 8 down, add 8+4=12, carry the 1 and finally calculate 1+2+6 = 9.
You have the answer, 928. Congratulations, you’ve managed to multiply two
numbers by hand without a calculator!&lt;/p&gt;

&lt;h2&gt;Ruby’s Multiplication Table&lt;/h2&gt;

&lt;div style="float: right; padding: 7px 0px 40px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/24/intel.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;The Intel 4004 was the first&lt;br/&gt;
    commercially available microprocessor&lt;br/&gt;(source: &lt;a href="http://commons.wikimedia.org/wiki/File:Intel_4004.jpg"&gt;wikimedia commons&lt;/a&gt;)&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;To multiply small numbers Ruby doesn’t implement a software algorithm. Instead,
Ruby relies on your computer’s microprocessor’s hardware circuits to perform
the calculation. Your microprocessor, in a sense, plays the role of a
multiplication table for Ruby. By using a machine language instruction to
multiply numbers, Ruby can get simple products very quickly. This is loosely
analogous to you or I memorizing the simple products from the multiplication
table in our heads.&lt;/p&gt;

&lt;p&gt;As I discussed in &lt;a href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum"&gt;my last article&lt;/a&gt;, Ruby stores small integers as native 64-bit
values using the &lt;span class="code"&gt;Fixnum&lt;/span&gt; class. For example, in Ruby we could multiply two
numbers like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/five-six-ruby.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;When you execute this program, Ruby’s internal C code represents these two
numbers as &lt;span class="code"&gt;Fixnum&lt;/span&gt; objects:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/fixnums.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;As you can see, Ruby represents each &lt;span class="code"&gt;Fixnum&lt;/span&gt; with a 64-bit binary value with the
least significant bit (FIXNUM_FLAG) set. When it needs to multiply, Ruby first removes the FIXNUM_FLAG bit and is
left with the actual binary values 5 and 6. Now it can perform the
multiplication using a native machine language instruction.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/fixnums-multiply.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above &lt;span class="code"&gt;imulq&lt;/span&gt; is the Intel x86-64 assembly language
instruction for multiplying integers. Ruby relies on the microprocessor to
calculate 5x6 and to return the product 30, shown as binary at the bottom.&lt;/p&gt;

&lt;h2&gt;A Fourth Grader That Knows Hexadecimal&lt;/h2&gt;

&lt;p&gt;Ruby multiplies large numbers exactly the same way you and I do, using the
classic long multiplication algorithm. We use long multiplication to multiply
numbers larger than 12, since the multiplication tables we memorized went up to
12. Ruby uses long multiplication for numbers that don’t fit into a &lt;span class="code"&gt;Fixnum&lt;/span&gt;
object &amp;ndash; numbers so large that a single machine language instruction can’t
process them.&lt;/p&gt;

&lt;p&gt;Here’s an example problem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The number 29 fits into a &lt;span class="code"&gt;Fixnum&lt;/span&gt; no problem, but 10000000000000000000 does not.
Instead, Ruby represents this large integer using a &lt;span class="code"&gt;Bignum&lt;/span&gt; object, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/bignum.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see a simplified view of the &lt;span class="code"&gt;RBignum&lt;/span&gt; C structure at the top. The &lt;span class="code"&gt;digits&lt;/span&gt;
pointer saves the location of an array of 32-bit values, the “digits.” As I
explained in &lt;a href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum"&gt;my last article&lt;/a&gt;, the digits are actually out of order, with the
lower 32 bits on the left and the top 32 bits on the right.&lt;/p&gt;

&lt;p&gt;Since Ruby represents &lt;span class="code"&gt;Bignum&lt;/span&gt;’s with a complex data structure and not simple
64-bit integers, it can’t use machine language instructions to perform
mathematical operations on them. What does Ruby do instead? How did it
calculate 10000000000000000000 * 29 above?&lt;/p&gt;

&lt;p&gt;It turns out Ruby uses long multiplication, just as we did in fourth grade! The
only difference is that Ruby uses 32-bit “digits,” instead of digits that
contain decimal values from 0-9.&lt;/p&gt;

&lt;p&gt;To see what I mean, here’s another look at the 32x29 problem we did earlier:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/another-look.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above I show a rectangle around each 0-9 decimal digit. Remember the long
multiplication algorithm works on one pair of digits at a time. The 0-9
notation means that each digit can hold a value between 0 and 9.&lt;/p&gt;

&lt;p&gt;Now let’s take another look at the large integer multiplication Ruby executed
above:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;If I redraw this using 32-bit “digits,” I get this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Each rectangle is a 32-bit word present in a &lt;span class="code"&gt;Bignum&lt;/span&gt; &lt;span class="code"&gt;digit&lt;/span&gt; data structure. At the bottom
we see 0x1d, which is 29. (This does fit into a &lt;span class="code"&gt;Fixnum&lt;/span&gt; but Ruby moves it to a &lt;span class="code"&gt;Bignum&lt;/span&gt; before the multiplication starts.) Above that are the bits from the &lt;span class="code"&gt;RBignum&lt;/span&gt; structure, shown in the proper order. 0x8ac72304 are the most significant 32 bits
and 0x89e80000 are the least significant 32 bits. In order words, the
hexadecimal value 0x8ac7230489e80000 is equivalent to 10000000000000000000.&lt;/p&gt;

&lt;p&gt;It might seem bizarre to show a multiplication problem this way, but remember
Ruby is a  very special fourth grader, one that knows how to perform binary
math and can understand hexadecimal.&lt;/p&gt;

&lt;h2&gt;Multiplying Bignums Using Long Multiplication&lt;/h2&gt;

&lt;p&gt;Once we’ve drawn the problem using 32-bit hexadecimal digits, we’ll be able to
see that Ruby performs long multiplication just like you or I did back in school.
First, it multiplies the rightmost digits from each number.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;So we have 0x89e80000 * 0x1d = 0xf9f480000. But now the top 4 bits, the 0xf,
doesn’t fit into a single 32-bit value. So Ruby “carries” the 0xf to the next
column.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see above the carried value 0xf at the top left, and the remaining bits
in the 32-bit digit at the bottom right.&lt;/p&gt;

&lt;p&gt;Now Ruby calculates 0x8ac72304 * 0x1d + 0xf and gets 0xfb88ef783.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample6.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Once again, 0xfb88ef783 doesn’t fit into 32 bits, so Ruby carries the extra 0xf
to the next column. Since this was the last column, Ruby is done and just moves
the extra 0xf into a new 32-bit digit:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample7.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;And now we have our answer:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample8.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Multiplication of Extremely Large Numbers&lt;/h2&gt;

&lt;p&gt;This was a very simple example, because 29 was actually a small integer. This
meant Ruby didn’t need to use multiple rows in the long multiplication process,
adding them together to get the final result. But Ruby would use multiple rows in
long multiplication just the way we would if both numbers were large.&lt;/p&gt;

&lt;p&gt;However, Ruby’s &lt;span class="code"&gt;Bignum&lt;/span&gt; class was also designed to handle extremely large numbers
that might contain thousands of digits. You might need these for certain
scientific applications or in cryptography, for example. To handle extremely
large numbers, the &lt;span class="code"&gt;Bignum&lt;/span&gt; class also contains some alternative, advanced
mathematical algorithms for multiplication, division and more. Ruby 2.1 also now optionally supports the GMP, the &lt;a href="https://gmplib.org"&gt;GNU
Multiple Precision Arithmetic Library&lt;/a&gt;. In my next post I’ll take a look at how
to enable GMP support and how to use it.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How Big is a Bignum?</title>
    <link href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum</id>
    <published>2014-01-09T01:00:00Z</published>
    <updated>2014-01-09T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/9/classes.png"&gt;&lt;br/&gt;
  &lt;i&gt;Ruby represents small integers using Fixnum&lt;br/&gt;
    and large integers using Bignum.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Most of us don’t use Ruby to perform complex calculations for science,
engineering or cryptography applications; instead, we migh</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/9/classes.png"&gt;&lt;br/&gt;
  &lt;i&gt;Ruby represents small integers using Fixnum&lt;br/&gt;
    and large integers using Bignum.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Most of us don’t use Ruby to perform complex calculations for science,
engineering or cryptography applications; instead, we might turn to R, Matlab
or some other programming language or tool for that sort of thing. When we calculate
values using Ruby, it’s often to process simple values while generating a web
page using ERB or Haml, or to handle the result of a database query using
ActiveRecord. Almost all of the time, Ruby’s &lt;span class="code"&gt;Fixnum&lt;/span&gt;
class is more than sufficient.&lt;/p&gt;

&lt;p&gt;For most Ruby developers, therefore, the &lt;span class="code"&gt;Bignum&lt;/span&gt; class is a dark, unfamiliar
corner of the language. Today I’d like to shed some light on &lt;span class="code"&gt;Bignum&lt;/span&gt; by looking
at how Ruby represents integers internally inside the &lt;span class="code"&gt;Fixnum&lt;/span&gt; and &lt;span class="code"&gt;Bignum&lt;/span&gt;
classes. What’s the largest integer that fits inside a &lt;span
  class="code"&gt;Fixnum&lt;/span&gt;; just how big is a &lt;span
  class="code"&gt;Bignum&lt;/span&gt;?&lt;/p&gt;

&lt;p&gt;Also, it turns out that Ruby 2.1 contains an important new change for the
&lt;span class="code"&gt;Bignum&lt;/span&gt; class: support for the &lt;a href="https://gmplib.org"&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; library.
In my next post, I’ll take a look at mathematical theory and history behind
some of the algorithms used by &lt;span class="code"&gt;Bignum&lt;/span&gt; internally and how Ruby 2.1 works
with GMP. But for now, let’s start with the basics.&lt;/p&gt;

&lt;h2&gt;64-Bit Integers&lt;/h2&gt;

&lt;p&gt;Most computers these days represent numbers as 64 digit binary values
internally. For example, the number ten thousand looks like this expressed as a
binary value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/64-bits.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;My rectangle here represents how a 64-bit computer would save an integer in a
microprocessor register or a RAM memory location. The numbers 63 and 0 indicate
that there are spaces for 64 binary digits, each of which can contain a zero or
one. The most significant binary digit, #63, is on the left, while the least
significant digit, #0, is on the right. I’m not showing all of the leading
zeroes here to keep things simple.&lt;/p&gt;

&lt;p&gt;The term &lt;em&gt;64-bit architecture&lt;/em&gt; means the logic gates, transistors and circuits
located on your microprocessor chip are designed to process binary values using
64 binary digits like this, in parallel. Whenever your code uses an integer,
the microprocessor retrieves all of these on/off values from one of the RAM
chips in your CPU using a “bus” or set of 64 parallel connections.&lt;/p&gt;

&lt;h2&gt;64-Bit Integers in MRI Ruby&lt;/h2&gt;

&lt;p&gt;The standard implementation of Ruby, Matz’s Ruby Interpreter (MRI), saves
integers using a slightly different, custom format; it hard codes the least
significant digit (on the right in my diagram) to one and shifts the actual
integer value one bit to the left. As we’ll see in a moment, if this bit were
zero Ruby would instead consider the integer to be a pointer to some Ruby
object.&lt;/p&gt;

&lt;p&gt;Here’s how Ruby represents ten thousand
internally:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/64-bits-ruby.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;=1 indicates this integer represents an instance of the &lt;span class="code"&gt;Fixnum&lt;/span&gt;
class. The flag is a performance optimization, removing the need for Ruby to
create a separate C structure the way it normally would for other types of
objects. (Ruby uses a similar trick for symbols and special values such as
&lt;span class="code"&gt;true&lt;/span&gt;, &lt;span class="code"&gt;false&lt;/span&gt; and &lt;span class="code"&gt;nil&lt;/span&gt;.)&lt;/p&gt;

&lt;h2&gt;Two’s Complement in Ruby&lt;/h2&gt;

&lt;p&gt;Like most other computer languages and also like your microprocessor’s actual hardware
circuits, Ruby uses a binary format called &lt;a href="http://en.wikipedia.org/wiki/Two's_complement"&gt;two’s complement&lt;/a&gt; to save negative
integers. Here’s how the value -10,000 would be saved inside your Ruby program:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/twos-complement-ruby.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Note the first bit on the left, the sign bit, is set to 1. This indicates this
is a negative integer. Ruby still sets the lowest bit, &lt;span
  class="code"&gt;FIXNUM_FLAG&lt;/span&gt;, to 1. The other bits contain the value
itself. To calculate a two’s complement value for a negative integer, your
microprocessor adds one to the absolute value (getting 10,001 in this example)
and then reverses the zeroes and ones. This is equivalent to subtracting the
absolute value from the next highest power of two. Ruby uses two’s complement
in the same way, except it adds &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt; on the
right and shifts the rest of the value to the left.&lt;/p&gt;

&lt;h2&gt;The Largest Fixnum Value: 4611686018427387903&lt;/h2&gt;

&lt;p&gt;Using 64-bit binary values with &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;, Ruby is able to take advantage of
your computer’s microprocessor to represent integer values efficiently. Addition,
subtraction and other integer operations can be handled using the
corresponding assembly language instructions by removing and then re-adding
&lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt; internally as needed. This design only
works, however, for integer values that are small enough to fit into a single
64-bit word. We can see what the largest positive &lt;span
  class="code"&gt;Fixnum&lt;/span&gt; integer must be by setting all 62 of the middle
bits to one, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/largest-value.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here we have a zero on the left (indicating this is a positive integer) and a
one on the right (for &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;). The remaining 62 bits in the middle hold
this binary number:&lt;br/&gt;
11111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;

&lt;p&gt;Converting this to decimal we get: 4611686018427387903, the largest integer
that fits into a &lt;span class="code"&gt;Fixnum&lt;/span&gt; object. (If you compiled Ruby on a 32-bit computer, of
course, the largest &lt;span class="code"&gt;Fixnum&lt;/span&gt; would be much smaller than this, only 30-bits wide.)&lt;/p&gt;

&lt;h2&gt;The Smallest Bignum: 4611686018427387904&lt;/h2&gt;

&lt;p&gt;But what does Ruby do if we want to use larger numbers? For example, this Ruby
program works just fine:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/code.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But now the sum doesn’t fit into a 64-bit &lt;span class="code"&gt;Fixnum&lt;/span&gt; value, since expressing
4611686018427387904 as a binary value requires 63 digits, not 62:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/doesnt-fit.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is where the &lt;span class="code"&gt;Bignum&lt;/span&gt; class comes in. While calculating
4611686018427387903+1, Ruby has to create a new type of object to represent
4611686018427387904 &amp;ndash; an instance of the &lt;span class="code"&gt;Bignum&lt;/span&gt; class. Here’s how that looks
inside of Ruby:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/pointer.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the right you can see Ruby has reset the &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt; to zero, indicating
this value is not a &lt;span class="code"&gt;Fixnum&lt;/span&gt; but instead a pointer to some other type of object.
(C programs like MRI Ruby that use &lt;span class="code"&gt;malloc&lt;/span&gt; to allocate memory always get
addresses that end in zero, that are &lt;em&gt;aligned&lt;/em&gt;. This means the &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;, a
zero, is actually also part of the pointer’s value.)&lt;/p&gt;

&lt;h2&gt;The RBignum Structure&lt;/h2&gt;

&lt;p&gt;Now let’s take a closer look at the &lt;span class="code"&gt;RBignum&lt;/span&gt; C structure and find out what’s
inside it. Here’s how Ruby saves the value 4611686018427387904 internally:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/closer-look.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left, you can see &lt;span class="code"&gt;RBignum&lt;/span&gt; contains an inner structure called &lt;span class="code"&gt;RBasic&lt;/span&gt;,
which contains internal, technical values used by all Ruby objects. Below that
I show values specific to &lt;span class="code"&gt;Bignum&lt;/span&gt; objects: &lt;span class="code"&gt;digits&lt;/span&gt; and &lt;span class="code"&gt;len&lt;/span&gt;. &lt;span class="code"&gt;digits&lt;/span&gt; is a pointer
to an array of 32-bit values that contain the actual big integer’s bits grouped
into sets of 32. &lt;span class="code"&gt;len&lt;/span&gt; records how many 32-bit groups are in the &lt;span class="code"&gt;digits&lt;/span&gt; array.
Since there can be any number of groups in the &lt;span class="code"&gt;digits&lt;/span&gt; array, Ruby can represent
arbitrarily large integers using &lt;span class="code"&gt;RBignum&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Ruby divides up the bits of the big integer into 32-bit pieces. On the left,
the first 32-bit value contains the least significant 32 bits from the big
integer, bit 31 down to bit 0. Following that, the second value contains bits
63-32. If the big integer were larger, the third value would contain bits
95-64, etc. Therefore, the large integer’s bits are actually not in order: The
groups of bits are in reverse order, while the bits inside each group are in
the proper order.&lt;/p&gt;

&lt;p&gt;To save a &lt;span class="code"&gt;Bignum&lt;/span&gt; value, Ruby starts by saving the
least significant bits of the target integer into the first 32-bit digit group.
Then it shifts the remaining bits 32 places to the right and saves the next 32
least significant bits into the next group. Ruby continues shifting and saving
until the entire big integer has been processed.&lt;/p&gt;

&lt;p&gt;Ruby allocates enough 32-bit pieces in the &lt;span class="code"&gt;digits&lt;/span&gt; array to provide enough room
for the entire large integer. For example, for an extremely large number
requiring 320 bits, Ruby could use 10 32-bit values by setting &lt;span class="code"&gt;len&lt;/span&gt; to 10 and
allocating more memory:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/ten-digits.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In my example Ruby needs just two 32-bit values. This makes sense because, as
we saw above, 4611686018427387903 is a 62-bit integer (all ones) and when I add one I get a 63-bit value. When I add
one, Ruby first copies the 62 bits in the target value into a new &lt;span class="code"&gt;Bignum&lt;/span&gt; structure, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/copy-to-bignum.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Ruby copies the least significant 32 bits into the first digit
value on the left, and the most significant 30 into the second digit value on
the right (there is space for two leading zeroes in the second digit value).&lt;/p&gt;

&lt;p&gt;Once Ruby has copied 4611686018427387903 into a new &lt;span
  class="code"&gt;RBignum&lt;/span&gt; structure, it can then use a special algorithm
implemented in bignum.c to perform an addition operation on the new Bignum. Now
there is enough room to hold the 63-bit result, 4611686018427387904 (diagram copied from above):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/closer-look.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;A few other minor details to learn about this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ruby saves the sign bit inside the &lt;span class="code"&gt;RBasic&lt;/span&gt;
  structure, and not in the binary digit values themselves. This saves a bit of
  space, and makes the code inside bignum.c simpler.&lt;/li&gt;

  &lt;li&gt;Ruby also doesn’t need to save the &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;
  in the digits, since it already knows this is a &lt;span
    class="code"&gt;Bignum&lt;/span&gt; value and not a &lt;span class="code"&gt;Fixnum&lt;/span&gt;.&lt;/li&gt;

  &lt;li&gt;For small &lt;span class="code"&gt;Bignum&lt;/span&gt;’s, Ruby saves memory and time
by storing the digits values right inside the &lt;span class="code"&gt;RBignum&lt;/span&gt; structure itself, using a
C &lt;i&gt;union&lt;/i&gt; trick. I don’t have time to explain that here today, but you can see
how the same optimization works for strings in my article &lt;a href="http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters"&gt;Never create Ruby strings longer than 23 characters&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Next time&lt;/h2&gt;

&lt;p&gt;In my next post I’ll look at how Ruby performs an actual mathematical operation
using &lt;span class="code"&gt;Bignum&lt;/span&gt; objects. It turns out there’s more to multiplication that you
might think: Ruby uses one of a few different multiplication algorithms
depending on how large the integers are, each with a different history behind
it. And Ruby 2.1 adds yet another new algorithm to the mix with GMP.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Three RubyConf Surprises</title>
    <link href="http://patshaughnessy.net/2013/12/4/three-rubyconf-surprises" rel="alternate"/>
    <id>http://patshaughnessy.net/2013/12/4/three-rubyconf-surprises</id>
    <published>2013-12-04T01:00:00Z</published>
    <updated>2013-12-04T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px"&gt;
   &lt;img src="http://patshaughnessy.net/assets/2013/11/26/heading-to-the-beach.png"/&gt;
&lt;/div&gt;




&lt;p&gt;This year &lt;a href="http://rubyconf.org"&gt;RubyConf&lt;/a&gt; was an inspiring, enthusiastic and fun experience. If you weren&amp;apos;t lucky enough to be able to attend in person, I would highly recommend taking a look at &lt;a href="http://rubyconf13.multifacete</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px"&gt;
   &lt;img src="http://patshaughnessy.net/assets/2013/11/26/heading-to-the-beach.png"/&gt;
&lt;/div&gt;




&lt;p&gt;This year &lt;a href="http://rubyconf.org"&gt;RubyConf&lt;/a&gt; was an inspiring, enthusiastic and fun experience. If you weren&amp;apos;t lucky enough to be able to attend in person, I would highly recommend taking a look at &lt;a href="http://rubyconf13.multifaceted.io"&gt;http://rubyconf13.multifaceted.io&lt;/a&gt;, a multimedia site about RubyConf put together by &lt;a href="http://www.ninefold.com"&gt;Ninefold&lt;/a&gt;, a Sydney Rails hosting firm. They collected an amazing set of speaker interviews, slides, talk summaries, and tweets from the conference. And just this week Confreaks has started posting the &lt;a href="http://www.confreaks.com/events/rubyconf2013"&gt;session videos online&lt;/a&gt;; there are many sessions I missed in person that I can’t wait to see.&lt;/p&gt;




&lt;p&gt;Today, however, I'd like to pass along a few tidbits of technical knowledge I learned during the conference that &lt;em&gt;surprised&lt;/em&gt; me. Aside from all the great people I met during hallway, dinner and lunch conversations, the surprising bits of knowledge are what stand out in my memory as I write this, three weeks after the conference ended.&lt;/p&gt;


&lt;p&gt;Read the full article on &lt;a href="http://www.sitepoint.com/three-rubyconf-surprises/"&gt;sitepoint.com&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Expanded Ruby Under a Microscope Available in Print!</title>
    <link href="http://patshaughnessy.net/2013/11/7/expanded-ruby-under-a-microscope-available-in-print" rel="alternate"/>
    <id>http://patshaughnessy.net/2013/11/7/expanded-ruby-under-a-microscope-available-in-print</id>
    <published>2013-11-07T01:00:00Z</published>
    <updated>2013-11-07T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 0px 30px 10px 0px; text-align: center; margin-top: 8px; margin-bottom: 9px"&gt;
  &lt;a href="http://nostarch.com/rum"&gt;&lt;img src="http://patshaughnessy.net/assets/2013/11/7/RUM_coverfront.png"&gt;&lt;br/&gt;&lt;i&gt;Order your copy today at NoStarch.com&lt;/a&gt;.&lt;br/&gt;
    Use coupon code LENS to get a 40% discount!&lt;/i&gt;&lt;/a&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;I’m happy to announce &lt;em&gt;Ruby Under a Microscope&lt;/em&gt;</summary>
    <content type="html">&lt;div style="float: left; padding: 0px 30px 10px 0px; text-align: center; margin-top: 8px; margin-bottom: 9px"&gt;
  &lt;a href="http://nostarch.com/rum"&gt;&lt;img src="http://patshaughnessy.net/assets/2013/11/7/RUM_coverfront.png"&gt;&lt;br/&gt;&lt;i&gt;Order your copy today at NoStarch.com&lt;/a&gt;.&lt;br/&gt;
    Use coupon code LENS to get a 40% discount!&lt;/i&gt;&lt;/a&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;I’m happy to announce &lt;em&gt;Ruby Under a Microscope&lt;/em&gt; is now available in print!&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ruby Under a Microscope&lt;/em&gt; gives you a hands-on look at Ruby’s core, using
extensive diagrams and thorough explanations to show you how Ruby is
implemented (no C skills required). I take a scientific approach, laying out a
series of experiments with Ruby code to take you behind the scenes of how
programming languages work. You’ll even find information on JRuby and Rubinius
(two alternative implementations of Ruby), as well as in-depth explorations of
Ruby’s garbage collection algorithm.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ruby Under a Microscope&lt;/em&gt; will teach you:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How a few computer science concepts underpin Ruby’s complex implementation&lt;/li&gt;
&lt;li&gt;How Ruby executes your code using a virtual machine&lt;/li&gt;
&lt;li&gt;How classes and modules are the same inside Ruby&lt;/li&gt;
&lt;li&gt;How Ruby employs algorithms originally developed for Lisp&lt;/li&gt;
&lt;li&gt;How Ruby uses grammar rules to parse and understand your code&lt;/li&gt;
&lt;li&gt;How your Ruby code is translated into a different language by a compiler.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;No programming language needs to be a black box. Whether you’re already
intrigued by language implementation or just want to dig deeper into Ruby,
you’ll find &lt;em&gt;Ruby Under a Microscope&lt;/em&gt; a fascinating way to become a better
programmer.&lt;/p&gt;

&lt;h2&gt;What’s New in the Expanded Book?&lt;/h2&gt;

&lt;p&gt;Professionally edited and produced, the expanded book covers important new
features introduced with Ruby 2.0: &lt;span class="code"&gt;Module#prepend&lt;/span&gt;,
keyword arguments, refinements and more. You’ll learn how to use them… and even
how Ruby 2.0 implements them internally! I also updated the text and diagrams
from my 2012 eBook to account for important changes to Ruby&amp;rsquo;s virtual machine
(YARV) made during 2.0 release, and added new chapters covering JRuby, Rubinius
and garbage collection.&lt;/p&gt;

&lt;p&gt;I had the honor of working with &lt;a href="https://twitter.com/tenderlove"&gt;Aaron “tenderlove”
Patterson&lt;/a&gt; on the project, who was the
technical reviewer.  Thanks to Aaron, the expanded book is both more accurate and
more interesting: Aaron had a number of great suggestions for new content which
I included as well.&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 10px 30px; text-align: center; margin-top: 20px"&gt;
  &lt;a href="http://nostarch.com/download/samples/RUM_CH6_excerpt.pdf"&gt;&lt;img src="http://patshaughnessy.net/assets/2013/11/7/ch6.png"&gt;&lt;br/&gt;&lt;i&gt;Download Chapter 6 as a free PDF&lt;/i&gt;&lt;/a&gt;.
&lt;/div&gt;


&lt;h2&gt;A 40% Discount&lt;/h2&gt;

&lt;p&gt;For the next seven days only, I’m offering a special discount: &lt;b&gt;Use coupon
  code “LENS” on &lt;a href="http://nostarch.com/rum"&gt;NoStarch.com&lt;/a&gt; to get a 40%
  discount.&lt;/b&gt; The LENS code will be valid for one week only, so be sure to
order your copy today! No Starch plans to start shipping the new books Monday,
Nov. 11th.&lt;/p&gt;

&lt;h2&gt;A Free Chapter Online&lt;/h2&gt;

&lt;p&gt;No Starch has posted Chapter 6, “Module Lookup and Constant Lookup,” as a &lt;a href="http://nostarch.com/download/samples/RUM_CH6_excerpt.pdf"&gt;free
online PDF&lt;/a&gt;. It
discusses how internally Ruby implements modules as classes, how Ruby finds
methods you call, and how Ruby uses lexical scope to find constants.&lt;/p&gt;

&lt;h2&gt;Expanded Table of Contents&lt;/h2&gt;

&lt;table id='toc'&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Foreword by Aaron Patterson&lt;/td&gt;
    &lt;td&gt;xv&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Acknowledgments&lt;/td&gt;
    &lt;td&gt;xvii&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Introduction&lt;/td&gt;
    &lt;td&gt;xix&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 1: Tokenization and Parsing&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 2: Compilation&lt;/td&gt;
    &lt;td&gt;31&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 3: How Ruby Executes Your Code&lt;/td&gt;
    &lt;td&gt;55&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 4: Control Structures and Method Dispatch&lt;/td&gt;
    &lt;td&gt;83&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 5: Objects and Classes&lt;/td&gt;
    &lt;td&gt;105&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;&lt;a href="http://nostarch.com/download/samples/RUM_CH6_excerpt.pdf"&gt;Chapter 6: Method Lookup and Constant Lookup&lt;/a&gt;&lt;/td&gt;
    &lt;td&gt;133&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 7: The Hash Table: The Workhorse of Ruby Internals&lt;/td&gt;
    &lt;td&gt;167&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 8: How Ruby Borrowed a Decades-Old Idea from Lisp&lt;/td&gt;
    &lt;td&gt;191&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 9: Metaprogramming&lt;/td&gt;
    &lt;td&gt;219&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 10: JRuby: Ruby on the JVM&lt;/td&gt;
    &lt;td&gt;251&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 11: Rubinius: Ruby Implemented with Ruby&lt;/td&gt;
    &lt;td&gt;273&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 12: Garbage Collection in MRI, JRuby, and Rubinius&lt;/td&gt;
    &lt;td&gt;295&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Index&lt;/td&gt;
    &lt;td&gt;327&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

</content>
  </entry>
  <entry>
    <title>Generational GC in Python and Ruby</title>
    <link href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby</id>
    <published>2013-10-30T00:00:00Z</published>
    <updated>2013-10-30T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 10px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/30/generations.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Both the Ruby and Python garbage collectors&lt;br/&gt;
  handle old and young objects differently.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a href="http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python"&gt;Last week I wrote u</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 10px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/30/generations.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Both the Ruby and Python garbage collectors&lt;br/&gt;
  handle old and young objects differently.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a href="http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python"&gt;Last week I wrote up the my first half of my notes&lt;/a&gt;
from a presentation I did at &lt;a href="http://13.rupy.eu"&gt;RuPy&lt;/a&gt; called “Visualizing
Garbage Collection in Ruby and Python.” I explained how standard Ruby (also
known as Matz’s Ruby Interpreter or MRI) uses a garbage collection (GC)
algorithm called &lt;em&gt;mark and sweep&lt;/em&gt;, the same basic algorithm developed for the
original version of Lisp in 1960. We also saw how Python uses a very different
GC algorithm also invented 53 years ago called &lt;em&gt;reference counting&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As it turns out, along with reference counting Python employs a second
algorithm called &lt;em&gt;generational garbage collection&lt;/em&gt;. This means Python’s garbage
collector handles newly created objects differently than older ones. And
starting with the upcoming version 2.1 release, MRI Ruby will also employ
generational GC for the first time. (Two alternative implementations of Ruby,
JRuby and Rubinius, have been using generational garbage collection for years.
I’ll talk about how garbage collection works inside of JRuby and Rubinius next
week at &lt;a href="http://rubyconf.org/program#pat-shaughnessy"&gt;RubyConf&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Of course, the phrase “handles new objects differently from older ones” is a
bit of hand-waving. What exactly are new and old objects? Exactly how do Ruby
and Python handle them differently? Today I’ll continue to describe how these
two garbage collectors work and answer these questions. But before we
get to generational GC, we first need to learn more about a serious theoretical
problem with Python’s reference counting algorithm.&lt;/p&gt;

&lt;h2&gt;Cyclic Data Structures and Reference Counting in Python&lt;/h2&gt;

&lt;p&gt;We saw last time that Python uses an integer value saved inside of each object,
known as the &lt;em&gt;reference count&lt;/em&gt;, to keep track of how many pointers reference that
object. Whenever a variable or other object in your program starts to refer to
an object, Python increments this counter; when your program stops using an
object, Python decrements the counter. Once the reference count becomes zero,
Python frees the object and reclaims its memory.&lt;/p&gt;

&lt;p&gt;Since the 1960s, computer scientists have been aware of a theoretical problem
with this algorithm: if one of your data structures refers to itself, if it is a
&lt;em&gt;cyclic data structure&lt;/em&gt;, some of the reference counts will never become zero. To
better understand this problem let’s take an example. The code below shows the
same &lt;span class="code"&gt;Node&lt;/span&gt; class we used last week:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/cycle1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;We have a constructor (these are called &lt;span class="code"&gt;__init__&lt;/span&gt; in Python) which saves a
single attribute in an instance variable. Below the class definition we create
two nodes, ABC and DEF, which I represent using the rectangles on the left. The
reference count inside both of our nodes is initially one, since one pointer
(&lt;span class="code"&gt;n1&lt;/span&gt; and &lt;span class="code"&gt;n2&lt;/span&gt;, respectively) refers to each node.&lt;/p&gt;

&lt;p&gt;Now let’s define two additional attributes in our nodes, &lt;span class="code"&gt;next&lt;/span&gt; and &lt;span class="code"&gt;prev&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/cycle2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Unlike in Ruby, using Python you can define instance variables or object
attributes on the fly like this. This seems like a bit of interesting magic
missing from Ruby. (Disclaimer: I’m not a Python developer so I might have some
of the nomenclature wrong here.) We set &lt;span class="code"&gt;n1.next&lt;/span&gt; to
reference &lt;span class="code"&gt;n2&lt;/span&gt;, and &lt;span class="code"&gt;n2.prev&lt;/span&gt;
to point back to &lt;span class="code"&gt;n1&lt;/span&gt;. Now our two nodes form a doubly
linked list using a circular pattern of pointers. Also notice that the
reference counts of both ABC and DEF have increased to two.  There are two
pointers referring to each node: &lt;span class="code"&gt;n1&lt;/span&gt; and &lt;span
  class="code"&gt;n2&lt;/span&gt; as before, and now &lt;span class="code"&gt;next&lt;/span&gt; and
&lt;span class="code"&gt;prev&lt;/span&gt; as well.&lt;/p&gt;

&lt;p&gt;Now let’s suppose our Python program stops using the nodes; we set both &lt;span
  class="code"&gt;n1&lt;/span&gt; and &lt;span class="code"&gt;n2&lt;/span&gt; to null. (In Python
null is known as &lt;span class="code"&gt;None&lt;/span&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/cycle3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now Python, as usual, decrements the reference count inside of each node down to 1.&lt;/p&gt;

&lt;h2&gt;Generation Zero in Python&lt;/h2&gt;

&lt;p&gt;Notice in the diagram just above we’ve ended up with an unusual situation: We
have an “island” or a group of unused objects that refer to each other, but
which have no external references. In other words, our program is no longer
using either node object, therefore we expect Python’s garbage collector to be
smart enough to free both objects and reclaim their memory for other purposes.
But this doesn’t happen because both reference counts are one and not zero.
Python’s reference counting algorithm can’t handle objects that refer to each
other!&lt;/p&gt;

&lt;p&gt;Of course, this is a contrived example, but your own programs might contain
circular references like this in subtle ways that you may not be aware of. In
fact, as your Python program runs over time it will build up a certain amount
of “floating garbage,” unused objects that the Python collector is unable to
process because the reference counts never reach zero.&lt;/p&gt;

&lt;p&gt;This is where Python’s generational algorithm comes in! Just as Ruby keeps
track of unused, free objects using a linked list (the &lt;em&gt;free list&lt;/em&gt;), Python uses a
different linked list to keep track of active objects. Instead of calling this
the “active list,” Python’s internal C code refers to it as &lt;em&gt;Generation Zero&lt;/em&gt;.
Each time you create an object or some other value in your program, Python adds
it to the Generation Zero linked list:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/python-gen1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see when we create the ABC node, Python adds it to Generation
Zero. Note that this isn’t an actual list that you see and access in your
program; this linked list is entirely internal to the Python runtime.&lt;/p&gt;

&lt;p&gt;Similarly, when we create the DEF node, Python adds it to the same linked list:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/python-gen2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now Generation Zero contains two node objects. (It will also contain every
other value our Python code creates, and many internal values used by Python
itself.)&lt;/p&gt;

&lt;h2&gt;Detecting Cyclic References&lt;/h2&gt;

&lt;p&gt;Later Python loops through the objects in the Generation Zero list and checks
which other objects each object in the list refers to, decrementing reference
counts as it goes. In this way, Python accounts for internal references from
one object to another that prevented Python from freeing the objects earlier.&lt;/p&gt;

&lt;p&gt;To make this a bit easier to understand, let’s take an example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/python-gen3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see the ABC and DEF nodes contain a reference count of 1. Three
other objects are in the Generation Zero linked list also. The blue arrows
indicate some of the objects are referred to by other objects that are located
elsewhere &amp;ndash; references from outside of Generation Zero. (As we’ll see in a
moment, Python also uses two other lists called Generation One and Generation
Two.) These objects have higher reference counts because of the other pointers
referring to them.&lt;/p&gt;

&lt;p&gt;Below you can see what happens after Python’s garbage collector processes
Generation Zero.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/python-gen4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;By identifying internal references, Python is able to reduce the reference
count of many of the Generation Zero objects. Above in the top row you can see
that ABC and DEF now have a reference count of zero. This means the collector
will free them and reclaim their memory. The remaining live objects are then
moved to a new linked list: Generation One.&lt;/p&gt;

&lt;p&gt;In a way, Python’s GC algorithm resembles the mark and sweep algorithm Ruby
uses. Periodically it traces references from one object to another to determine
which objects remain live, active objects our program is still using &amp;ndash; just
like Ruby’s marking process.&lt;/p&gt;

&lt;h2&gt;Garbage Collection Thresholds in Python&lt;/h2&gt;

&lt;p&gt;When does Python perform this marking process? As your Python program runs, the
interpreter keeps track of how many new objects it allocates, and how many
objects it frees because of zero reference counts. Theoretically, these two
values should remain the same: every new object your program creates should
eventually be freed.&lt;/p&gt;

&lt;p&gt;Of course, this isn’t the case. Because of circular references, and because
your program uses some objects longer than others, the difference between the
allocation count and the release count slowly grows. Once this delta value
reaches a certain threshold, Python’s collector is triggered and processes the
Generation Zero list using the subtract algorithm above, releasing the
“floating garbage” and moving the surviving objects to Generation One.&lt;/p&gt;

&lt;p&gt;Over time, objects that your Python program continues to use for a long time
are migrated from the Generation Zero list to Generation One. Python processes
the objects on the Generation One list in a similar way, after the
allocation-release count delta value reaches an even higher threshold value.
Python moves the remaining, active objects over to the Generation Two list.&lt;/p&gt;

&lt;p&gt;In this way, the objects that your Python program uses for long periods of
time, that your code keeps active references to, move from Generation Zero to
One to Two. Using different threshold values, Python processes these objects at
different intervals. Python processes objects in Generation Zero most
frequently, Generation One less frequently, and Generation Two even less often.&lt;/p&gt;

&lt;h2&gt;The Weak Generational Hypothesis&lt;/h2&gt;

&lt;p&gt;This behavior is the crux of the generational garbage collection algorithm: the
collector processes new objects more frequently than old objects. A new, or
&lt;em&gt;young&lt;/em&gt; object is one that your program has just created, while an old or &lt;em&gt;mature&lt;/em&gt;
object is one that has remained active for some period of time. Python &lt;em&gt;promotes&lt;/em&gt;
an object when it moves it from Generation Zero to One, or from One to Two.&lt;/p&gt;

&lt;p&gt;Why do this? The fundamental idea behind this algorithm is known as the &lt;em&gt;weak
generational hypothesis&lt;/em&gt;. The hypothesis actually consists of two ideas: that
most new objects die young, while older objects are likely to remain active for
a long time.&lt;/p&gt;

&lt;p&gt;Suppose I create a new object using Python or Ruby:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/weak-gen1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;According to the hypothesis, my code is likely to use the new ABC node only for a
short time.   The object is probably just an intermediate value used inside of
one method and will become garbage as soon as the method returns. Most new
objects will become garbage quickly in this way. Occasionally, however, my
program creates a few objects that remain important for a longer time &amp;ndash; such as
session variables or configuration values in a web application.&lt;/p&gt;

&lt;p&gt;By processing the new objects in Generation Zero more frequently, Python’s
garbage collector spends most of its time where it will benefit the most: it
processes the new objects which will quickly and frequently become garbage.
Only rarely, when the allocation threshold value increases, does Python’s
collector process the older objects.&lt;/p&gt;

&lt;h2&gt;Back to the Free List in Ruby&lt;/h2&gt;

&lt;p&gt;The upcoming release of Ruby, version 2.1, now uses a generational garbage
collector algorithm for the first time! (Remember, other implementations of
Ruby, such as JRuby and Rubinius, have been using this idea for years.) Let’s
return to the free list diagrams from &lt;a href="http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python"&gt;my last post&lt;/a&gt;
to understand how this works.&lt;/p&gt;

&lt;p&gt;Recall that when the free list is used up, Ruby marks the objects your program
is still using:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/ruby-gen1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In this diagram, we see there are three active objects because the pointers &lt;span class="code"&gt;n1&lt;/span&gt;,
&lt;span class="code"&gt;n2&lt;/span&gt; and &lt;span class="code"&gt;n3&lt;/span&gt; still refer to
them. The remaining objects, the white squares, are garbage. (Of course, the
free list will actually contain thousands of objects that refer to each other
in complex patterns. My simple diagrams help me communicate the basic ideas
behind Ruby’s GC algorithm without getting bogged down in the details.)&lt;/p&gt;

&lt;p&gt;Also recall that Ruby moves the garbage objects back onto the free list,
because now they can be recycled and reused by your program when it allocates new
objects:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/ruby-gen2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Generational GC in Ruby 2.1&lt;/h2&gt;

&lt;p&gt;Starting with Ruby 2.1, the GC code takes an additional step: it promotes the
remaining active objects to the &lt;em&gt;mature generation&lt;/em&gt;. (The MRI C source code
actually uses the word &lt;em&gt;old&lt;/em&gt; and not &lt;em&gt;mature&lt;/em&gt;.) This diagram shows a conceptual
view of the two Ruby 2.1 object generations:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/ruby-gen3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left is a different view of the free list. We see the garbage objects in
white, and the remaining live, active objects in gray. The gray objects were
just marked.&lt;/p&gt;

&lt;p&gt;Once the mark and sweep process is finished, Ruby 2.1 will consider the
remaining marked objects to be mature:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/ruby-gen4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Instead of using three generations like Python, Ruby 2.1’s garbage collector
uses just two. On the left are new objects in the young generation, and on the
right are old objects in the mature generation. Once Ruby 2.1 has marked an
object once, it considers it to be mature. Ruby bets the object has remained
active for a long enough time that it will not become garbage quickly.&lt;/p&gt;

&lt;p&gt;Important note: Ruby 2.1 doesn’t actually copy objects around in memory. These
generations don’t consist of different areas of physical memory. (Some GC
algorithms used by other languages and other Ruby implementations, known as
&lt;em&gt;copying garbage collectors&lt;/em&gt;, do actually copy objects when they are promoted.)
Instead, Ruby 2.1 uses code internally that doesn’t include previously marked
objects in the mark and sweep process again. Once an object has been marked
once it won’t be included in the next mark and sweep process.&lt;/p&gt;

&lt;p&gt;Now suppose your Ruby program continues to run, creating more new, young
objects. These appear in the young generation again, on the left:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/ruby-gen5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Just like Python, Ruby’s collector focuses its efforts on the young generation.
It only includes the new, young objects created since the last GC process
occurred in the mark and sweep algorithm. This is because many new objects are
likely to be garbage already (the white boxes on the left). Ruby doesn’t
re-mark the mature objects on the right. Because they already survived one GC
process, they are likely to remain active and not become garbage for a longer
time. By only marking young objects, Ruby’s GC code runs much faster. It just
skips over the mature objects entirely, reducing the amount of time your
program is waiting for garbage collection to finish.&lt;/p&gt;

&lt;p&gt;Occasionally Ruby runs a “full collection,” re-marking and re-sweeping the
mature objects as well. Ruby decides when to run a full collection by
monitoring the number of mature objects. When the number of mature objects has
doubled since the last full collection, Ruby clears the marks and considers all
the objects to be young again.&lt;/p&gt;

&lt;h2&gt;Write Barriers&lt;/h2&gt;

&lt;p&gt;One important challenge to this algorithm is worth further explanation. Suppose
your code creates a new, young object and adds it as a child of an existing,
mature object. For example, this would happen if you added a new value to an
array that had existed for a long time.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/30/ruby-gen6.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here again on the left we see new, young objects and mature objects on the
right. On the left side the marking process has identified that 5 new objects
are still active (gray), while two new objects are garbage (white). But what
about the new, young object in the center? This is the one shown in white with
a question mark. Is this new object garbage or active?&lt;/p&gt;

&lt;p&gt;It’s active, of course, because there’s a reference to it from a mature object
on the right. But  remember Ruby 2.1 doesn’t include mature objects in mark and
sweep (until a full collection occurs). This means the new object will be
incorrectly considered garbage and released, causing your program to lose data!&lt;/p&gt;

&lt;p&gt;Ruby 2.1 overcomes this challenge by monitoring the mature objects to see if
your program adds a reference from them to a new, young object. Ruby 2.1 uses
an old GC technique called &lt;em&gt;write barriers&lt;/em&gt; to monitor changes to mature
objects &amp;ndash; whenever you add a reference from one object to another (whenever you
write to or modify an object), a write barrier is triggered.  The barriers
check whether the source object is mature, and if so adds the mature object to
a special list. Later Ruby 2.1 includes these just these modified mature
objects in the next mark and sweep process, preventing active, young objects
from being incorrectly considered garbage.&lt;/p&gt;

&lt;p&gt;Ruby 2.1’s actual implementation of write barriers is quite complex, primarily
because existing C extensions don’t contain them. Koichi Sasada and the Ruby
core team used a number of clever solutions to overcome this challenge as well.
To learn more about these technical details, watch &lt;a href="http://www.ustream.tv/recorded/35107339/highlight/377033"&gt;Koichi’s fascinating
presentation&lt;/a&gt; from &lt;a href="http://euruko2013.org"&gt;EuRuKo 2013&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Standing on the Shoulders of Giants&lt;/h2&gt;

&lt;p&gt;At first glance, Ruby and Python seem to implement garbage collection very
differently. Ruby uses John McCarthy’s original mark and sweep algorithm, while
Python uses reference counting. But when we look more closely, we see that
Python uses bits of the mark and sweep idea to handle cyclic references, and
that both Ruby and Python use generational garbage collection in similar ways.
Python uses three separate generations, while Ruby 2.1 uses two.&lt;/p&gt;

&lt;p&gt;This similarity should not be a surprise. Both languages are using computer
science research that was done decades ago &amp;ndash; before either Ruby or Python were
even invented. I find it fascinating that when you look “under the hood” at
different programming languages, you often find the same fundamental ideas and
algorithms are used by all of them. Modern programming languages owe a great
deal to the ground breaking computer science research that John McCarthy and
his contemporaries did back in the 1960s and 1970s.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Visualizing Garbage Collection in Ruby and Python</title>
    <link href="http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python" rel="alternate"/>
    <id>http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python</id>
    <published>2013-10-24T00:00:00Z</published>
    <updated>2013-10-24T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;p&gt;&lt;b&gt;
  &lt;p&gt;
  Note: This post is based on a presentation I just did at &lt;a href="http://13.rupy.eu"&gt;RuPy&lt;/a&gt; in Budapest.
  Instead of just posting my slides I thought it would be more useful if I wrote
  it down as a blog post while it’s still fresh in my mind. I’ll post the video
  link here when the RuPy folks have it online.  FYI I’m planning to do a &lt;a href="http://rubyconf.org/program#pat-sha</summary>
    <content type="html">&lt;p&gt;&lt;b&gt;
  &lt;p&gt;
  Note: This post is based on a presentation I just did at &lt;a href="http://13.rupy.eu"&gt;RuPy&lt;/a&gt; in Budapest.
  Instead of just posting my slides I thought it would be more useful if I wrote
  it down as a blog post while it’s still fresh in my mind. I’ll post the video
  link here when the RuPy folks have it online.  FYI I’m planning to do a &lt;a href="http://rubyconf.org/program#pat-shaughnessy"&gt;similar presentation at RubyConf&lt;/a&gt;,
  except I’ll remove the Python info, and instead compare how
  GC works inside of MRI vs.  JRuby and Rubinius.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;  &lt;p&gt;
  For a more detailed explanation of GC in Ruby and of Ruby internals generally,
  see my upcoming book, &lt;a href="http://nostarch.com/rum"&gt;Ruby Under a Microscope&lt;/a&gt;,
  due out very soon from No Starch Press.&lt;/p&gt; &lt;/b&gt;&lt;/p&gt;

&lt;div style="float: left; padding: 7px 30px 10px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/24/circuitory-system-polish.png"&gt;&lt;br/&gt;
  &lt;i&gt;If your algorithms and business logic are the brain of your&lt;br/&gt;
  application, which organ would the garbage collector be?&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Since this is the “Ruby Python” conference, I thought it would be fun to
compare how garbage collection works inside of Ruby and Python. But before we
get to that, why talk about garbage collection at all? After all, it’s not the
most glamorous, exciting topic, is it? How many of you get excited by
garbage collection? [ A number of RuPy attendees actually raised their hands! ]&lt;/p&gt;

&lt;p&gt;Recently in the Ruby community there was a &lt;a href="http://fredwu.me/post/60441991350/protip-ruby-devs-please-tweak-your-gc-settings-for"&gt;blog
post&lt;/a&gt;
about how you can speed up your unit tests by changing your Ruby GC settings. I
think that’s great. It’s good to run your tests faster and to run your app with
fewer GC pauses, but somehow GC doesn’t really &lt;em&gt;excite&lt;/em&gt; me. It seems like a
boring, dry, technical topic at first glance.&lt;/p&gt;

&lt;p&gt;But actually, garbage collection is a fascinating topic: GC algorithms are both
an important part of computer science history, and a subject of cutting edge
research. For example, the Mark and Sweep algorithm used by MRI Ruby is over 50
years old, while one of the GC algorithms used inside of Rubinius, an
alternative implementation of Ruby, was invented just recently in 2008.&lt;/p&gt;

&lt;p&gt;However, the name “garbage collection,” is actually misnomer.&lt;/p&gt;

&lt;h2&gt;The Beating Heart of Your Application&lt;/h2&gt;

&lt;p&gt;GC systems do much more than just “collect garbage.” In fact, they perform
three important tasks. They&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;allocate memory for new objects,&lt;/li&gt;
&lt;li&gt;identify garbage objects, and&lt;/li&gt;
&lt;li&gt;reclaim memory from garbage objects.&lt;/li&gt;
&lt;/ul&gt;


&lt;div style="float: right; padding: 7px 0px 10px 30px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/24/heart-polish.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Imagine if your application was a human body: All of the elegant code you
write, your business logic, your algorithms, would be the brain or the
intelligence inside the application. Following this analogy, what part of the
body do you think the garbage collector would be? [ I got lots of fun answers from the RuPy audience: kidneys, white blood cells :) ]&lt;/p&gt;

&lt;p&gt;I think the garbage collector is the beating heart of your application. Just as
your heart provides blood and nutrients to the rest of the your body, the
garbage collector provides memory and objects for your application to use. If
your heart stopped beating you would die in seconds. If the garbage collector
stopped or ran slowly &amp;ndash; if it had clogged arteries &amp;ndash; your
application would slow down and eventually die!&lt;/p&gt;

&lt;h2&gt;A Simple Example&lt;/h2&gt;

&lt;p&gt;It’s always helpful to work through theories using examples. Here’s a simple
class, written in both Python and Ruby, that we can use as an example today:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/code.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;By the way, it’s amazing to me how similar this code is in both languages: Ruby
and Python are really just slightly different ways of saying the same thing.
But are the languages also &lt;em&gt;implemented&lt;/em&gt; in a similar way internally?&lt;/p&gt;

&lt;h2&gt;The Free List&lt;/h2&gt;

&lt;p&gt;When we call &lt;span class="code"&gt;Node.new(1)&lt;/span&gt; above, what does Ruby do,
exactly? How does Ruby go about creating a new object for us?&lt;/p&gt;

&lt;p&gt;Surprisingly, it does very little! In fact, long before your code starts to
run, Ruby creates thousands of objects ahead of time and places them on a linked
list, called the &lt;em&gt;free list&lt;/em&gt;. Here’s what the free list might look like,
conceptually:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/free-list1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Imagine each of the white squares above is an unused, precreated Ruby object.
When we call &lt;span class="code"&gt;Node.new&lt;/span&gt;, Ruby simply takes one of these objects and hands it to
us:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/free-list2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In the diagram above, the gray square on the left represents an active Ruby
object we’re using in our code, while the remaining white squares are unused
objects. [ Note: of course, my diagrams are a simplified version of reality. In
fact, Ruby would use another object to hold the string “ABC,” a third object to
hold the class definition of Node, and still other objects to hold the parsed,
abstract syntax tree (AST) representation of my code, etc. ]&lt;/p&gt;

&lt;p&gt;If we call &lt;span class="code"&gt;Node.new&lt;/span&gt; again, Ruby just hands
us another object:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/free-list3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 10px 30px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/24/mccarthy.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;John McCarthy’s 1960 implementation of Lisp contained&lt;br/&gt;the first garbage collector.&lt;/i&gt;
  &lt;i&gt;(Courtesy MIT Museum)&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;This simple algorithm of using a linked list of precreated objects was
invented over 50 years ago by a legendary computer scientist named John
McCarthy, while he was working on the original implementation of Lisp. Lisp was
not only one of the first functional programming languages, but also contained
a number of other groundbreaking advances in computer science. One of these was
the concept of automatically managing your application’s memory using garbage
collection.&lt;/p&gt;

&lt;p&gt;The standard version of Ruby, also known as “Matz’s Ruby Interpreter” (MRI),
uses a GC algorithm similar to the one used by McCarthy’s implementation
of Lisp in 1960. For better or worse, Ruby uses a 53 year old algorithm for
garbage collection. Just as Lisp did, Ruby creates objects ahead of time and
hands them to your code when you allocate new objects or values.&lt;/p&gt;

&lt;h2&gt;Allocating Objects in Python&lt;/h2&gt;

&lt;p&gt;We’ve seen that Ruby creates objects ahead of time and saves them in the free
list. What about Python?&lt;/p&gt;

&lt;p&gt;While Python also uses free lists for various reasons internally (it recycles
certain objects such as lists), it normally allocates memory for new objects
and values differently than Ruby does.&lt;/p&gt;

&lt;p&gt;Suppose we create a Node object using Python:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Python, unlike Ruby, will ask the operating system for memory immediately when
you create the object. (Python actually implements its own memory allocation
system which provides an additional layer of abstraction on top of the OS heap.
But I don’t have time to get into those details today.)&lt;/p&gt;

&lt;p&gt;When we create a second object, Python will again ask the OS for more memory:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 10px 30px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/24/mess.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Ruby leaves unused objects lying around in&lt;br/&gt;memory until the next GC process runs.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Seems simple enough; at the moment we create an object Python takes the time to
find and allocate memory for us.&lt;/p&gt;

&lt;h2&gt;Ruby Developers Live in a Messy House&lt;/h2&gt;

&lt;p&gt;Back to Ruby. As we allocate more and more objects, Ruby will continue to hand
us precreated objects from the free list. As it does this, the free list will
become shorter:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/free-list4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip;and shorter:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/free-list5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Notice as I continue to assign new values to &lt;span class="code"&gt;n1&lt;/span&gt;, Ruby
leaves the old values behind. The ABC, JKL and MNO nodes remain in memory. Ruby
doesn’t immediately clean up old objects my code is no longer using! Working as
a Ruby developer is like living in a messy house, with clothes lying on the
floor or dirty dishes in the kitchen sink. As a Ruby developer you have to work
with unused, garbage objects surrounding you.&lt;/p&gt;

&lt;div style="clear: right"&gt;&lt;/div&gt;


&lt;h2&gt;Python Developers Live in a Tidy Household&lt;/h2&gt;

&lt;div style="float: right; padding: 7px 0px 10px 30px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2013/10/24/clean.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Python cleans up garbage objects immediately &lt;br/&gt;
    after your code is done using them.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Garbage collection works quite differently in Python than in Ruby. Let’s return
to our three Python Node objects from earlier:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python3b.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Internally, whenever we create an object Python saves an integer inside the
object’s C structure, called the &lt;em&gt;reference count&lt;/em&gt;. Initially, Python sets this
value to 1:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The value of 1 indicates there is one pointer or reference to each of the three
objects. Now suppose we create a new node, JKL:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Just as before, Python sets the reference count in JKL to be 1. However, also
notice since we changed &lt;span class="code"&gt;n1&lt;/span&gt; to point to JKL, it no
longer references ABC, and that Python decremented its reference count down to
0.&lt;/p&gt;

&lt;p&gt;At this point, the Python garbage collector immediately jumps into action! Whenever an
object’s reference count reaches zero, Python immediately frees it, returning
it’s memory to the operating system:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python6.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above Python reclaims the memory used by the ABC node. Remember, Ruby simply
leaves old objects lying around and doesn’t release their memory.&lt;/p&gt;

&lt;p&gt;This garbage collection algorithm is known as &lt;em&gt;reference counting&lt;/em&gt;. It was
invented by George Collins in 1960 &amp;ndash; not coincidentally the same year John
McCarthy invented the free list algorithm. As &lt;a href="https://twitter.com/mrb_bk"&gt;Mike Bernstein&lt;/a&gt; said in his
fantastic &lt;a href="http://www.confreaks.com/videos/2545-goruco2013-to-know-a-garbage-collector"&gt;presentation on garbage collection&lt;/a&gt;
at the &lt;a href="http://goruco.com"&gt;Gotham Ruby Conference&lt;/a&gt; back in June: &lt;i&gt;“1960 was a good year for Garbage Collectors&amp;hellip;.”&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Working as a Python developer is like living in a tidy house; you know, the
kind of place where your roommates are a bit OCD and are constantly cleaning up
after you. As soon as you put down a dirty dish or glass, someone has already
put it away in the dishwasher!&lt;/p&gt;

&lt;p&gt;Now for a second example. Suppose we set &lt;span class="code"&gt;n2&lt;/span&gt; to refer
to the same node as &lt;span class="code"&gt;n1&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/python8.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above to the left you can see Python has decremented the reference count for
DEF and will immediately garbage collect the DEF node. Also note that the JKL
now has a reference count of 2, since both &lt;span class="code"&gt;n1&lt;/span&gt; and
&lt;span class="code"&gt;n2&lt;/span&gt; point to it.&lt;/p&gt;

&lt;h2&gt;Mark and Sweep&lt;/h2&gt;

&lt;p&gt;Eventually a messy house fills up with trash and life can’t continue as usual.
After your Ruby program runs for some time, the free list will eventually be
entirely used up:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/mark-and-sweep1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here all of the precreated Ruby objects have been used by our application
(they are all gray) and no objects remain on the free list (no white squares
are left).&lt;/p&gt;

&lt;p&gt;At this point Ruby uses another algorithm invented by McCarthy known as &lt;em&gt;Mark
and Sweep&lt;/em&gt;. First Ruby stops your application; Ruby uses “stop the world garbage
collection.” Ruby then loops through all of the pointers, variables and other
references our code makes to objects and other values. Ruby also iterates over
internal pointers used by its virtual machine. It &lt;em&gt;marks&lt;/em&gt; each object that
it is able to reach using these pointers. I indicate these marks using the letter M
here:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/mark-and-sweep2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above the three objects marked with “M” are live, active objects that our
application is still using. Internally, Ruby actually uses a series of bits
known as the &lt;em&gt;free bitmap&lt;/em&gt; to keep track of which objects are marked or not:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/mark-and-sweep3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Ruby saves the free bitmap in a separate memory location in order to take full
advantage of Unix copy-on-write optimization. For more information on this, see
my article &lt;a
  href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0"&gt;Why
  You Should Be Excited About Garbage Collection in Ruby 2.0.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If the marked objects are live, the remaining, unmarked objects must be garbage,
meaning they are no longer being used by our code. I’ll show the garbage objects
as white squares below:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/mark-and-sweep4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Next Ruby &lt;em&gt;sweeps&lt;/em&gt; the unused, garbage objects back onto the free list:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2013/10/24/mark-and-sweep5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Internally this happens quite quickly, since Ruby doesn’t actually copy objects
around from one place to another. Instead, Ruby places the garbage objects back
onto the free list by adjusting internal pointers to form a new linked list.&lt;/p&gt;

&lt;p&gt;Now Ruby can give these garbage objects back to us the next time we create a
new Ruby object. In Ruby, objects are reincarnated, and enjoy multiple lives!&lt;/p&gt;

&lt;h2&gt;Mark and Sweep vs. Reference Counting&lt;/h2&gt;

&lt;p&gt;At first glance, Python’s GC algorithm seems far superior to Ruby’s: why live
in a messy house when you can live in a tidy one? Why does Ruby force your
application to stop running periodically each time it cleans up, instead of
using Python’s algorithm?&lt;/p&gt;

&lt;p&gt;Reference counting isn’t as simple as it seems at first glance, however. There
are a number of reasons why many languages don’t use a reference counting GC
algorithm like Python does:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First, it’s difficult to implement. Python has to leave room inside of each
object to hold the reference count. There’s a minor space penalty for this. But
worse, a simple operation such a changing a variable or reference becomes a
more complex operation since Python needs to increment one counter, decrement
another, and possibly free the object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Second, it can be slower. Although Python performs GC work smoothly
as your application runs (cleaning dirty dishes as soon as you put them in the
sink), this isn’t necessarily faster. Python is constantly updating the
reference count values. And when you stop using a large data structure, such as
a list containing many elements, Python might have to free many objects all at
once. Decrementing reference counts can be a complex, recursive process.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, it doesn’t always work. As we’ll see in my next post containing my
notes from the rest of this presentation, reference counting can’t handle
&lt;em&gt;cyclic data structures&lt;/em&gt; &amp;ndash; data structures that contain circular references.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Until Next Time&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Next week I’ll type up &lt;a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby"&gt;the rest of the presentation&lt;/a&gt;. I’ll discuss how Python
handles cyclic data structures, and how GC works in the upcoming Ruby 2.1 release.&lt;/p&gt;
</content>
  </entry>
</feed>

<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pat Shaughnessy</title>
  <id>http://patshaughnessy.net</id>
  <updated>2008-09-03T00:00:00Z</updated>
  <author>
    <name></name>
  </author>
  <entry>
    <title>What Do Perl and Go Have in Common?</title>
    <link href="http://patshaughnessy.net/2015/9/25/what-do-perl-and-go-have-in-common" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/9/25/what-do-perl-and-go-have-in-common</id>
    <published>2015-09-25T00:00:00Z</published>
    <updated>2015-09-25T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;TL/DR:&lt;/strong&gt; &lt;em&gt;Both Perl and Go only partially implement object oriented
programming, in a confusing way. Using either language you can create
structures equivalent to objects but without using keywords such as &lt;span
class="code"&gt;class&lt;/span&gt; or &lt;span class="code"&gt;new&lt;/span&gt;.  Converting a Go
function into a method by adding a receiver reminds me of &amp;ldquo;blessing&amp;rdquo; a Perl has</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;TL/DR:&lt;/strong&gt; &lt;em&gt;Both Perl and Go only partially implement object oriented
programming, in a confusing way. Using either language you can create
structures equivalent to objects but without using keywords such as &lt;span
class="code"&gt;class&lt;/span&gt; or &lt;span class="code"&gt;new&lt;/span&gt;.  Converting a Go
function into a method by adding a receiver reminds me of &amp;ldquo;blessing&amp;rdquo; a Perl hash
reference.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It’s hard to imagine two programming languages that are more different. Larry
Wall created Perl  almost 30 years ago in 1987. Google introduced Go much more
recently in 2009. Perl is a dynamic, interpreted language while Go uses a
compiler and static types. Perl syntax is quirky, fun and sometimes bizarre,
while Go syntax is clean and simple, almost boring at times.&lt;/p&gt;

&lt;p&gt;This year, coincidentally, I tried to learn both Perl and Go around the same
time. Oddly, I found something in common between these two dramatically
different languages. They both allow you to create objects and to write
methods, but without supporting &lt;span class="code"&gt;class&lt;/span&gt;, &lt;span
class="code"&gt;new&lt;/span&gt; or other keywords found in traditional object oriented
languages like Smalltalk, Java, Ruby or Python.  Both languages leave the door
partially open to object oriented design, but don’t provide the syntax or
features you expect and need for using objects and classes.&lt;/p&gt;

&lt;h2&gt;Writing a Perl Function&lt;/h2&gt;

&lt;p&gt;Let’s suppose I want to calculate the density of Jupiter, based on its mass and
diameter. Using Perl, I could write:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl1.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 25px 8px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/9/25/vw.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;
  Writing Perl feels like riding a vintage VW bus. Things don’t&lt;br/&gt;
  work the way you expect, but you can always feel the love.
&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;As you can see, Perl’s syntax is somewhat odd: The &lt;span class="code"&gt;my&lt;/span&gt;
keyword indicates each variable belongs to the local lexical scope. The &lt;span
class="code"&gt;shift&lt;/span&gt; keywords pull the mass and radius values from an
array of values Perl implicitly passes to every function &amp;ndash; Perl functions
always take a single array argument! And you have to prefix all of the
identifiers with either a &lt;span class="code"&gt;$,&lt;/span&gt; &lt;span
class="code"&gt;@&lt;/span&gt; or &lt;span class="code"&gt;%&lt;/span&gt; character to indicate
whether it is a scalar (simple value), an array or a hash. Sometimes in more
complex Perl code you have to combine these prefixes together in cryptic
patterns, such as &lt;span class="code"&gt;@$var&lt;/span&gt;, or &lt;span
class="code"&gt;%$var&lt;/span&gt;. Thankfully in this simple function I just use
numeric values, so &lt;span class="code"&gt;$&lt;/span&gt; is sufficient.&lt;/p&gt;

&lt;p&gt;To me, Perl feels like an old-fashioned, awkward version of Ruby. And this
makes some sense. Perl was to some extent the model for both Ruby and Python,
which were created just a few years after Perl in the early 1990s. Ruby and
Python smoothed out the rough edges of Perl’s syntax (along with adding proper
support for objects among other things).&lt;/p&gt;

&lt;h2&gt;Creating a Perl Object&lt;/h2&gt;

&lt;p&gt;Now I decide to use an object oriented style instead. I want a Jupiter object
which has mass and radius attributes, and I’d like the density function to be a
method, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl2.png"/&gt;&lt;/p&gt;

&lt;p&gt;In other words, I’d like to think of &lt;span class="code"&gt;$jupiter&lt;/span&gt; as an
instance of the Planet class.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/jupiter-class.png"/&gt;&lt;/p&gt;

&lt;p&gt;By writing a &lt;span class="code"&gt;Planet&lt;/span&gt; class, I group together data
values that describe each planet (mass and radius) with the functions that use
those values (density).  Object oriented languages refer to the data values as
&lt;em&gt;instance variables&lt;/em&gt;, and the functions as &lt;em&gt;methods&lt;/em&gt;. By creating a class, I now
have a natural place to gather functions and attributes related to planets.&lt;/p&gt;

&lt;p&gt;The problem is that Perl isn’t an object oriented language. There’s no way to
declare a class, define methods or create objects which are instances of that
class. However, a few years after Perl was invented, in the mid 1990s, Larry
Wall and the Perl team introduced some support for object oriented programming
concepts in Perl 5. They converted Perl into an object oriented language after
the fact &amp;ndash; at least a partially object oriented language.&lt;/p&gt;

&lt;p&gt;To create a Perl class, I first group my planet functions together using the Perl &lt;span class="code"&gt;package&lt;/span&gt; keyword. In this example I have only one:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl3.png"/&gt;&lt;/p&gt;

&lt;p&gt;This gives me a place to put all of the methods of the &lt;span
class="code"&gt;Planet&lt;/span&gt; class &amp;ndash; the &lt;span class="code"&gt;package&lt;/span&gt;
keyword plays the same role the &lt;span class="code"&gt;class&lt;/span&gt; keyword would
in Java or Ruby, to some extent. Also notice that I’ve rewritten my function to
use object oriented syntax.  Instead of obtaining the mass and radius from the
parameters array, I get a single parameter which I call &lt;span
class="code"&gt;$self&lt;/span&gt;. Then I use &lt;span class="code"&gt;$self&lt;/span&gt; as a hash
reference to get the mass and radius values, for example: &lt;span
class="code"&gt;$self-&gt;{&amp;lsquo;mass&amp;rsquo;}&lt;/span&gt;. This is object oriented code. I’ve created
a class and added a method to it.&lt;/p&gt;

&lt;p&gt;However, let’s think about this for another moment:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice there’s a difference between what I want to say, and the words I have to
use to say it. The Perl language doesn’t include the &lt;span
class="code"&gt;class&lt;/span&gt; keyword; instead, I need to use &lt;span
class="code"&gt;package&lt;/span&gt;. We’ll see this again in a moment.&lt;/p&gt;

&lt;p&gt;To create an instance of my new &lt;span class="code"&gt;Planet&lt;/span&gt; class, an
object, I need to create a hash (technically a reference to a hash) and then
“bless” it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl4.png"/&gt;&lt;/p&gt;

&lt;p&gt;This creates a connection between the hash (the object) and the package that
contains the methods I want to use (the class). Now I can use syntax such as
&lt;span class="code"&gt;$jupiter-&gt;density()&lt;/span&gt;. I’ve done it! I’ve created an object using Perl.&lt;/p&gt;

&lt;p&gt;However, once again the language doesn’t supply the words I want to use to
express the idea I’m thinking of:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words2.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Expressing Object Oriented Concepts Using Perl&lt;/h2&gt;

&lt;p&gt;Here’s the complete, object oriented version of my example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/perl5.png"/&gt;&lt;/p&gt;

&lt;p&gt;To me, the Perl code I wrote above seems very confusing. But it’s not Perl’s
strange, old-fashioned syntax that confuses me. After a while, all the &lt;span
class="code"&gt;$&lt;/span&gt; symbols and the use of &lt;span class="code"&gt;shift&lt;/span&gt;
start to make sense. Writing Perl code is a bit like writing Ruby code while on
drugs &amp;ndash; I start with Ruby and just keep adding &lt;span class="code"&gt;$&lt;/span&gt; and
semicolon characters until it works.&lt;/p&gt;

&lt;p&gt;The real problem in this example is that Perl allows me to create objects and
classes, but doesn’t refer to them as objects or classes. Instead, I have
“blessed references” and “packages.” Perl allows me to get the object oriented
behavior I want, but doesn’t let me use the words I want to use to describe
what I’m doing. Perl’s partial support of object oriented programming is
confusing at best.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: Perl 6, under development for the last fifteen years and still not
released, is planning to introduce more explicit support for objects using the
&lt;span class="code"&gt;class&lt;/span&gt; and &lt;span class="code"&gt;new&lt;/span&gt; keywords.&lt;/em&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 25px 8px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/9/25/driverless-car.png"&gt;&lt;br/&gt;
  &lt;i&gt;
Writing Go code feels like riding in a Google driverless car:&lt;br/&gt;
the compiler and &lt;span class="code"&gt;gofmt&lt;/span&gt; tool are in complete control.
  &lt;/i&gt;
&lt;/div&gt;


&lt;h2&gt;Creating a Go Object&lt;/h2&gt;

&lt;p&gt;Perl was invented many years ago. Now let’s try using a modern, new programming
language to write the same example: Go. Along the way I’ll compare the Go
version with the Perl code I wrote above.&lt;/p&gt;

&lt;p&gt;Earlier using Perl I had to use the &lt;span class="code"&gt;package&lt;/span&gt; keyword
to define a place to put my class’s methods. In Go, I define a group of
methods in a different way: by associating them with a type. Therefore, I’ll
start my Go code by creating a &lt;span class="code"&gt;Planet&lt;/span&gt; type:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/go1.png"/&gt;&lt;/p&gt;

&lt;p&gt;The two versions look very different. In Go I define a static type that always
consists of mass and radius values, while in Perl I dynamically create a hash
that might contain any values.&lt;/p&gt;

&lt;p&gt;Once again, however, I’m forced to think about my code one way and write it
another:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words3.png"/&gt;&lt;/p&gt;

&lt;p&gt;What Go and Perl really have in common is this: Neither language contains the
words and syntax I really would like to use to express the object oriented
concepts I’m trying to use.&lt;/p&gt;

&lt;p&gt;So far I’ve created a type, a static collection of values. Let’s take the next
step and convert that into a class:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/go2.png"/&gt;&lt;/p&gt;

&lt;p&gt;In Go I don’t need to connect my instance data with the class; the mass and
radius values are already contained inside the &lt;span class="code"&gt;Planet&lt;/span&gt;
struct type. Instead, I need to create a connection between the method and the
class. I do this by typing in a receiver for the Density function, &lt;span
class="code"&gt;func (p Planet) Density()&lt;/span&gt;, converting it into a method of
the Planet type.&lt;/p&gt;

&lt;p&gt;In Perl I “bless” a hash by connecting it to a group of functions in a package.
A blessed hash is an object in Perl. In Go I “bless” a function by connecting
it to a type containing instance data. A blessed function combined with a type
is a class in Go. The two languages both use special syntax tricks to allow for
object oriented programming, but they make the connection between instance
variables and methods from opposite directions.&lt;/p&gt;

&lt;p&gt;Once again, however, there’s an impedance mismatch between the concepts I’m
imagining and the words I have to use to to express them:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/words4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Go doesn’t provide me with the vocabulary I want to use. I want to type &lt;span
class="code"&gt;class&lt;/span&gt;, but Go only allows me to use &lt;span class="code"&gt;type
struct&lt;/span&gt;. And because there’s no &lt;span class="code"&gt;class&lt;/span&gt; keyword,
my blessed function, my method, could be anywhere and not necessary right next
to my type definition.&lt;/p&gt;

&lt;h2&gt;Expressing Object Oriented Concepts Using Go&lt;/h2&gt;

&lt;p&gt;Here’s the complete, object oriented version of my example in Go:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/9/25/go3.png"/&gt;&lt;/p&gt;

&lt;p&gt;I find this Go code just as confusing and misleading as the Perl version above,
and for the same reason. Both Perl and Go take the first step towards object
oriented programming, but stop short of providing a complete solution. Instead
of objects, Go gives us C-style static structures which can have methods
associated with them. And Go doesn’t provide classes at all: There’s no natural
place to gather all of the methods belonging to a given type.&lt;/p&gt;

&lt;p&gt;We can guess that Perl 5 didn’t introduce proper support for object oriented
programming either because it was too difficult to add it to an existing
language, or for backward compatibility reasons. But the &lt;a href="http://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html"&gt;designers of Go
decided from the very
beginning&lt;/a&gt;
not to support classes or objects. Then, why support methods at all? Why allow
developers to create object-like structures, but with a confusing syntax? Or
why not go all the way and introduce the &lt;span class="code"&gt;class&lt;/span&gt;
keyword to properly support object structures?&lt;/p&gt;

&lt;div style="float: right; padding: 25px 8px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/9/25/jupiter.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;
The density of Jupiter is 1,326 kg/m&lt;sup&gt;3&lt;/sup&gt;, only &lt;br/&gt;
1/4th the density of Earth. (source: &lt;a
href="http://nssdc.gsfc.nasa.gov/planetary/factsheet/jupiterfact.html"&gt;NASA&lt;/a&gt;).
&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Go’s tepid, partial support for object oriented programming reminds me of Perl.
Writing a Go function and making it special &amp;ndash; “blessing” it &amp;ndash; by assigning it a
receiver reminds me of how I would bless a hash in a Perl program. Perhaps
Google used Perl as design inspiration for Go; perhaps they wanted to include a
small bit of Perl’s quirky, bizarre but lovable behavior in Go.&lt;/p&gt;

&lt;p&gt;Regardless, don’t stretch your programming language by using it in ways it
wasn’t intended to be used. And certainly don’t change your ideas and solutions
to fit any given programming language. Choose the programming language that has
keywords and syntax that allow you to express your ideas in a natural,
straightforward manner. The only purpose of a language, whether a human
language or programming language, is to express our abstract thoughts using
words in simple, or even beautiful, ways.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Don’t Let Your Data Out of the Database</title>
    <link href="http://patshaughnessy.net/2015/6/18/dont-let-your-data-out-of-the-database" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/6/18/dont-let-your-data-out-of-the-database</id>
    <published>2015-06-18T00:00:00Z</published>
    <updated>2015-06-18T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/escape.png"&gt;&lt;br/&gt;
  &lt;i&gt;Don’t let your data escape from your database&lt;br/&gt;
  and cause unintended performance mistakes.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Keep your data in the database, not for security reasons but to avoid
performance mistakes. Often the best way to speed up your applicati</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/escape.png"&gt;&lt;br/&gt;
  &lt;i&gt;Don’t let your data escape from your database&lt;br/&gt;
  and cause unintended performance mistakes.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Keep your data in the database, not for security reasons but to avoid
performance mistakes. Often the best way to speed up your application is to let
your database server do what it was designed to do: operate on data.&lt;/p&gt;

&lt;p&gt;Most modern programming languages and frameworks hide databases behind an
elegant, beautiful layer of abstraction. Developers today don’t need to write
or even understand Structured Query Language (SQL), the native language of
database servers. We view SQL as a low-level, technical relic of 1970s Computer
Science, best left behind in academic journals and college classrooms.&lt;/p&gt;

&lt;p&gt;However, not learning and thoroughly understanding SQL would be a tremendous
mistake. In fact, many data related performance problems are a result of using
a high level language, such as Ruby or Python, to work with data instead of
SQL. Keep your data where it belongs… in the database. Use your database server
to operate on your data in place, and then fetch the result your application
actually needs.&lt;/p&gt;

&lt;p&gt;Let me show you what I mean with a simple example.&lt;/p&gt;

&lt;div style="clear: both"&gt;&lt;/div&gt;


&lt;h2&gt;Posts and Comments&lt;/h2&gt;

&lt;p&gt;Suppose I have data in a one-many relationship: one post has many comments.
Using ActiveRecord, the popular Ruby ORM, I implement a one-many association by
writing:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Post&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Base&lt;/span&gt;
  has_many &lt;span class="symbol"&gt;:comments&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Comment&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Base&lt;/span&gt;
  belongs_to &lt;span class="symbol"&gt;:post&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Ruby’s powerful dynamic behavior allows me to query the comments for a given
post in a very natural, human way:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post = &lt;span class="constant"&gt;Post&lt;/span&gt;.find(&lt;span class="integer"&gt;1&lt;/span&gt;)
post.comments
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;But remember ActiveRecord isn’t a magic framework. It doesn’t have a secret
connection to the tables in my database. It has to speak to the database server
like everyone else, using the server’s language: SQL. Reading my log file, I
can see how ActiveRecord translates &lt;span class="code"&gt;post.comments&lt;/span&gt; into SQL:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="class"&gt;select&lt;/span&gt; comments.* &lt;span class="keyword"&gt;from&lt;/span&gt; comments &lt;span class="keyword"&gt;where&lt;/span&gt; comments.post_id = &lt;span class="integer"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;After executing this SQL statement, ActiveRecord converts the result set into
an array of Ruby objects which I can then use in my code. For example, if I
want the latest comment for a post I can write:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Post&lt;/span&gt;
  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;latest_comment&lt;/span&gt;
    comments.max {|a, b| a.updated_at &amp;lt;=&amp;gt; b.updated_at }
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Here I ask Ruby to sort the comment objects and return the latest one, the
comment with the maximum &lt;span class="code"&gt;updated_at&lt;/span&gt; value. Now I can
find the person who wrote the latest comment for a post just by writing:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post.latest_comment.author
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;





&lt;div style="float: right; padding: 7px 0px 50px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/open-cell.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;h2&gt;Where Is My Data?&lt;/h2&gt;

&lt;p&gt;The problem with this approach is that it doesn’t scale. Suppose this post has
hundreds or even thousands of comments; in this case, ActiveRecord will convert
them all into Ruby objects just so I can iterate through them in the
&lt;span class="code"&gt;latest_comment&lt;/span&gt; method.&lt;/p&gt;

&lt;p&gt;My mistake was to let my data out of the database. Instead, I should have asked
the database do the work for me.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at how &lt;span class="code"&gt;latest_comment&lt;/span&gt; works:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/filter-sort.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the right, I start with all of the comments in the database, tens of
thousands of them let’s say. Next, I need to search for the comments associated
with my post, filtering on the &lt;span class="code"&gt;post_id&lt;/span&gt; column. This
yields a subset, hundreds of comments for example. Finally, I sort these
filtered comments and take the last one, yielding the latest one on the left.&lt;/p&gt;

&lt;p&gt;The problem with my Ruby solution is that I perform the filtering in the
database, but the sorting in Ruby. In between, the entire subset of comments
for a post have to be transmitted from the database server to my Ruby
application server:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/ruby-sort.png"/&gt;&lt;/p&gt;

&lt;p&gt;To transmit all of these records, the database needs to serialize them to some
binary format, which my Ruby code (or my DB driver actually) later needs to
unpack. Finally, ActiveRecord has to convert this binary data into Ruby
objects.&lt;/p&gt;

&lt;p&gt;This process takes time; in particular, creating hundreds or thousands of Ruby
objects involves allocating a series of memory structures and placing them into
a large array. Using a process called “garbage collection,” Ruby might even
have to find and recycle older unused Ruby objects to hold the comments, which
would take even more time.&lt;/p&gt;

&lt;h2&gt;Databases Are Faster Than You Are&lt;/h2&gt;

&lt;p&gt;The solution is obvious: perform the search inside the database and only return
the latest comment. But how do I ask my database server to search for the
latest comment? By using ActiveRecord methods such as &lt;span class="code"&gt;where&lt;/span&gt;,
&lt;span class="code"&gt;order&lt;/span&gt; and &lt;span class="code"&gt;first&lt;/span&gt; to describe
what I want, instead of writing my own code in Ruby. This line will do the
trick:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post.comments.order(&lt;span class="key"&gt;updated_at&lt;/span&gt;: &lt;span class="symbol"&gt;:desc&lt;/span&gt;).first
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;ActiveRecord translates this into SQL code as follows:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="class"&gt;select&lt;/span&gt; comments.* &lt;span class="keyword"&gt;from&lt;/span&gt; comments
&lt;span class="keyword"&gt;where&lt;/span&gt; comments.post_id = &lt;span class="integer"&gt;1&lt;/span&gt;
&lt;span class="keyword"&gt;order&lt;/span&gt; &lt;span class="keyword"&gt;by&lt;/span&gt; comments.updated_at &lt;span class="directive"&gt;desc&lt;/span&gt; limit &lt;span class="integer"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;This will run much faster than my previous solution, because my database only
transmits one comment record over the network to my Ruby server: the latest
one. And Ruby only creates one Ruby object, for the latest comment:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/db-sort.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now highly optimized C code, running on the same server that holds the comments
table data, filters the comments by post, and sorts the matches by timestamp.
This code has been used and tested by millions of developers around the world
for years; don’t try to reinvent the wheel by rewriting the sort yourself using
Ruby.&lt;/p&gt;

&lt;h2&gt;Caching the Latest Comment&lt;/h2&gt;

&lt;p&gt;Suppose in my user interface I always show the author of the latest comment
next to each post. Now to display my page, I need to perform this comment
search over and over again for every post. One way to avoid the comment query
altogether would be to cache the latest comment’s author right inside the posts
table. That way I’ll get the latest comment’s author automatically when I load
the posts. No need for repeated searches, or any queries on the comments table
at all!&lt;/p&gt;

&lt;p&gt;In practice, if I’ve remembered to create indexes on the &lt;span
class="code"&gt;post_id&lt;/span&gt; and &lt;span class="code"&gt;updated_at&lt;/span&gt; columns,
the comment search SQL above will run very quickly, even if I execute it many
times. I could even load the latest comments for all the posts using single SQL
query, but for the sake of argument today, let’s explore a caching solution anyway.&lt;/p&gt;

&lt;p&gt;Again ActiveRecord makes this easy. All I need to do is write a migration like
this:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;AddLatestCommentAuthorToPosts&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Migration&lt;/span&gt;
  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;change&lt;/span&gt;
    add_column &lt;span class="symbol"&gt;:posts&lt;/span&gt;, &lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, &lt;span class="symbol"&gt;:string&lt;/span&gt;
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Now I just need to be sure to update the post each time a user writes a new
comment:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
post.update_attribute(&lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;user name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;h2&gt;Data Migration Using Ruby&lt;/h2&gt;

&lt;p&gt;Of course, I forgot something important. Using &lt;span
class="code"&gt;update_attribute&lt;/span&gt; I save the author for any new comments,
but what about all of the existing comments? How do I set this column’s initial
value for all the comments already in my database?&lt;/p&gt;

&lt;p&gt;Simple enough: I just add a method to my migration that calls &lt;span class="code"&gt;update_attribute&lt;/span&gt;.
Here’s how to do it:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;AddLatestCommentAuthorToPosts&lt;/span&gt; &amp;lt; &lt;span class="constant"&gt;ActiveRecord&lt;/span&gt;::&lt;span class="constant"&gt;Migration&lt;/span&gt;
  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;change&lt;/span&gt;
    add_column &lt;span class="symbol"&gt;:posts&lt;/span&gt;, &lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, &lt;span class="symbol"&gt;:string&lt;/span&gt;
    populate_latest_comment_authors
  &lt;span class="keyword"&gt;end&lt;/span&gt;

  &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;populate_latest_comment_authors&lt;/span&gt;
   &lt;span class="constant"&gt;Post&lt;/span&gt;.all.each &lt;span class="keyword"&gt;do&lt;/span&gt; |post|
      latest_author = post.comments.order(&lt;span class="key"&gt;updated_at&lt;/span&gt;: &lt;span class="symbol"&gt;:desc&lt;/span&gt;).first.author
      post.update_attribute(&lt;span class="symbol"&gt;:latest_comment_author&lt;/span&gt;, latest_author)
    &lt;span class="keyword"&gt;end&lt;/span&gt;
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Because you write migrations in Ruby, ActiveRecord makes it simple to perform
complex transformations in a simple, elegant way. Using Ruby I get all the
posts, iterate over each one, lookup the latest comment for that post, and
update the latest comment author field.&lt;/p&gt;

&lt;p&gt;But I’ve made the same performance mistake as before! Looking at my Rails log
after running this migration, I find a series of repeated SQL statements:&lt;/p&gt;

&lt;pre&gt;
SELECT  "comments".* FROM "comments"  WHERE "comments"."post_id" = $1  ORDER BY "comments"."updated_at" DESC LIMIT 1  [["post_id", 2]]
UPDATE "posts" SET "latest_comment_author" = $1, "updated_at" = $2 WHERE "posts"."id" = 2  [["latest_comment_author", "Harry"], ["updated_at", "2015-06-17 13:58:42.512160"]]
SELECT  "comments".* FROM "comments"  WHERE "comments"."post_id" = $1  ORDER BY "comments"."updated_at" DESC LIMIT 1  [["post_id", 3]]
UPDATE "posts" SET "latest_comment_author" = $1, "updated_at" = $2 WHERE "posts"."id" = 3  [["latest_comment_author", "Harry"], ["updated_at", "2015-06-17 13:58:42.514676"]]
SELECT  "comments".* FROM "comments"  WHERE "comments"."post_id" = $1  ORDER BY "comments"."updated_at" DESC LIMIT 1  [["post_id", 1]]
UPDATE "posts" SET "latest_comment_author" = $1, "updated_at" = $2 WHERE "posts"."id" = 1  [["latest_comment_author", "Harry"], ["updated_at", "2015-06-17 13:58:42.516071"]]
&lt;/pre&gt;


&lt;p&gt;Again, I’ve let my data out of the database. By loading all of the posts using
&lt;span class="code"&gt;Post.all&lt;/span&gt;, and iterating over them using &lt;span
class="code"&gt;each&lt;/span&gt;, I’ve triggered this series of repeated SQL commands.
Now I’m transmitting all of the post data, and then more data back and forth
for each post between my database and my Ruby application:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/ruby-iterate.png"/&gt;&lt;/p&gt;

&lt;p&gt;Just like my previous code, this migration will perform poorly. If I have just
a few posts it probably doesn’t matter. But imagine if there are thousands or
even 100,000s of post records: This migration might take minutes or even hours
to complete! My database server and Ruby need to serialize, transmit and
deserialize data for each one of these SQL commands.&lt;/p&gt;

&lt;p&gt;There must be a better way.&lt;/p&gt;

&lt;h2&gt;Data Migration Using SQL&lt;/h2&gt;

&lt;p&gt;The solution is the same as before: Don’t let your data out of the database.
Instead of writing Ruby code to update each post record, ask the database
server to do it. My database server already has all my post data in an
optimized format, likely loaded into memory. It can iterate over the posts and
update them very quickly.&lt;/p&gt;

&lt;div style="float: right; padding: 17px 0px 10px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/6/18/prison.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;But how? How do I ask the database server to update all the posts? I need to
speak the database’s language: SQL. By writing SQL directly, I can be sure the
database is doing exactly what I want, that it’s using the most efficient
algorithm possible. I can be sure my database and I understand each other.&lt;/p&gt;

&lt;p&gt;Here’s one way to update all the posts using SQL:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="class"&gt;update&lt;/span&gt; posts &lt;span class="class"&gt;set&lt;/span&gt; latest_comment_author = (
  &lt;span class="class"&gt;select&lt;/span&gt; author &lt;span class="keyword"&gt;from&lt;/span&gt; comments
  &lt;span class="keyword"&gt;where&lt;/span&gt; comments.post_id = posts.id
  &lt;span class="keyword"&gt;order&lt;/span&gt; &lt;span class="keyword"&gt;by&lt;/span&gt; comments.updated_at &lt;span class="directive"&gt;desc&lt;/span&gt;
  limit &lt;span class="integer"&gt;1&lt;/span&gt;
)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;This tiny SQL program actually uses SQL commands similar to the what I found
repeated in my log file. But there’s an important difference: This SQL code
doesn’t refer to hard coded post id values, such as 1 or 2. Here I’ve updated
all of the posts with a single command!&lt;/p&gt;

&lt;p&gt;How does this work? Let’s take a look:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/db-iterate.png"/&gt;&lt;/p&gt;

&lt;p&gt;Using a SQL migration, my Ruby code sends a single SQL command to the database
server, which is transmitted over the network to the database. Then, on the
right, my database server performs the same iteration over the posts table,
selecting the latest comment for each one.&lt;/p&gt;

&lt;p&gt;This looks similar, but there’s a crucial difference: The iteration happens
entirely inside the database server. No data needs to be packed, transmitted to
the Ruby server and unpacked again. In fact, the C code performing the repeated
&lt;span class="code"&gt;SELECT&lt;/span&gt; statements has been compiled to native machine
language and will run very quickly. Once it fetches the latest comment, it can
directly update each post because the posts table is stored nearby on the same
server’s hard drive, or even in memory.&lt;/p&gt;

&lt;h2&gt;Why Does the SQL Code Iterate?&lt;/h2&gt;

&lt;p&gt;You might wonder why I drew an iteration inside the database server above.
After all, I sent the database a simple command containing 1 &lt;span
class="code"&gt;UPDATE&lt;/span&gt; statement and 1 &lt;span class="code"&gt;SELECT&lt;/span&gt;
statement. Why does my database need to execute the select over and over again?&lt;/p&gt;

&lt;p&gt;The reason why is that my SQL code uses a &lt;a href="https://en.wikipedia.org/wiki/Correlated_subquery"&gt;correlated
subquery&lt;/a&gt;, because the inner
&lt;span class="code"&gt;SELECT&lt;/span&gt; uses a value from the outer query. Here’s the
SQL again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/6/18/correlated-subquery.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice the inner &lt;span class="code"&gt;SELECT&lt;/span&gt; statement refers to &lt;span
class="code"&gt;posts.id&lt;/span&gt;, a value from the surrounding &lt;span
class="code"&gt;UPDATE&lt;/span&gt; statement.  This requires the database server to
iterate over all of the posts, executing the inner select for each row. I’ll
leave it as an exercise for the reader to rewrite this using an &lt;span
class="code"&gt;UPDATE-FROM&lt;/span&gt; statement, a &lt;span class="code"&gt;JOIN&lt;/span&gt; or
even Postgres window functions, which would avoid the repeated &lt;span
class="code"&gt;SELECT&lt;/span&gt;s.&lt;/p&gt;

&lt;p&gt;However, remember if there are indexes on the columns in the comments table,
the iteration selecting the latest comment for each post will be very fast. It
will certainly be thousands of times faster than sending repeated &lt;span
class="code"&gt;SELECT&lt;/span&gt; and &lt;span class="code"&gt;UPDATE&lt;/span&gt; SQL statements
from your Ruby server over the network.&lt;/p&gt;

&lt;h2&gt;Do You Need to Learn SQL?&lt;/h2&gt;

&lt;p&gt;In reality I could have written this data migration using Ruby code.
ActiveRecord provides a rich set of methods, even allowing for sophisticated
queries employing subselects. And in the rare case when
ActiveRecord can’t generate the SQL I need, I can always resort to using the
underlying &lt;a href="https://github.com/rails/arel"&gt;Arel&lt;/a&gt; Ruby library. In practice,
it’s rare that you will actually need to write SQL code inside a Rails
application.&lt;/p&gt;

&lt;p&gt;Then why learn SQL? You should learn SQL because it will give you tremendous
insight into how database servers actually work. You’ll learn what database
servers can really do, and what they can’t. You won’t try to reinvent the wheel
when you already have a server that uses algorithms more powerful and
sophisticated that any you could write.&lt;/p&gt;

&lt;p&gt;Use the database server for what it was designed to do: to solve your data
problems. Whether you write SQL directly or use a tool like ActiveRecord to
generate SQL automatically, perform the search, sort, or calculation you need
right inside the database.&lt;/p&gt;

&lt;p&gt;Don’t let your data out of the database until you need to… until you have just
the values your application really needs.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Mark Methods Private When You Don’t Test Them</title>
    <link href="http://patshaughnessy.net/2015/2/16/mark-methods-private-when-you-dont-test-them" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/2/16/mark-methods-private-when-you-dont-test-them</id>
    <published>2015-02-16T01:00:00Z</published>
    <updated>2015-02-16T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/2/16/plaza-de-la-merced.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;My father in law once lived in same building where Picasso&lt;br/&gt;was born, near the Plaza de la Merced in Málaga, Spain.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;In Ruby and many other languages, you write private methods to implement
internal logic you don’t want</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/2/16/plaza-de-la-merced.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;My father in law once lived in same building where Picasso&lt;br/&gt;was born, near the Plaza de la Merced in Málaga, Spain.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;In Ruby and many other languages, you write private methods to implement
internal logic you don’t want to expose. You want the freedom to rename,
repurpose or even delete them without worrying about impacting anything else.
The &lt;span class="code"&gt;private&lt;/span&gt; keyword signals other developers: Don’t rely on this; don’t call
it; it might change. This is especially important when writing framework or
library code that many other developers will use.&lt;/p&gt;

&lt;p&gt;But which methods should you make private? Sometimes this is obvious; sometimes
it isn’t. A good rule of thumb to use is: If you’re not testing a method, it
should be private.&lt;/p&gt;

&lt;br/&gt;


&lt;br/&gt;


&lt;p&gt;But wait a minute! Aren’t we supposed to test everything? Isn’t 100% code
coverage the nirvana every Ruby developer seeks? Let me clarify. You should
mark methods private when you test them indirectly by calling the other, public
methods in the same class. Use the &lt;span class="code"&gt;private&lt;/span&gt; keyword to help organize your code,
to remind yourself what you still need to test, and what you don’t.&lt;/p&gt;

&lt;h2&gt;Three Paintings&lt;/h2&gt;

&lt;p&gt;A simple example will make this clear. Suppose I have a class that describes a
painting:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="constant"&gt;Painting&lt;/span&gt; = &lt;span class="constant"&gt;Struct&lt;/span&gt;.new(&lt;span class="symbol"&gt;:name&lt;/span&gt;, &lt;span class="symbol"&gt;:year&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Now I can create a list of three paintings in a &lt;span
class="code"&gt;Minitest::Spec&lt;/span&gt; file like this:&lt;/p&gt;

&lt;div class="CodeRay"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
let(&lt;span class="symbol"&gt;:one&lt;/span&gt;) { &lt;span class="constant"&gt;Painting&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1900&lt;/span&gt;) }
let(&lt;span class="symbol"&gt;:two&lt;/span&gt;) { &lt;span class="constant"&gt;Painting&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1937&lt;/span&gt;) }
let(&lt;span class="symbol"&gt;:three&lt;/span&gt;) { &lt;span class="constant"&gt;Painting&lt;/span&gt;.new(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1958&lt;/span&gt;) }
let(&lt;span class="symbol"&gt;:paintings&lt;/span&gt;) { [one, two, three] }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Suppose my first requirement is to return the first painting from the list.
Simple enough:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 200px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  list.first
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;should return the first element&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).must_equal one
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;I just call &lt;span class="code"&gt;Array#first&lt;/span&gt; and I’m done. Returning the
rest of the list is slightly more interesting:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 200px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = list
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest of the elements&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).must_equal [two, three]
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Using &lt;a href="http://devblog.avdi.org/2010/01/31/first-and-rest-in-ruby/"&gt;a trick I learned from
Avdi&lt;/a&gt;, &lt;span
class="code"&gt;rest&lt;/span&gt; always returns an array even if the input list was
empty or had only one element. So far, so good. I’ve written two methods and
two tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests.png"/&gt;&lt;/p&gt;

&lt;h2&gt;A New Requirement&lt;/h2&gt;

&lt;p&gt;Now suppose my business requirement changes slightly and I instead need to
return the first painting sorted alphabetically by name. Once again, it’s not
hard to do.&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt;.first
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;should return the first element&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).name.must_equal &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;


&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;And I need &lt;span class="code"&gt;rest&lt;/span&gt; to use the same sort order, so I repeat the call to &lt;span class="code"&gt;sort&lt;/span&gt;:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt; 
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;div class="CodeRay" style="display: inline-block"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest of the elements&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).map(&amp;amp;&lt;span class="symbol"&gt;:name&lt;/span&gt;).must_equal [
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ]
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;I’ve implemented new behavior, but still have two methods and two tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Extracting a Method&lt;/h2&gt;

&lt;p&gt;Because both of my methods are covered by tests, I’m free to refactor them. I
decide to extract a new method, &lt;span class="code"&gt;sorted_by_name&lt;/span&gt;:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  sorted_by_name(list).first
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = sorted_by_name(list)
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;




&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;sorted_by_name&lt;/span&gt;(list)
  list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;





&lt;div class="CodeRay" style="display: inline-block; width: 400px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the element with the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).name.must_equal &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;

it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest after the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).map(&amp;amp;&lt;span class="symbol"&gt;:name&lt;/span&gt;).must_equal [
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ]
&lt;span class="keyword"&gt;end&lt;/span&gt;







&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;Here I’ve simply moved the call to sort into a utility method called
&lt;span class="code"&gt;sorted_by_name&lt;/span&gt;. Now &lt;span class="code"&gt;first&lt;/span&gt;
and &lt;span class="code"&gt;rest&lt;/span&gt; both call &lt;span
class="code"&gt;sorted_by_name&lt;/span&gt;, making the code a bit clearer and DRY-er. But
now I have three methods and only two tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests-three-methods.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Mark Methods Private When You Don’t Test Them&lt;/h2&gt;

&lt;p&gt;Notice I didn’t bother writing a test for &lt;span class="code"&gt;sorted_by_name&lt;/span&gt;. I know it works
because my other tests still pass. The existing tests are sufficient; I am
testing &lt;span class="code"&gt;sorted_by_name&lt;/span&gt; indirectly. Because I extracted &lt;span class="code"&gt;sorted_by_name&lt;/span&gt; from
&lt;span class="code"&gt;first&lt;/span&gt; and &lt;span class="code"&gt;rest&lt;/span&gt;, because I
refactored my code without adding any new behavior, no new test were required.&lt;/p&gt;

&lt;p&gt;In this scenario, take the time to mark the new, untested method as private:&lt;/p&gt;

&lt;div class="CodeRay" style="display: inline-block; width: 300px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;first&lt;/span&gt;(list)
  sorted_by_name(list).first
&lt;span class="keyword"&gt;end&lt;/span&gt;

&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rest&lt;/span&gt;(list)
  _, *rest = sorted_by_name(list)
  rest
&lt;span class="keyword"&gt;end&lt;/span&gt;



private

&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;sorted_by_name&lt;/span&gt;(list)
  list.sort &lt;span class="keyword"&gt;do&lt;/span&gt; |p1, p2|
    p1.name &amp;lt;=&amp;gt; p2.name
  &lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;





&lt;div class="CodeRay" style="display: inline-block; width: 400px;"&gt;
  &lt;div class="code"&gt;&lt;pre&gt;
it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the element with the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  first(paintings).name.must_equal &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guernica&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;

it &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;returns the rest after the first name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  rest(paintings).map(&amp;amp;&lt;span class="symbol"&gt;:name&lt;/span&gt;).must_equal [
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Petite Fleurs&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Spanish Couple In Front Of Inn&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ]
&lt;span class="keyword"&gt;end&lt;/span&gt;








&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;The &lt;span class="code"&gt;private&lt;/span&gt; keyword here reminds me I’ve already tested &lt;span
class="code"&gt;sorted_by_name&lt;/span&gt;, that I don’t need to write new tests for
it. Now &lt;span class="code"&gt;private&lt;/span&gt; is helping me organize my code; it’s helping me remember
which methods I don’t need to test… and which methods are missing important
tests.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/2/16/two-tests-three-methods-private.png"/&gt;&lt;/p&gt;

&lt;p&gt;If my tests don’t need to know about &lt;span class="code"&gt;sorted_by_name&lt;/span&gt;, then certainly other
developers don’t. It should be private. Marking it private reminds me that it
is being tested indirectly, that I didn’t just forget to write a test for it.
Marking it private tells other developers about what I’ve learned from my own
test suite.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using Rake to Generate a Blog</title>
    <link href="http://patshaughnessy.net/2015/1/8/using-rake-to-generate-a-blog" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/1/8/using-rake-to-generate-a-blog</id>
    <published>2015-01-08T01:00:00Z</published>
    <updated>2015-01-08T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/1/8/power-rake.png"&gt;&lt;br/&gt;
  &lt;i&gt;Jim Weirich showing a real power rake at &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;GORUCO 2012&lt;/a&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last year I needed to replace the software I use to serve this web site.
Instead of just using &lt;a href="h</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/1/8/power-rake.png"&gt;&lt;br/&gt;
  &lt;i&gt;Jim Weirich showing a real power rake at &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;GORUCO 2012&lt;/a&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last year I needed to replace the software I use to serve this web site.
Instead of just using &lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt;,
&lt;a href="https://middlemanapp.com"&gt;Middleman&lt;/a&gt;, &lt;a href="http://nanoc.ws"&gt;Nanoc&lt;/a&gt; or one of the
&lt;a href="https://www.ruby-toolbox.com/categories/static_website_generation"&gt;many other available
options&lt;/a&gt;, I
decided to implement my own &lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io"&gt;custom blog
software&lt;/a&gt;. After a
fair amount of work, I was able to implement a static blog site generator using
only &lt;a href="https://github.com/jimweirich/rake"&gt;Rake&lt;/a&gt; and a handful of simple Ruby classes. Although it took a bit longer,
it was a lot of fun and I learned a few tricks which I’d like to pass along
today.&lt;/p&gt;

&lt;p&gt;I first got the idea of using Rake as a static site generator from a
presentation called &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;Power Rake&lt;/a&gt;,
given by the late Jim Weirich at GORUCO 2012. This was one of the first Ruby
conferences I had ever attended, and was also the first time I had ever seen
Jim speak in public. It still stands out in my memory as one of the best
conference presentations I&amp;rsquo;ve ever seen. Funny, engaging, interesting, but most
of all &lt;em&gt;genuine&lt;/em&gt;, Jim had me and the rest of the audience enthralled as he talked
about &lt;a href="https://github.com/jimweirich/rake"&gt;Rake&lt;/a&gt;, his Ruby reinterpretation of
the old C make utility from the 1970s.&lt;/p&gt;

&lt;p&gt;The key idea behind using Rake to generate a static site is to generate and
manipulate files using Rake file tasks. What are file tasks? How are they
different from standard Rake tasks? To find out watch Jim’s presentation, or
read &lt;a href="http://devblog.avdi.org/2014/04/21/rake-part-1-basics/."&gt;an excellent series of articles and
screencasts&lt;/a&gt; by Avdi
Grimm. Today I’ll explain how I used Rake to create this blog. But first, let’s review
what a blog really is.&lt;/p&gt;

&lt;h2&gt;A Blog or a Static Web Site?&lt;/h2&gt;

&lt;p&gt;Most of the blogs in the world consist of a few dynamically generated web pages
served by either &lt;a href="http://wordpress.com"&gt;wordpress.com&lt;/a&gt; or
&lt;a href="http://blogger.com"&gt;blogger.com&lt;/a&gt;. To be honest, I should just use one of these
two free services for my site as well. However, I have a few years worth of
markdown files that contain all of my old content which would be a hassle to
import into whatever format Wordpress or Google uses. Plus using these sites
would be no fun at all; instead, I was looking for an excuse to write some Ruby
code and to learn more about Rake.&lt;/p&gt;

&lt;p&gt;What I really needed was an automated process for converting my markdown source
files into a series of static HTML files that were navigable using URL patterns that
readers expect. That is, I wanted a Rake task that would do this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/convert-file.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the top is one of my markdown files; on the bottom is the HTML version. I
needed a way to generate the bottom file from the top one. I needed to write a Rake
task that would iterate over all of the markdown files in the “posts” directory,
and generate the corresponding HTML files in the proper target directory.  The
markdown file name (“posts/2014-10-13-…”) was a naming convention I used to stay
organized. However, the name and path of the HTML file was what readers would see
in the post’s URL online &amp;ndash; for example:
&lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals&lt;/a&gt;.
This was a problem well suited to Rake file tasks, because they allow you to
create a series of dependencies between source and target files.&lt;/p&gt;

&lt;p&gt;But before I was ready to use file tasks, I needed to use a few tricks to make
those tasks easier to write.&lt;/p&gt;

&lt;h2&gt;Iterating Over Files Using Rake::FileList&lt;/h2&gt;

&lt;p&gt;Ruby objects are easier to work with than text files are, so the first thing I
decided to do was to write a Ruby class that represented one of my markdown
files. I called it &lt;span class="code"&gt;Post&lt;/span&gt; because each markdown file represented a single blog
post.&lt;/p&gt;

&lt;p&gt;Next, I needed to create a post object for each of the files in the posts
directory, by listing the files and iterating over them. It turns out Rake
provides a very simple way to do this: the &lt;span class="code"&gt;Rake::FileList&lt;/span&gt; class. To quote &lt;a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/rake/rdoc/Rake/FileList.html"&gt;the
documentation&lt;/a&gt;:&lt;/p&gt;

&lt;br/&gt;




&lt;blockquote&gt;
A FileList is essentially an array with a few helper methods defined to make file manipulation a bit easier.
&lt;/blockquote&gt;


&lt;p&gt;I like things that are easier. Here’s how I used &lt;span class="code"&gt;FileList&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/mapping-posts.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the left are my markdown files with the corresponding post objects on the right. My
code above first created a &lt;span class="code"&gt;FileList&lt;/span&gt;, using the &lt;span class="code"&gt;posts/*.markdown&lt;/span&gt; pattern. You
can think of the &lt;span class="code"&gt;FileList&lt;/span&gt; as an array of files that match the given pattern.
Once I had this array, I &lt;em&gt;mapped&lt;/em&gt; the array to a second array of ruby objects using
&lt;span class="code"&gt;Enumerable#map&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Blog Post Routing&lt;/h2&gt;

&lt;p&gt;Now that I had a &lt;span class="code"&gt;Post&lt;/span&gt; object for each source markdown file, I could add methods
to the &lt;span class="code"&gt;Post&lt;/span&gt; class to make manipulating the markdown files easier. Most
importantly, what I needed to know for each markdown file is where its HTML
should go in the generated site. That is, I needed to know the URL of the post:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/post-url.png"/&gt;&lt;/p&gt;

&lt;p&gt;This did the trick. The &lt;span class="code"&gt;date&lt;/span&gt; and &lt;span class="code"&gt;title&lt;/span&gt; methods parsed some metadata values I
saved in the markdown file along with the text. The &lt;span class="code"&gt;url&lt;/span&gt; method returned a string using
the year/month/day pattern most people are familiar with. The &lt;span class="code"&gt;slugize&lt;/span&gt; method
removed characters from the title that weren’t compatible with URL strings. As I
explained earlier, the URL is also the file system path for each post’s HTML
file: The single line of code above mapped the posts to an array of strings, each
one the path to an HTML file, the URL of that post appended with a file
extension.&lt;/p&gt;

&lt;h2&gt;Grouping Two Arrays Together&lt;/h2&gt;

&lt;p&gt;Now I had two arrays: &lt;span class="code"&gt;Post&lt;/span&gt; objects and HTML file paths. I was almost ready to
write a Rake file task that would convert the posts into HTML files. But, as
you&amp;rsquo;ll see in a minute, writing a file task requires two files: a source file
and a target file. Somehow I needed to convert these two separate arrays into a
single array of pairs, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/zipping.png"/&gt;&lt;/p&gt;

&lt;p&gt;As you can see, Ruby’s &lt;span class="code"&gt;Enumerable#zip&lt;/span&gt; method was
perfect solution. It yielded object pairs, one object taken from the receiver
(&lt;span class="code"&gt;html_files&lt;/span&gt;) and the other object taken from the
argument (&lt;span class="code"&gt;posts&lt;/span&gt;). If you pass in 2, 3 or more
arguments, it will yield triplets, quadruplets or n-tuples to the block
instead. I first learned about &lt;span class="code"&gt;zip&lt;/span&gt; from Jim Weirich’s
2012 Power Rake presentation; he used it in his static web site example in a
very similar way.  Of course, you can use &lt;span class="code"&gt;zip&lt;/span&gt; to
process multiple arrays for any purpose. It’s one of Ruby’s most beautiful
features I think.&lt;/p&gt;

&lt;h2&gt;Writing Rake File Tasks&lt;/h2&gt;

&lt;p&gt;As you probably know, a standard Rake task runs when you execute the task
directly, or when you run another task that depends on it. A file task,
however, will only execute the Ruby code inside the block if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The source file is newer than the target file, or&lt;/li&gt;
&lt;li&gt;The target file doesn’t exist at all.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This behavior is ideal for generating a static web site, or for any other job
that requires generating a file from another file. Rake will build the target
file for the first time if it doesn’t exist, or update it if the source file
has changed.&lt;/p&gt;

&lt;p&gt;Now that I had pairs of HTML paths and &lt;span class="code"&gt;Post&lt;/span&gt; objects,
it was easy for me to write a file task using one of these pairs. Here’s what I
came up with:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/file-task.png"/&gt;&lt;/p&gt;

&lt;p&gt;By calling &lt;span class="code"&gt;file&lt;/span&gt; inside of the &lt;span class="code"&gt;zip&lt;/span&gt; block, I created a file task for each one
of the paths in &lt;span class="code"&gt;html_files&lt;/span&gt;. Now if I created a single, standard Rake task that
depended on the array of html file paths, I could test whether any or all of the
HTML files needed to be generated:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/rake-posts.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now I could generate all of my blog posts with one command: &lt;span class="code"&gt;rake posts&lt;/span&gt;!&lt;/p&gt;

&lt;h2&gt;Rendering Each Post Using ERB&lt;/h2&gt;

&lt;p&gt;What did the code inside the file task do? It generated the HTML file for a
single post using &lt;span class="code"&gt;ERB&lt;/span&gt;, using a method I wrote called &lt;span class="code"&gt;Layout#render&lt;/span&gt;. If you’re
interested, here’s the &lt;span class="code"&gt;Layout&lt;/span&gt; class (&lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/lib/layout.rb"&gt;github&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/layout.png"/&gt;&lt;/p&gt;

&lt;p&gt;I won’t explain this line by line, but there were a couple of interesting tricks
here also. First, the &lt;span class="code"&gt;contents&lt;/span&gt; method used nested calls to
ERB to render a page layout surrounding the post, along
with the article text itself. This required I call &lt;span
class="code"&gt;yield&lt;/span&gt; somewhere inside my &lt;span class="code"&gt;layout.erb&lt;/span&gt; file in just the same
way I would in &lt;span class="code"&gt;application.html.erb&lt;/span&gt; for a Rails app.&lt;/p&gt;

&lt;p&gt;The complex line of code at the bottom that uses &lt;span class="code"&gt;instance_eval&lt;/span&gt; and
&lt;span class="code"&gt;binding&lt;/span&gt; seems impossible to understand at first. But actually it’s fairly
standard boilerplate Ruby metaprogramming code that evaluates the ERB template
in the context of the &lt;span class="code"&gt;page&lt;/span&gt; object and the current method.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/metaprogramming.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the left I show the the &lt;span class="code"&gt;page&lt;/span&gt; object, an instance of the &lt;span class="code"&gt;Post&lt;/span&gt; class, in the
center the code running the ERB transformation, and on the right the Ruby call
stack.&lt;/p&gt;

&lt;p&gt;The arrow from ERB going to the left represents the use of &lt;span class="code"&gt;instance_eval&lt;/span&gt;. This
method, built into the Ruby language, resets the &lt;span class="code"&gt;self&lt;/span&gt; pointer to the
receiver or the &lt;span class="code"&gt;page&lt;/span&gt; object in this example. This allows the ERB code to access
the instance variables of the &lt;span class="code"&gt;page&lt;/span&gt; object and the methods of the &lt;span class="code"&gt;Post&lt;/span&gt; class.&lt;/p&gt;

&lt;p&gt;The arrow from ERB going to the right, in turn, represents the call to &lt;span class="code"&gt;binding&lt;/span&gt;.
The &lt;span class="code"&gt;binding&lt;/span&gt; method, also part of the Ruby core language, refers to the
current Ruby stack frame allowing the ERB code to access all of the local
variables present there, such as &lt;span class="code"&gt;recent_posts&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;My Rakefile&lt;/h2&gt;

&lt;p&gt;Of course, I’m glossing over some other important details here, such as
generating the index or home page, the RSS feed and a few other things. For
reference, here’s my entire Rakefile (&lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/Rakefile"&gt;github&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/rakefile.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the call to &lt;span class="code"&gt;Layout#render&lt;/span&gt; and the &lt;span class="code"&gt;rake :posts&lt;/span&gt; task I described
above. Here are some other coding details, if you’re interested:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;After creating the &lt;span class="code"&gt;posts&lt;/span&gt; array, I sort it by date, reversed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I generate the home page using another file task: &lt;span class="code"&gt;index.html&lt;/span&gt;, and a &lt;span class="code"&gt;HomePage&lt;/span&gt; class.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I generate the RSS in a similar way using a third file task: &lt;span class="code"&gt;index.xml&lt;/span&gt;, and a &lt;span class="code"&gt;Feed&lt;/span&gt; class.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Ideas, Not Code&lt;/h2&gt;

&lt;p&gt;If you’re interested in using this code for your own site, it’s on &lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io"&gt;github&lt;/a&gt;.
However, I wouldn’t recommended using it: It’s always a better idea to use a
well tested, robust free service such as wordpress.com or Jekyll.&lt;/p&gt;

&lt;p&gt;Instead of using this code, use the ideas behind it! Take the time to use
&lt;span class="code"&gt;Rake::FileList&lt;/span&gt; and Rake file tasks in whatever application you’re working on. And
please take the time to watch the &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;PowerRake presentation&lt;/a&gt;. You’ll learn more about one
of Ruby’s most powerful tools &amp;ndash; and you’ll be able spend some time with Jim.
Jim’s bright personality and sense of humor can live on in our memory, at
least.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Koichi Sasada Encourages Us To Contribute To Ruby</title>
    <link href="http://patshaughnessy.net/2014/12/17/koichi-sasada-encourages-us-to-contribute-to-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/12/17/koichi-sasada-encourages-us-to-contribute-to-ruby</id>
    <published>2014-12-17T01:00:00Z</published>
    <updated>2014-12-17T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div class="epigraph"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/17/microscope.png"&gt;
  &lt;div class="epigraph-text"&gt;Ruby処理系開発コミュニティは、&lt;br/&gt;あなたの挑戦を歓迎する。&lt;/div&gt;
  &lt;div class="epigraph-caption"&gt;
  The Ruby core community welcomes your challenge.
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Today I’m happy to post an English translation of a new appendix to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ru</summary>
    <content type="html">&lt;div class="epigraph"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/17/microscope.png"&gt;
  &lt;div class="epigraph-text"&gt;Ruby処理系開発コミュニティは、&lt;br/&gt;あなたの挑戦を歓迎する。&lt;/div&gt;
  &lt;div class="epigraph-caption"&gt;
  The Ruby core community welcomes your challenge.
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Today I’m happy to post an English translation of a new appendix to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt; written by
Koichi Sasada (&lt;a href="https://twitter.com/_ko1"&gt;@_ko1&lt;/a&gt;), included in the Japanese
edition last month. As you probably know, Koichi is the developer behind the
virtual machine used by Ruby since Ruby 1.9 was released, known as “YARV.” He
writes about the early days of YARV (apparently he wrote the first version
during a single vacation week!) as well as some interesting aspects of its
technical design.&lt;/p&gt;

&lt;p&gt;But what struck me the most about this essay &amp;ndash; what I found encouraging and
inspiring &amp;ndash; was the story about how Koichi first became involved in Ruby
core development. He writes about how certain Ruby meetups and book
clubs created an environment that enabled him to learn and innovate. This
environment lead directly to the development of YARV, which enables all our
Ruby programs to run faster today.&lt;/p&gt;

&lt;p&gt;He concludes with a message for all of us: We should follow in his footsteps
and not be afraid to contribute to Ruby, to create “yet another Ruby
implementation.” Thinking about his story, to do this maybe we need to seek out
&amp;ndash; or to create &amp;ndash; the right learning environment, like the one Koichi found in
Japan 10 years ago. Thanks for writing this, Koichi! I’m happy and proud that
RUM now concludes with this message.&lt;/p&gt;

&lt;p&gt;Japanese-language edition copyright &amp;copy; 2014 by Ohmsha, Ltd. Reproduced with
permission of the copyright owner.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;




&lt;div class="appendix"&gt;A&lt;/div&gt;


&lt;div class="appendix-title"&gt;さらにそのほかの&lt;br/&gt;Ruby仮想マシン&lt;/div&gt;


&lt;br/&gt;


&lt;div class="appendix-translation"&gt;
Yet More Ruby Virtual Machines
&lt;/div&gt;




&lt;div class="jp"&gt;
&lt;p&gt;今回、私（笹田）がYARV：Yet Another RubyVMの開発者であるという縁で、本書の付録にYARVについて寄稿する機会を得た。本書では、多くのページを割いてYARVの中身を解説していただいている。しかも、原著は英語の著作であるので、世界中で読まれていることになる。ソフトウェア開発者として、たいへん光栄であると共に、読みながら実装の非効率な部分などを見つけてしまい、恥ずかしい思いもある。本稿では、YARVについて少し補足する。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;I (Koichi Sasada) am thankful to have a chance to write about YARV in this
appendix as a developer of YARV: Yet Another Ruby VM. Many pages of this book
describe the internals of YARV. Furthermore, the original edition is written in
English and has been read by people all over the world. I am greatly honored by
that as a software developer, although it humbles me to have found several
inefficiencies in YARV’s implementation while reading the book. In this appendix,
I will give some supplemental information and background on the design and
implementation of YARV.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARV: Yet Another RubyVM&lt;/h2&gt;
&lt;p&gt;YARVは、2004年の正月に、その当時より興味のあったRuby向け仮想マシンとして開発に着手し、簡単なものを1週間程度で開発した。おそらく、暇だったのだと思う。最初のアナウンスメール（[ruby-dev:22494]）を見ると、フィボナッチ数を求めるプログラムは動いていたようである。&lt;/p&gt;
&lt;p&gt;開発当初、YARVはRuby 1.8向けの拡張ライブラリとして実装していた。つまり、実行エンジンをすべて差し替えるのではなく、Ruby 1.8処理系から、指定したRubyプログラムをYARV上で実行する、という構造としていた。Ruby 1.8処理系の上に、もう1つRuby処理系を重ねていたことになる。この構造により、十分に安定しているRuby 1.8処理系を用いて、YARVの試験を比較的容易に行うことができた。また、GCやC APIなどの関数といった基盤コードをそのまま利用することもできた。そして、開発が進んだ後、スレッドなどをサポートするため、一気にRuby 1.8処理系のコア部分を取り除き、YARVに置き換えた。しかし、GCなどの基盤コードはその後も流用を続けた。当初より、Rubyインタプリタ（MRI/CRuby）はC言語と親和性の高い処理系として知られているが、YARVもその特長を受け継いでいる。そして、置き換えたものがRuby 1.9としてリリースされ、2014年現在も、RubyVMとして利用されている。&lt;/p&gt;
&lt;p&gt;よく、YARV：Yet Another RubyVMは、公式に取り込まれたので、Yet Anotherな処理系ではないのではないか、という指摘を受けるが、なんとなく語呂が良いので利用を続けている。ただし、ファイル名やクラス名には利用しないようにしている。開発当時、Ruby向け仮想マシンは、既にいくつか提案されていた。特に、Rubyの生みの親であるまつもと氏によるRiteVM、そしてByteCodeRubyというプロジェクトが知られていたと思う。そのため、“Yet Another”という名前を付けた。もちろん、yaccに代表されるように、この業界では“Yet Another”なものが多く利用されることも多かったため、同じようにYARVも多く利用されるよう、願をかけたということもある。ちなみに、RiteVMは、まつもと氏が鋭意開発しているmrubyの仮想マシンの名前となっている。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;YARV: Yet Another RubyVM&lt;/h2&gt;

&lt;p&gt;I started the development of YARV during the New Year&amp;rsquo;s holiday in 2004. I had
already been interested in a virtual machine for Ruby at that time. I built a
simple prototype within about a week. I must have had plenty of time to kill
back then. According to the first announcement ([ruby-dev:22494]), it was
capable of running a program to calculate Fibonacci numbers.&lt;/p&gt;

&lt;p&gt;In its early stages of development, I implemented YARV as an extension library
for Ruby 1.8. Instead of replacing the whole runtime engine, I designed it to
be used by Ruby 1.8 as a VM to run specific programs. In other words, it was
another Ruby implementation on top of the Ruby 1.8 implementation. This
architecture allowed us to test YARV with relative ease using Ruby 1.8, which
was sufficiently stable. We could continue using the base mechanisms of Ruby
1.8, such as GC, C APIs and so on. After finishing a substantial part of the
development, the Ruby 1.8 core was removed and replaced with YARV all at once,
in order to support features such as threads. However, we kept using
infrastructure code, such as GC, after that. The Ruby interpreter (MRI/CRuby)
is known to have an affinity to the C programming language. YARV inherits that
characteristic as well. Then a new version of Ruby containing YARV at its core
was released as Ruby 1.9. As of this writing in 2014, YARV has been used as the
Ruby VM since then.&lt;/p&gt;

&lt;p&gt;People often point out that YARV is not &amp;ldquo;Yet Another&amp;rdquo; anymore, because it is
the official VM now. Though we still use the name because it somehow sounds
familiar, we make it a rule not to use &amp;ldquo;YARV&amp;rdquo; in file names or class names. When
I started working on YARV, there had already been several proposals for the
development of new virtual machines for Ruby. RiteVM by Matz, the creator of
Ruby, and ByteCodeRuby were the most well known projects then, as far as I can
remember. That lead me to prefix the name of our VM with “Yet Another.” Of
course, I named it so hoping it would become popular. There are many examples
of software programs that have “Yet Another” in their names and nevertheless became
popular: for example yacc. By the way, RiteVM is now the name of the mruby VM
which Matz is actively developing.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARVの設計方針&lt;/h2&gt;
&lt;p&gt;YARVは当時の最新版であるRuby 1.8の仕様を踏襲するのではなく、その次の版である、Ruby 1.9の仕様を実装することとした。当時はRuby 1.9の仕様をどうするか議論していた。YARVではそのRuby 1.9の仕様のもとで開発を進めることにした。別の戦略として、Ruby 1.8に完全互換の仮想マシンを開発することで、多くの人に、即座に利用してもらうこともできた。しかし、いくつかのRuby 1.8の仕様がYARVで用いているスタックマシンでは実現困難であろうと思われたため、新しい仕様をベースに実装しつつ、困難な仕様は仕様変更できないか、交渉しながら開発を進めることとした。この戦略により、Ruby 1.9を実現するRubyインタプリタのひとつとなることができた。後に公式処理系としてマージされた理由のひとつだろうと思う。&lt;/p&gt;
&lt;p&gt;YARVの詳細設計は本書で解説しているとおりである。ただし、本書で説明している設計に辿り着くまでには紆余曲折があった。特に思い浮かぶのは仮想マシンのスタックの構造である。本書では、2重スタックマシンと表現されているが、当初は1つのスタックしか用いていなかった。仮想ではない現実のプロセッサでは、1つのスタックの上に、計算領域と関数呼び出しフレーム構造を交互に確保する。YARVも当初はそのような構造であったが、あまりに複雑となってしまい、性能を犠牲にしても、2つのスタックを用いて管理しよう、という結論に至った。ブロックをクロージャとして取り出す仕組みを実装するとき、特に操作が複雑となったためである。幸いにして本書ではこのあたりの説明をうまく回避しており、読者がこのような複雑さに悩まなくて済むようになっている。ただ、一番難しく、苦労した部分でもあるため、機会があれば解説してみたい。ちなみに、2つのスタックを持つ、ということは、スタックオーバーフローのチェックコストも2倍になる、ということである。そこで、2つのスタックを、1つのメモリブロックで下端から上へ伸ばすスタック、上端から下へ伸ばすスタックとして実装した。この工夫により、2つのスタックのスタックオーバフローのチェックは、2つのスタックポインタの位置関係を1度確認するだけでよく、若干軽量にすることができた。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;Design Principles of YARV&lt;/h2&gt;

&lt;p&gt;We chose to implement YARV for the Ruby 1.9 specification, instead of 1.8. At
the time, Ruby 1.9 was the next version, and we were discussing its
specification. We targeted YARV at that specification. We also had the option
of implementing it for Ruby 1.8, thereby supporting a large number of users
instantly. But some of the Ruby 1.8 features seemed difficult to implement with
the stack machine which YARV is based on. So I decided to implement my VM for
the newer spec, while negotiating with Ruby developers to change the parts of
the specification that were hard to implement. This strategy worked well, and
YARV became one of the interpreters to run Ruby 1.9. I think that was one of
the reasons that it was finally merged in as an official VM.&lt;/p&gt;

&lt;p&gt;This book correctly explains YARV’s design details. I would, however, like to add
that it was not so straightforward to get to the current design. One of the
things I remember is the stack structure of the virtual machine. The book
describes YARV as a &amp;ldquo;double stack machine,&amp;rdquo; but it was using only one stack at
first.  Actual microprocessors allocate a calculation area and a function call
frame one after another on a single stack. YARV used a similar architecture at
first, but it became too complicated. Later I concluded that it should have two
stacks, even if I had to give up some efficiency. YARV’s operation became too
complex especially when implementing the extraction of a block as a closure.
Because this book cleverly avoids such hairy details, readers fortunately do
not have to confront this sort of complexity. I hope, though, I have chance to
explain that, because it was one of the most difficult parts to implement. By
the way, having two stacks means that the cost of checking for stack overflows
also doubles. So I implemented them both in the same memory block: one going
from bottom to top and the other going from top to bottom.  This trick somewhat
reduced the cost of checking for stack overflows, because we only have to check
the positions of two stack pointers once.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARVの開発までの経緯&lt;/h2&gt;
&lt;p&gt;開発に至った経緯についても触れておく。もともと、私は言語処理系の実装に興味があったため、Javaの仮想マシンを2つほど開発したことがあった。そのため、オブジェクト指向言語処理系に必要となる仮想マシンに必要な要件を、既にいくつか知っていた。そのころ、「計算機プログラムの構造と解釈」、通称SICPの読書会が山下伸夫氏により定期的に開催されており、これに参加することで、Schemeの言語処理系についての知見を得ることができた。本書の第8章で紹介されているように、RubyのブロックはLispの関数にあたるものであったため、この知見は重要なものであった。&lt;/p&gt;
&lt;p&gt;2002年12月に青木峰郎氏による、Rubyのソースコードを逐一解説するという異色の書、「Rubyソースコード完全解説」、通称RHGが発売された。そして、高橋征義氏によりRHG読書会が企画され、月1度程度の頻度で開催された。参加者で本書を読み上げていく、というスタイルであったが、不明点は著者である青木氏を含めた参加者で議論できたため、Ruby処理系の詳細を知ることができた。余談だが、SICP読書会、およびRHG読書会は、当時山下氏が勤めていた、新宿にある株式会社タイムインターメディアの会議室で行われていた。私は、これらの読書会に参加するために、月に数回、タイムインターメディアに通っていたことになる。このような大切な機会を与えてくれた諸氏に深く感謝したい。&lt;/p&gt;
&lt;p&gt;RHGによってRuby処理系の構造を学べば、Rubyプログラムを実行する心臓部となる評価器が、Java仮想マシンなどに比べ、あまりに非効率であることは明らかであった。そのため、Rubyの文法を適切に、高速に評価する仮想マシンはどのようなものであるか、ということに興味を持ち、検討を続けた。そして、正月休みの機会に一気に書き上げた。その頃は、まさかRuby 1.9の一部としてリリースされることになるとは思わなかった。最初の動機が性能向上であったため、最初から性能のことを強く意識したソースコードであった。今思えば、早すぎる最適化といえると思う。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;YARV Development Prehistory&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;d like to describe the history of how I came to develop YARV. Because earlier
I had been interested in programming language processors, I had the experience
of implementing two Java virtual machines. That gave me some knowledge of what
was required to implement virtual machines intended for object-oriented
programming languages. At the time, Mr.  Nobuo Yamashita was periodically
holding meetups to read the book &lt;i&gt;The Structure and Interpretation of
Computer Programs&lt;/i&gt; (or SICP). Attending them, I acquired knowledge and
insight about implementations of Scheme. This insight was important since
Ruby&amp;rsquo;s block design was based on Lisp functions, as Chapter 8 of this book
points out.&lt;/p&gt;

&lt;p&gt;It was December 2002 when &lt;i&gt;Ruby Source Code Kanzen Kaisetsu&lt;/i&gt; (the &lt;i&gt;Ruby
Hacking Guide&lt;/i&gt;, or RHG), by Mr. Minero Aoki was published, which is a unique
book that explains the entire Ruby source code. Mr. Masayoshi Takahashi held
meetings to read RHG about once a month. We took turns in a reading group, but
because the author Aoki-san himself was one of the members the other members
could talk with him in person when they had questions. In this way, we learned
the implementation details of Ruby very well. Let me add that both of these
meetups are held in the meeting rooms at Time Intermedia, Ltd., where Mr.
Yamashita was working then. I attended the meetups frequently: several times a
month. I wish to express my deep gratitude to the people who provided such an
environment for learning.&lt;/p&gt;

&lt;p&gt;After reading RHG and learning more about the structure of Ruby’s
implementation, it became clear to me that the evaluation module Ruby used to
run programs &amp;ndash; the heart of the Ruby interpreter &amp;ndash; was not efficient enough. I
kept on studying and thinking about the ideal design of a virtual machine to run
Ruby programs precisely and efficiently, which I finally implemented all at
once during that New Year&amp;rsquo;s holiday. I didn’t foresee that it would be released
as a part of Ruby 1.9. My first motivation was performance improvement &amp;ndash; my
source code surely reflected that. In hindsight, it was such an early
optimization.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;さらにそのほかのRuby仮想マシン&lt;/h2&gt;
&lt;p&gt;本書では、YARVの構造を既知のものとして紹介しており、もしかしたら、このように実装するのが正しいRuby処理系だ、とも読めるかもしれない。しかし、本稿で紹介したとおり、YARVをはじめ、Ruby処理系は人間が試行錯誤しながら、なんとか作り上げてきたソフトウェアにすぎない。本書はRuby 2.0をベースに紹介しているが、Ruby 2.1では、さらに品質を向上するためにさまざまな修正を行った。そして、これからリリースする予定であるRuby 2.2を、より良いものにするため、改善を続けている。&lt;/p&gt;
&lt;p&gt;たとえば、キーワード引数の改善である。本書の第4章では、キーワード引数の実装方法について紹介している。簡単に要約すると、呼び出しにおいて、キーワード引数として渡した名前と値の対を、1つのHashオブジェクトとしてまとめ、通常の引数として渡す。受け側はそのHashオブジェクトから必要な値を読み出すコードをコンパイル時に暗黙に展開する。さて、キーワード引数はRuby 2.0から導入された新機能なので、利用頻度が低いようであり、問題になっていないが、この実装は非効率である。メソッド呼び出しごとにHashオブジェクトが生成されることになり、Hashオブジェクト生成、およびGCのコストがかかる。また、暗黙に展開されるHashオブジェクトの読み込みも、複数のメソッド呼び出しを含むため、遅い。&lt;/p&gt;
&lt;p&gt;この問題を改善するため、Ruby 2.2から、可能な限りHashオブジェクトを生成しないようにキーワード引数を実装し直した。その代わり、コンパイル時にキーワード引数の名前をまとめておき、呼び出し側では値のみ渡すことにした。そして、受け側では渡された値と、コンパイル時に作成した名前を用いて対を復元するようにした。この工夫によりキーワード引数を用いるメソッド呼び出しを、場合によっては10倍以上高速化することができた。今後も、実行速度を含む、Ruby処理系の品質向上を続けていきたい。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;Yet More Ruby Virtual Machines&lt;/h2&gt;

&lt;p&gt;This book explains the current architecture of YARV, which you might conclude
is the correct way of implementing Ruby. But, as I have explained in this
appendix so far, all of Ruby’s implementations, including YARV, are not much
different from any other software application: they are all developed through
trial and error by humans. While this book covers Ruby 2.0, we have already
made various improvements for Ruby 2.1. And we are working on even more
improvements that will make the forthcoming Ruby 2.2 even better.&lt;/p&gt;

&lt;p&gt;For example, keyword arguments will be more efficient. Chapter 4 explains the
implementation of keyword arguments. Quickly summarizing: Ruby first passes a
hash object containing keyword name and value pairs as a normal argument. Then,
at compile time, the receiver implicitly expands code that reads the values
from the argument hash. Users don’t seem to be complaining about its
performance for now. I assume keyword arguments are not widely used, because it
is a new feature introduced in Ruby 2.0. But this implementation is not
efficient. Hash objects are created every time, incurring object creation and
GC costs. Also, reading from Hash objects using the implicitly expanded code is
slow, because it involves multiple method calls.&lt;/p&gt;

&lt;p&gt;In order to address this problem, we are reimplementing how Ruby 2.2 handles
keyword arguments to avoid creating Hash objects as much as possible.
Meanwhile, we are implementing a new design that will collect the names of
keyword arguments at compile time, so that caller need only pass the values at
runtime. The callee will then recombine the values with the names collected
by the compiler. This design change will allow Ruby to process keyword
arguments 10 times faster. I would like to keep on improving the quality of
Ruby&amp;rsquo;s implementation, including runtime efficiency.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;p&gt;もし、本書によってYARV、そしてRuby処理系に興味を持ち、改良方法を思いついたら、ぜひ「さらにそのほかのRuby処理系」として実装し、試してほしい。Ruby処理系開発コミュニティは、あなたの挑戦を歓迎する。
&lt;br/&gt;
&lt;br/&gt;
2014年11月&lt;br/&gt;
笹田耕一&lt;br/&gt;
Heroku, Inc.
&lt;/div&gt;


&lt;p&gt;If you become interested in YARV and Ruby implementations after reading this
book, if you have ideas for improving them, I encourage you to develop your own
“Yet Another Ruby Implementation.” The Ruby core community will welcome your
challenge.&lt;/p&gt;

&lt;p&gt;November 2014&lt;br/&gt;
Koichi Sasada&lt;br/&gt;
Heroku, Inc.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Matz’s Foreword to Ruby Under a Microscope</title>
    <link href="http://patshaughnessy.net/2014/12/15/matzs-forward-to-ruby-under-a-microscope" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/12/15/matzs-forward-to-ruby-under-a-microscope</id>
    <published>2014-12-15T01:00:00Z</published>
    <updated>2014-12-15T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/15/rumja_cover.png"&gt;&lt;br/&gt;
  &lt;i&gt;&lt;a href="http://shop.ohmsha.co.jp/shopdetail/000000004065/"&gt;A Japanese translation&lt;/a&gt; of Ruby Under a&lt;br/&gt;Microscope was published last month.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Matz wrote a new foreword to &lt;a href="http://patshaughnessy.net/ruby-under-a-micros</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/15/rumja_cover.png"&gt;&lt;br/&gt;
  &lt;i&gt;&lt;a href="http://shop.ohmsha.co.jp/shopdetail/000000004065/"&gt;A Japanese translation&lt;/a&gt; of Ruby Under a&lt;br/&gt;Microscope was published last month.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Matz wrote a new foreword to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt;, which was
included in the Japanese version of the book published just last month. Today
I’d like to share a translation so everyone has a chance to read it. The
Japanese edition also includes a new appendix written by Koichi Sasada about
YARV, Ruby’s virtual machine. I’ll post a translation of that tomorrow.&lt;/p&gt;

&lt;p&gt;I love Matz’s sentiment about inspiring someone to work on Ruby… I hope that
might happen too. Thank you for writing this, Matz! You’ve already inspired so
many of us for years with your personality, your philosophy and with the
beautiful programming language you created.&lt;/p&gt;

&lt;p&gt;Japanese-language edition copyright &amp;copy; 2014 by Ohmsha, Ltd. Reproduced with
permission of the copyright owner.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;




&lt;div class="jp"&gt;
&lt;h2&gt;日本語版序文&lt;/h2&gt;
&lt;p class="jp"&gt;
私が小学生のときに読んで記憶に残っている一冊として、マーク・トウェインによる「アーサー王とあった男」&lt;sup&gt;*1&lt;/sup&gt;というSF作品があります。1880年代のアメリカ人がアーサー王時代にタイムスリップしてしまうものの、現代（出版当時）の知識を活用して活躍するというストーリーです。5世紀に電話や自転車、銃などの知識を持ち込めばさぞかし無敵でしょう。しかし、仮に21世紀の我々が5世紀にタイムスリップしたとして、我々の持っている知識をどれだけ活用することができるでしょう。自転車くらいならともかく、何もないところからコンピュータやネットワークを構築することなどできそうもありません。現代のテクノロジーは個人レベルで再現するには高度化しすぎています。普段はなにげなく使っている技術でも中身までは理解していないものです。
&lt;/p&gt;
&lt;/div&gt;




&lt;h2&gt;Foreword for Japanese Edition&lt;/h2&gt;


&lt;p&gt;The science fiction novel &lt;cite class="book"&gt;A Connecticut Yankee in King Arthur's
Court&lt;/cite&gt;&lt;sup&gt;*1&lt;/sup&gt; by Mark Twain is one of the books I still remember reading from my
elementary school days. It is the story of an American living in the 1880s who accidentally
time travels to King Arthur era England and nonetheless survives, taking
advantage of his knowledge from the modern (1880) era. Surely you would be very
powerful in the 5th century if you had knowledge of telephones, bicycles, and
guns.  But if we time travelled from the 21st century to the 5th century, how
much of our knowledge could we utilize?  Bicycles are okay, but how about
computers? It seems almost impossible to build computers and networks from
scratch ourselves.  Modern technology products are too advanced for individuals
to reproduce. We don't know how technologies work even when we use them in our
everyday lives.&lt;/p&gt;




&lt;div class="jp"&gt;
&lt;p&gt;
私たちが普段使っているRubyもそのような現代テクノロジーのひとつです。Rubyを便利に使っていても、その中がどうなっていて、どのように実行されているのか、あるいはRubyのような言語をどうすれば再現できるのか正確な知識を持っている人はほとんどいないでしょう。本書はそのような謎に包まれている「Rubyの中身」を明らかにしてくれる一冊です。
&lt;/p&gt;
&lt;p&gt;
本書はRubyのソフトウェア構造から、オブジェクトシステムの構成、性能を向上させるための工夫まで解説されています。さらにCRubyだけでなく、JRubyやRubiniusについてまでカバーしています。このような知識を学べる書籍はなかなかありません。日本には類書として「Rubyソースコード完全解説」&lt;sup&gt;*2&lt;/sup&gt;がありますが、入手困難になって久しいですし、対象のRubyバージョンも1.7と古いので、YARVのような新しい技術については当然解説されていません。このような書物の登場は、Rubyの内部知識の一般化に貢献すると信じます。
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Ruby is one such technology. Even though we use it every day, not many of us
seem to know what it looks like on the inside, how it runs internally, or how
one could recreate such a programming language. This book sheds light on this and
reveals the mystery of Ruby internals.&lt;/p&gt;

&lt;p&gt;This book explains the software architecture of Ruby, the structure of its
object system, and tips for performance improvement. In addition to that, it
covers not only CRuby but also JRuby and Rubinius as well. I know of few books
where you can find this type of knowledge. Though we have the &lt;cite
class="book"&gt;Ruby Hacking Guide&lt;/cite&gt;&lt;sup&gt;*2&lt;/sup&gt; in Japan, it&amp;rsquo;s been
difficult to obtain a copy for a long time. It explains a version of Ruby as
old as 1.7 and naturally does not cover newer technologies like YARV. I believe
RUM will contribute to a wider understanding of Ruby internals.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;p&gt;
本書の知識をもとにして、もしかすると本書の読者のうちの誰か、もしかするとあなたがRubyの開発に関わるようになるかもしれませんし、そうなれば我々は大歓迎します。あるいは、次世代の言語処理系を開発するきっかけになるかもしれません。そのような未来が見たいものです。
&lt;/p&gt;
&lt;p&gt;
&lt;br/&gt;
2014年10月、松江にて&lt;br/&gt;
まつもと ゆきひろ
&lt;/p&gt;
&lt;br/&gt;
&lt;hr align="left"/&gt;
&lt;small&gt;*1 マーク・トウェーン作、亀山龍樹訳「アーサー王とあった男」（岩崎書店、1971）&lt;br/&gt;
*2 青木峰郎著「Rubyソースコード完全解説」（インプレス、2002）&lt;/small&gt;
&lt;/div&gt;


&lt;p&gt;In the future someone inspired by this book may join the development of Ruby.
It may be you. We will definitely welcome that. Or, he/she may begin creating a
next generation programming language. I hope to see that happen.&lt;/p&gt;

&lt;p&gt;In Matsue, October 2014&lt;br/&gt;
Yukihiro Matsumoto&lt;/p&gt;

&lt;br/&gt;


&lt;hr align="left"/&gt;


&lt;p&gt;&lt;small&gt;*1 Twain, Mark, A Connecticut Yankee in King Arthur’s Court. (Kameyama Nagarjuna translation, Iwasaki Bookstore, 1971)&lt;br/&gt;
*2 Aoki Minero al., Ruby Hacking Guide. (Impress, 2002)&lt;/small&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Discovering the Computer Science Behind Postgres Indexes</title>
    <link href="http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes</id>
    <published>2014-11-11T01:00:00Z</published>
    <updated>2014-11-11T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/engineering-plans.png"&gt;&lt;br/&gt;
  &lt;i&gt; Captain Nemo and Professor Aronnax discussing the&lt;br/&gt;engineering and science behind
  the Nautilus.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;&lt;b&gt; This is the last post in a series based on a
  presentation I did at the &lt;a href="http://www.baruco.org"&gt;Barcelona</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/engineering-plans.png"&gt;&lt;br/&gt;
  &lt;i&gt; Captain Nemo and Professor Aronnax discussing the&lt;br/&gt;engineering and science behind
  the Nautilus.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;&lt;b&gt; This is the last post in a series based on a
  presentation I did at the &lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt;
  called “20,000 Leagues Under ActiveRecord.” (other posts:
  &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;one&lt;/a&gt;
  &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;two&lt;/a&gt;
  &lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;three&lt;/a&gt;
  and &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).  &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;We all know indexes are one of the most powerful and important features of
relational database servers. How do you search for a value quickly? Create an
index. What do you have to remember to do when joining two tables together?
Create an index. How do you speed up a SQL statement that’s beginning to run
slowly? Create an index.&lt;/p&gt;

&lt;p&gt;But what are indexes, exactly? And &lt;em&gt;how&lt;/em&gt; do they speed up our database searches?
To find out, I decided to read the C source code inside the PostgreSQL database
server, to follow along as it searched an index for a simple string value. I
expected to find sophisticated algorithms and efficient data structures. And I
did. Today I’ll show you what indexes look like inside Postgres and explain how
they work.&lt;/p&gt;

&lt;p&gt;What I didn’t expect to find &amp;ndash; what I discovered for the first time reading the
Postgres C source code &amp;ndash; was the Computer Science theory behind what it was
doing. Reading the Postgres source was like going back to school and taking
that class I never had time for when I was younger. The C comments inside
Postgres not only explain what Postgres does, but &lt;em&gt;why&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Sequence Scans: A Mindless Search&lt;/h2&gt;

&lt;p&gt;When we left the crew of the Nautilus, they were exhausted and beginning to
faint: the Postgres sequence scan algorithm was mindlessly looping over all of
the records in the users table! Recall in &lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;my last
post&lt;/a&gt;
we had executed this simple SQL statement to find Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/select-users.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres first parsed, analyzed and planned the query. Then
&lt;a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html#af80d84501ff7621d2ef6249b148e7f44"&gt;ExecSeqScan&lt;/a&gt;,
the C function inside of Postgres that implements the sequence scan (SEQSCAN)
plan node, quickly found Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan4.png"/&gt;&lt;/p&gt;

&lt;p&gt;But then inexplicably Postgres continued to loop through the entire user table,
comparing each name to “Captain Nemo,” even though we had already found what we
were looking for!&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan5.png"/&gt;&lt;/p&gt;

&lt;p&gt;Imagine if our users table had millions of records; this could take a very long
time. Of course, we could have avoided this by removing the sort and rewriting
our query to accept the first name, but the deeper problem here is the
inefficient way Postgres searches for our target string. Using a sequence scan
to compare every single value in the users table with “Captain Nemo” is slow,
inefficient and depends on the random order the names appear in the table. What
are we doing wrong? There must be a better way!&lt;/p&gt;

&lt;p&gt;The answer is simple: We forgot to create an Index. Let’s do that now.&lt;/p&gt;

&lt;h2&gt;Creating an Index&lt;/h2&gt;

&lt;p&gt;Creating an index is straightforward &amp;ndash; we just need to run this command:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/create-index.png"/&gt;&lt;/p&gt;

&lt;p&gt;As Ruby developers, of course, we would use the &lt;span class="code"&gt;add_index&lt;/span&gt; ActiveRecord
migration instead; this would run the same &lt;span class="code"&gt;CREATE INDEX&lt;/span&gt; command behind the
scenes. When we rerun our select statement, Postgres will create a plan tree as usual &amp;ndash;
but this time the plan tree will be slightly different:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/11/11/indexscan-plan.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice at the bottom Postgres now uses INDEXSCAN instead of SEQSCAN. Unlike
SEQSCAN, INDEXSCAN won’t iterate over the entire users table. Instead, it will
use the index we just created to find and return the Captain Nemo records
quickly and efficiently.&lt;/p&gt;

&lt;p&gt;Creating an index has solved our performance problem, but it’s also left us with many interesting, unanswered questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;What&lt;/em&gt; is a Postgres index, exactly?&lt;/li&gt;
&lt;li&gt;If I could go inside of a Postgres database and take a close look at an index, &lt;em&gt;what would it look like&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;And &lt;em&gt;how&lt;/em&gt; does an index speed up searches?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Let’s try to answer these questions by reading the Postgres C source code.&lt;/p&gt;

&lt;h2&gt;What Is a Postgres Index, Exactly?&lt;/h2&gt;

&lt;p&gt;We can get started with a look at the
&lt;a href="http://www.postgresql.org/docs/9.3/static/sql-createindex.html"&gt;documentation&lt;/a&gt;
for the CREATE INDEX command.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/documentation.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see all of the options we can use to create an index, such as
&lt;span class="code"&gt;UNIQUE&lt;/span&gt; and &lt;span class="code"&gt;CONCURRENTLY&lt;/span&gt;. Notice there’s an option called &lt;span class="code"&gt;USING method&lt;/span&gt;. This
tells Postgres what kind of index we want. Farther down the same page is some
information about &lt;span class="code"&gt;method&lt;/span&gt;, the argument to the &lt;span class="code"&gt;USING&lt;/span&gt; keyword:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/method.png"/&gt;&lt;/p&gt;

&lt;p&gt;It turns out Postgres implements four different types of indexes. You can use
them for different types of data and in different situations. Because we didn’t
specify &lt;span class="code"&gt;USING&lt;/span&gt; at all, our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index is a “btree” (or B-Tree) index,
the default type.&lt;/p&gt;

&lt;p&gt;This is our first clue: a Postgres index is a B-Tree. But what is a B-Tree?
Where can we find one? Inside of Postgres, of course! Let’s search the Postgres
C source code for files containing “btree:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/find.png"/&gt;&lt;/p&gt;

&lt;p&gt;The key result is in bold: “./backend/access/nbtree.” Inside this directory is
a README file; let’s read it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/readme.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/atlantis.png"&gt;&lt;br/&gt;
  &lt;i&gt;Nemo found the lost continent of Atlantis&lt;br/&gt;next to an underwater
  volcano.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Amazingly, this README file turns out to be an extensive 12 page document! The
Postgres source code not only contains helpful and interesting C comments, it
also contains documentation about the theory and implementation of the database
server. Reading and understanding the code in open source projects can often be
intimidating and difficult, but not for Postgres. The developers behind
Postgres have gone to great lengths to help the rest of us understand their
work.&lt;/p&gt;

&lt;p&gt;The title of the README document, “Btree Indexing,” confirms this directory
contains the C code that implements Postgres B-Tree indexes. But the first
sentence is even more interesting: it’s a reference to an academic paper that
explains what a B-Tree is, and how Postgres indexes work: &lt;a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf"&gt;Efficient Locking for
Concurrent Operations on B-Trees&lt;/a&gt;, by Lehman and Yao.&lt;/p&gt;

&lt;p&gt;We’ll find our first look at a B-Tree inside this academic paper.&lt;/p&gt;

&lt;h2&gt;What Does a B-Tree Index Look Like?&lt;/h2&gt;

&lt;p&gt;Lehman and Yao’s paper explains an innovation they made to the B-Tree algorithm
in 1981. I’ll discuss this a bit later. But they start with a simple
introduction to the B-Tree data structure, which was actually invented 9 years
earlier in 1972. One of their diagrams shows an example of a simple B-Tree:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/11/11/figure2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The term B-Tree actually stands for “balanced tree.” B-Trees make searching
easy and fast. For example, if we wanted to search for the value 53 in this
example, we first start at the root node which contains the value 40:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node1.png"/&gt;&lt;/p&gt;

&lt;p&gt;We compare our target value of 53 with the value we find in the tree node. Is
53 greater than or less than 40? Because 53 is greater than 40 we follow the
pointer down to the right. If we were searching for 29, we would go down to the
left. Pointers on the right lead to larger values; pointers on the left to
smaller ones.&lt;/p&gt;

&lt;p&gt;Following the pointer down the tree to the next child tree node, we encounter a
node that contains 2 values:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node2.png"/&gt;&lt;/p&gt;

&lt;p&gt;This time we compare 53 with both 47 and 62, and find that 47 &amp;lt; 53 &amp;lt; 62. Note
the values in the tree node are sorted, so this will be easy to do. This time
we follow the center pointer down.&lt;/p&gt;

&lt;p&gt;Now we get to another tree node, this one with 3 values in it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node3.png"/&gt;&lt;/p&gt;

&lt;p&gt;Looking through the sorted list of numbers, we find 51 &amp;lt; 53 &amp;lt; 56, and follow
the second of four pointers down.&lt;/p&gt;

&lt;p&gt;Finally, we come to a leaf node in the tree:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node4.png"/&gt;&lt;/p&gt;

&lt;p&gt;And we’ve found the value 53!&lt;/p&gt;

&lt;p&gt;B-Trees speed up searches because:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They sort the values (known as &lt;em&gt;keys&lt;/em&gt;) inside of each node.&lt;/li&gt;
&lt;li&gt;They are &lt;em&gt;balanced&lt;/em&gt;: B-Trees evenly distribute the keys among the nodes,
minimizing the number of times we have to follow a pointer from one node to
another. Each pointer leads to a child node that contains more or less the
same number of keys each other child node does.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;What Does a Postgres Index Look Like?&lt;/h2&gt;

&lt;p&gt;Lehman and Yao drew this diagram over 30 years ago &amp;ndash; what does it have to do
with how Postgres works today? Astonishingly, the &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index we created earlier looks very
similar to Figure 2: We created an index in 2014 that looks just like a diagram
from 1981!&lt;/p&gt;

&lt;p&gt;When we executed the &lt;span class="code"&gt;CREATE INDEX&lt;/span&gt; command, Postgres
saved all of the names from our users table into a B-Tree. These became the
keys of the tree. Here’s what a node inside a Postgres B-Tree index looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Each entry in the index consists of a C structure called &lt;span class="code"&gt;IndexTupleData&lt;/span&gt;, and is
followed by a bitmap and a value. Postgres uses the bitmap to record whether
any of the index attributes in a key are NULL, to save space. The actual values
in the index appear after the bitmap.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at the &lt;span class="code"&gt;IndexTupleData&lt;/span&gt;
structures:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see each IndexTupleData structure contains:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class="code"&gt;t_tid&lt;/span&gt;: This is a pointer to either another index
tuple, or to a database record. Note this isn&amp;rsquo;t a C pointer to physical
memory; instead, it contains numbers Postgres can use to find the referenced
value among its memory pages.&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;t_info&lt;/span&gt;: This contains information about the index
tuple, such as how many values it contains, and whether or not there are null
values.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To understand this better, let’s show a few entries from our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Now I’ve replaced “value” with some names from my users table. The upper tree
node includes the keys “Dr. Edna Kunde” and “Julius Powlowski,” while the lower
tree node contains “Julius Powlowski” and “Juston Quitzon.” Notice that, unlike
Lehman and Yao’s diagram, Postgres repeats the parent keys in each child node.
Here “Julius Powlowski” is a key in the upper node and in the child node. The
&lt;span class="code"&gt;t_tid&lt;/span&gt; pointer from Julius in the upper node
references the same Julius name in the lower node.&lt;/p&gt;

&lt;p&gt;To learn more about exactly how Postgres stores key values into a B-Tree node,
refer to the itup.h C header file:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;IndexTupleData&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/itup_8h_source.html"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/itup.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Finding the B-Tree Node Containing Captain Nemo&lt;/h2&gt;

&lt;p&gt;Now let’s return to our original SELECT statement again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/select-users.png"/&gt;&lt;/p&gt;

&lt;p&gt;How exactly does Postgres search our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index for “Captain Nemo?” Why is
using the index faster than the sequence scan we saw in my last post? To find
out, let’s zoom out a bit and take a look at some of the user names in our
index:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/root-names1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;This is the root node of the &lt;span class="code"&gt;index_users_on_name&lt;/span&gt;
B-Tree. I’ve turned the tree on its side so the names would fit. You can see 4
names and a NULL value. Postgres created this root node when I created
&lt;span class="code"&gt;index_users_on_name&lt;/span&gt;. Note that, aside from the
first NULL value which represents the beginning of the index, the other 4 names
are more or less evenly distributed in alphabetical order.&lt;/p&gt;

&lt;p&gt;Remember that a B-Tree is a balanced tree. In this example, the B-Tree has 5 child nodes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the names that appear before Dr. Edna Kunde alphabetically&lt;/li&gt;
&lt;li&gt;names that appear between Dr. Edna Kunde and Julius Powlowski&lt;/li&gt;
&lt;li&gt;names that appear between Julius Powlowski and Monte Nicolas&lt;/li&gt;
&lt;li&gt;etc…&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Because we’re searching for Captain Nemo, Postgres follows the first, top arrow
to the right. This is because Captain Nemo comes before Dr. Edna Kunde
alphabetically:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/root-names2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;You can see on the right that Postgres has found the B-Tree node that contains
Captain Nemo. For my test I added 1000 names to the users table; this child
node in the B-Tree contained about 200 names (240 actually). The B-Tree has
narrowed down Postgres’s search considerably.&lt;/p&gt;

&lt;p&gt;To learn more about the precise algorithm Postgres uses to search for the
target B-Tree node among all of the nodes in the tree, read the &lt;span
class="code"&gt;_bt_search&lt;/span&gt; function.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;_bt_search&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nbtsearch_8c.html#a9053c37f2c25187580f3f690ad41bf01"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/bt_search.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Finding Captain Nemo Inside a Single B-Tree Node&lt;/h2&gt;

&lt;p&gt;Now that Postgres has narrowed down the search to a B-Tree node containing
about 200 names, it still has to find Captain Nemo… how does it do this? Does
it perform a sequence scan on this shorter list?&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;No. To search for a key value inside of a tree node, Postgres switches to use a
binary search algorithm. It starts by comparing the key that appears at the 50%
position in the tree node with “Captain Nemo:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Because Captain Nemo comes after Breana Witting alphabetically, Postgres
jumps down to the 75% position and performs another comparison:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;This time Captain Nemo comes before Curtis Wolf, so Postgres jumps back a bit.
Skipping a few more steps (it actually took Postgres 8 comparisons to find
Captain Nemo in my example), Postgres eventually finds what we are looking for:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search4.svg"/&gt;&lt;/p&gt;

&lt;p&gt;To learn more about exactly how Postgres searches for a value in a single
B-Tree node, read the &lt;span class="code"&gt;_bt_binsrch&lt;/span&gt; function:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;_bt_binsrch&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nbtsearch_8c.html#acd3770ac6d3bc26d6f319d3255721280"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/bt_binsrch.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;So Much More to Learn&lt;/h2&gt;

&lt;p&gt;I don’t have space in this blog post to cover many other fascinating details
about B-Trees, database indexes or Postgres internals… maybe I should write
&lt;em&gt;Postgres Under a Microscope&lt;/em&gt; :) But for now, here are just a few interesting
bits of theory you can read about in &lt;a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf"&gt;Efficient Locking for Concurrent
Operations on B-Trees&lt;/a&gt; or in
the other academic papers it references.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Inserting into B-Trees: The most beautiful part of the B-Tree algorithm has
to do with inserting new keys into a tree. Key are inserted in sorted order
into the proper tree node &amp;ndash; but what happens when there’s no more room for a
new key? In this situation, Postgres splits the node into two, inserts the
new key into one of them, and also adds the key from the split point into the
parent node, along with a pointer to the new child node. Of course, the
parent node might also have to be split to fit its new key, resulting in a
complex, recursive operation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Deleting from B-Trees: The converse operation is also interesting. When
deleting a key from a node, Postgres will combine sibling nodes together when
possible, removing a key from their parent. This can also be a recursive
operation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B-Link-Trees: Lehman and Yao’s paper actually discusses an innovation they
researched related to concurrency and locking when multiple threads are using
the same B-Tree. Remember, Postgres’s code and algorithms need to be
multithreaded because many clients could be searching or modifying the same
index at the same time. By adding another pointer from each B-Tree node to
the next sibling node &amp;ndash; the so-called “right arrow” &amp;ndash; one thread can search a
tree even while a second thread is splitting a node without locking the
entire index:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/right-arrow.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Don’t Be Afraid To Explore Beneath The Surface&lt;/h2&gt;

&lt;div style="float: right; padding: 22px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/at-the-helm.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo at the helm&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Professor Aronnax risked his life and career to find the elusive Nautilus and
to join Captain Nemo on a long series of amazing underwater adventures. We
should do the same: Don’t be afraid to dive underwater &amp;ndash; inside and underneath
the tools, languages and technologies that you use every day. You may know all
about how to use Postgres, but do you really know how Postgres itself works
internally? Take a look inside; before you know it, you’ll be on an underwater
adventure of your own.&lt;/p&gt;

&lt;p&gt;Studying the Computer Science at work behind the scenes of our applications
isn’t just a matter of having fun, it’s part of being a good developer. As
software development tools improve year after year, and as building web sites
and mobile apps becomes easier and easier, we shouldn’t loose sight of the
Computer Science we depend on. We’re all standing on the shoulders of giants &amp;ndash;
people like Lehman and Yao, and the open source developers who used their
theories to build Postgres. Don’t take the tools you use everyday for granted &amp;ndash;
take a look inside them! You’ll become a wiser developer and you’ll find
insights and knowledge you could never have imagined before.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Following a Select Statement Through Postgres Internals</title>
    <link href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals</id>
    <published>2014-10-13T00:00:00Z</published>
    <updated>2014-10-13T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/engine-room.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax on a tour&lt;br/&gt;of the engine room, a fascinating description&lt;br/&gt;of future technology from an 1870 perspective.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the third of a series of posts based on a presentation I did at the</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/engine-room.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax on a tour&lt;br/&gt;of the engine room, a fascinating description&lt;br/&gt;of future technology from an 1870 perspective.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the third of a series of posts based on a presentation I did at the
&lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt; called “20,000 Leagues Under
ActiveRecord.” (posts:
&lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;one&lt;/a&gt;
&lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;two&lt;/a&gt;
and &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).  &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Preparing for this presentation over the Summer, I decided to read through
parts of the PostgreSQL C source code. I executed a very simple select
statement and watched what Postgres did with it using LLDB, a C debugger. How
did Postgres understand my query? How did it actually find the data I was
looking for?&lt;/p&gt;

&lt;p&gt;This post is an informal journal of my trip through the guts of Postgres. I’ll
describe the path I took and what I saw along the way. I’ll use a series of
simple, conceptual diagrams to explain how Postgres executed my query.
In case you understand C, I’ll also leave you a few landmarks and signposts you
can look for if you ever decide to hack on Postgres internals.&lt;/p&gt;

&lt;p&gt;In the end, the Postgres source code delighted me. It was clean, well
documented and easy to follow. Find out for yourself how Postgres works
internally by following me on a journey deep inside a tool you use everyday.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;


&lt;h2&gt;Finding Captain Nemo&lt;/h2&gt;

&lt;p&gt;Here’s the example query from &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;the first half of my
presentation&lt;/a&gt;;
we’ll follow Postgres as it searches for Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/sql.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/maps.png"&gt;&lt;br/&gt;
  &lt;i&gt;Professor Aronnax and Captain Nemo&lt;br/&gt;plot the course of the Nautilus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Finding a single name in string column like this should be straightforward,
shouldn’t it? We’ll hold tightly onto this select statement while we explore
Postgres internals, like a rope deep sea divers use to find their way back to
the surface.&lt;/p&gt;

&lt;h2&gt;The Big Picture&lt;/h2&gt;

&lt;p&gt;What does Postgres do with this SQL string? How does it understand what we
meant? How does it know what data we are looking for?&lt;/p&gt;

&lt;p&gt;Postgres processes each SQL command we send it using a four step process.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/4-steps.png"/&gt;&lt;/p&gt;

&lt;p&gt;In the first step, Postgres &lt;em&gt;parses&lt;/em&gt; our SQL statement and converts it into a
series of C memory structures, a &lt;em&gt;parse tree&lt;/em&gt;. Next Postgres &lt;em&gt;analyzes and
rewrites&lt;/em&gt; our query, optimizing and simplifying it using a series of complex
algorithms. After that, Postgres generates a &lt;em&gt;plan&lt;/em&gt; for finding our data. Like
an obsessive compulsive person who won’t leave home without every suitcase
packed perfectly, Postgres doesn’t run our query until it has a plan. Finally,
Postgres actually &lt;em&gt;executes&lt;/em&gt; our query. In this presentation I’ll briefly touch
on the first three topics, and then focus more on the last step: &lt;em&gt;Execute&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The C function inside of Postgres that implements this 4 step process is called
&lt;span class="code"&gt;exec_simple_query&lt;/span&gt;. You can find a link to it below, along with an LLDB
backtrace which gives some context about exactly when and how Postgres calls
&lt;span class="code"&gt;exec_simple_query&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;exec_simple_query&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a7908e75bd9f9494fdb8c4b47f01a9de9"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_simple_query.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_simple_query_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Parse&lt;/h2&gt;

&lt;p&gt;How does Postgres understand the SQL string we sent it? How does it make sense
of the SQL keywords and expressions in our select statement? Through a process
called &lt;em&gt;parsing&lt;/em&gt;, Postgres converts our SQL string into an internal data
structure it understands, the parse tree.&lt;/p&gt;

&lt;p&gt;It turns out that Postgres uses the same parsing technology that Ruby does, a
&lt;em&gt;parser generator&lt;/em&gt; called &lt;a href="http://www.gnu.org/software/bison/"&gt;Bison&lt;/a&gt;. Bison
runs during the Postgres C build process and generates parser code based on a
series of grammar rules. The generated parser code is what runs inside of
Postgres when we send it SQL commands. Each grammar rule is triggered when the
generated parser finds a corresponding pattern or syntax in the SQL string,
and inserts a new C memory structure into the parse tree data structure.&lt;/p&gt;

&lt;p&gt;I won’t take the time today to explain how parsing algorithms work in detail.
If you’re interested in that sort of thing, I’d suggest taking a look at my
book &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt;. In Chapter One
I go through a detailed example of the LALR parse algorithm used by Bison and
Ruby. Postgres parses SQL statements in exactly the same way.&lt;/p&gt;

&lt;p&gt;Using LLDB and enabling some C logging code, I observed the Postgres parser
produce this parse tree for our Captain Nemo query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/parse-tree.png"/&gt;&lt;/p&gt;

&lt;p&gt;At the top is a node representing the entire SQL statement, and below that are
child nodes or branches that represent the different portions of the SQL
statement syntax: the target list (a list of columns), the from clause (a list
of tables), the where clause, the sort order and a limit count.&lt;/p&gt;

&lt;p&gt;If you want to learn more about how Postgres parses SQL statements, follow the
flow of control down from &lt;span class="code"&gt;exec_simple_query&lt;/span&gt; through
another C function called &lt;span class="code"&gt;pg_parse_query&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;pg_parse_query&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a0449a974d1a66a2fcdee8896a0690521"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_parse_query.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_parse_query_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;As you can see there are many helpful and detailed comments in the Postgres
source code that not only explain what is happening but also point out important
design decisions.&lt;/p&gt;

&lt;h2&gt;All That Hard Work For Nothing&lt;/h2&gt;

&lt;p&gt;The parse tree above should look familiar &amp;ndash; it’s almost precisely the same as
the abstract syntax tree (AST) we saw ActiveRecord create earlier. Recall from
the &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;first half of the
presentation&lt;/a&gt;
ActiveRecord generated our Captain Nemo select statement when we executed this
Ruby query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/example1.png"/&gt;&lt;/p&gt;

&lt;p&gt;We saw that ActiveRecord internally created an AST when we called methods such
as &lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;first&lt;/span&gt;. Later
(see the &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;second
post&lt;/a&gt;),
we watched as the Arel gem converted the AST into our example select statement
using an algorithm based on the visitor pattern.&lt;/p&gt;

&lt;p&gt;Thinking about this, it’s ironic that the first thing Postgres does with your
SQL statement is convert it from a string back into an AST. Postgres’s parse
process reverses everything ActiveRecord did earlier; all of that hard work the
Arel gem did was for nothing! The only reason for creating the SQL string at
all was to communicate with Postgres over a network connection. Once Postgres
has the string, it converts it back into an AST, which is a much more
convenient and useful way of representing queries.&lt;/p&gt;

&lt;p&gt;Learning this you might ask: Is there a better way? Is there some way of
conceptually specifying the data we want to Postgres without writing a SQL
statement? Without learning the complex SQL language or paying the performance
overhead of using ActiveRecord and Arel? It seems like a waste of time to go to
such lengths to generate a SQL string from an AST, just to convert it back to
an AST again. Maybe we should be using a NoSQL database solution instead?&lt;/p&gt;

&lt;p&gt;Of course, the AST Postgres uses is much different from the AST used by
ActiveRecord. ActiveRecord’s AST was comprised of Ruby objects, while
Postgres’s AST is formed of a series of C memory structures. Same idea but very
different implementations.&lt;/p&gt;

&lt;h2&gt;Analyze and Rewrite&lt;/h2&gt;

&lt;p&gt;Once Postgres has generated a parse tree, it then converts it into a another
tree structure using a different set of nodes. This is known as the &lt;em&gt;query
tree&lt;/em&gt;. Returning to the &lt;span class="code"&gt;exec_simple_query&lt;/span&gt; C
function, you can see it next calls another C function &lt;span
class="code"&gt;pg_analyze_and_rewrite&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;pg_analyze_and_rewrite&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a66930c41c305d22f3371cad134fd3dee"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_analyze_and_rewrite.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_analyze_and_rewrite_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;Waving my hands a bit and glossing over many important details, the analyze and
rewrite process applies a series of sophisticated algorithms and heuristics to
try to optimize and simplify your SQL statement. If you had executed a complex
select statement with sub-selects and multiple inner and outer joins, then
there is a lot of room for optimization. It’s quite possible that Postgres
could reduce the number of sub-select clauses or joins to produce a simpler
query that runs faster.&lt;/p&gt;

&lt;p&gt;For our simple select statement, here’s the query tree that &lt;span
class="code"&gt;pg_analyze_and_rewrite&lt;/span&gt; produces:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/query-tree.png"/&gt;&lt;/p&gt;

&lt;p&gt;I don’t pretend to understand the detailed algorithms behind &lt;span
class="code"&gt;pg_analyze_and_rewrite&lt;/span&gt;. I simply observed that for our
example the query tree largely resembled the parse tree. This means the
select statement was so straightforward Postgres wasn’t able to simplify it further.&lt;/p&gt;

&lt;h2&gt;Plan&lt;/h2&gt;

&lt;p&gt;The last step Postgres takes before starting to execute our query is to create
a plan. This involves generating a third tree of nodes that form a list of
instructions for Postgres to follow. Here’s the plan tree for our select
statement.&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/plan-tree.png"/&gt;&lt;/p&gt;

&lt;p&gt;Imagine that each node in the plan tree is a machine or worker of some
kind. The plan tree resembles a pipeline of data or a conveyor belt in a
factory. In my simple example there is only one branch in the tree. Each node
in the plan tree takes some the output data from the node below, processes it,
and returns results as input to the node above. We’ll follow Postgres as it
executes the plan in the next section.&lt;/p&gt;

&lt;p&gt;The C function that starts the query planning process is called &lt;span
class="code"&gt;pg_plan_queries&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;pg_plan_queries&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a34e18d3874224b3b670ec0a3ae9c970c"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_plan_queries.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_plan_queries_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;Note the &lt;span class="code"&gt;startup_cost&lt;/span&gt; and &lt;span
class="code"&gt;total_cost&lt;/span&gt; values in each plan node. Postgres uses these
values to estimate how long the plan will take to complete. You don’t have
to use a C debugger to see the execution plan for your query. Just prepend the
SQL &lt;span class="code"&gt;EXPLAIN&lt;/span&gt; command to your query, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/explain.png"/&gt;&lt;/p&gt;

&lt;p&gt;This is a powerful way to understand what Postgres is doing internally with one
of your queries, and why it might be slow or inefficient &amp;ndash; despite the
sophisticated planning algorithms in &lt;span class="code"&gt;pg_plan_queries&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Executing a Limit Plan Node&lt;/h2&gt;

&lt;p&gt;By now, Postgres has parsed your SQL statement and converted it back into an
AST. Then it optimized and rewrote your query, possibly in a simpler way.
Third, Postgres wrote a plan which it will follow to find and return the data
you are looking for. Finally it’s time for Postgres to actually execute your
query. How does it do this? It follows the plan, of course!&lt;/p&gt;

&lt;p&gt;Let’s start at the top of the plan tree and move down. Skipping the root node,
the first worker that Postgres uses for our Captain Nemo query is called Limit.
The Limit node, as you might guess, implements the &lt;span
class="code"&gt;LIMIT&lt;/span&gt; SQL command, which limits the result set to the
specified number of records. The same plan node also implements the &lt;span
class="code"&gt;OFFSET&lt;/span&gt; command, which starts the result set window at the
specified row.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/limit1.png"/&gt;&lt;/p&gt;

&lt;p&gt;The first time Postgres calls the Limit node, it calculates what the limit and
offset values should be, because they might be set to the result of some
dynamic calculation. In our example, offset is 0 and limit is 1.&lt;/p&gt;

&lt;p&gt;Next, the Limit plan node repeatedly calls the subplan, in our case Sort,
counting until it reaches the offset value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/limit2.png"/&gt;&lt;/p&gt;

&lt;p&gt;In our example the offset value is zero, so this loop will load the first data
value and stop iterating. Then Postgres returns the last data value loaded from
the subplan to the calling or upper plan. For us, this will be that first value
from the subplan.&lt;/p&gt;

&lt;p&gt;Finally when Postgres continues to call the Limit node, it will pass the data
values through from the subplan one at a time:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/limit3.png"/&gt;&lt;/p&gt;

&lt;p&gt;In our example, because the limit value is 1 Limit will immediately return NULL
indicating to the upper plan there is no more data available.&lt;/p&gt;

&lt;p&gt;Postgres implements the Limit node using code in a file called nodeLimit.c&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecLimit&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeLimit_8c.html#a9fe32874f36f4a955f5b4b762d814631"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_limit.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_limit_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;You can see the Postgres source code uses words such as &lt;em&gt;tuple&lt;/em&gt; (a set a
values, one from each column) and &lt;em&gt;subplan&lt;/em&gt;. The subplan in this example is the
Sort node, which appears below Limit in the plan.&lt;/p&gt;

&lt;h2&gt;Executing a Sort Plan Node&lt;/h2&gt;

&lt;p&gt;Where do the data values Limit filters come from? From the Sort plan node
that appears under Limit in the plan tree. Sort loads data values from its
subplan and returns them to its calling plan, Limit. Here’s what Sort does when
the Limit node calls it for the first time, to get the first data value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/sort1.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see that Sort functions very differently from Limit. It immediately
loads all of the available data from the subplan into a buffer, before
returning anything. Then it sorts the buffer using the
&lt;a href="http://en.wikipedia.org/wiki/Quicksort"&gt;Quicksort&lt;/a&gt; algorithm, and finally
returns the first sorted value.&lt;/p&gt;

&lt;p&gt;For the second and subsequent calls, Sort simply returns additional values from
the sorted buffer, and never needs to call the subplan again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/sort2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The Sort plan node is implemented by a C function called ExecSort:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecSort&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeSort_8c.html#afe145ec8ff9b3d3a654022f73eab2810"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_sort.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_sort_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Executing a SeqScan Plan Node&lt;/h2&gt;

&lt;p&gt;Where does ExecSort get its values? From its subplan, or the SeqScan node that
appears at the bottom of the plan tree. SeqScan stands for &lt;em&gt;sequence scan&lt;/em&gt;, which
means to look through the values in a table, returning values that match a
given filter. To understand how the scan works with our filter, let’s step
through an imaginary users table filled with fake names, looking for Captain
Nemo.&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres starts at the first record in a table (known as a &lt;em&gt;relation&lt;/em&gt; in the
Postgres source code) and executes the boolean expression from the plan tree.
In simple terms, Postgres asks the question: “Is this Captain Nemo?” Because
Laurianne Goodwin is not Captain Nemo, Postgres steps down to the next record.&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan2.png"/&gt;&lt;/p&gt;

&lt;p&gt;No, Candace is also not Captain Nemo. Postgres continues:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan3.png"/&gt;&lt;/p&gt;

&lt;p&gt;… and eventually finds Captain Nemo!&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres implements the SeqScan node using a C function called ExecSeqScan.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecSeqScan&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html#af80d84501ff7621d2ef6249b148e7f44"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_seq_scan.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_seq_scan_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;What Are We Doing Wrong?&lt;/h2&gt;

&lt;p&gt;Now we’re done! We’ve followed a simple select statement all the way through
the guts of Postgres, and have seen how it was parsed, rewritten, planned and finally
executed. After executing many thousands of lines of C code, Postgres has found the
data we are looking for! Now all Postgres has to do is return the Captain Nemo
string back to our Rails application and ActiveRecord can create a Ruby object.
We can finally return to the surface of our application.&lt;/p&gt;

&lt;p&gt;But Postgres doesn’t stop! Instead of simply returning, Postgres continues to
scan through the users table, even though we’ve already found Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan5.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 117px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/suffocating.png"&gt;&lt;br/&gt;
  &lt;i&gt;While returning from the South Pole, the air&lt;br/&gt; supply inside the Nautilus began to run out.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;What’s going on here? Why is Postgres wasting its time, continuing to search
even though it’s already found the data we’re looking for?&lt;/p&gt;

&lt;p&gt;The answer lies farther up the plan tree in the Sort node. Recall that in order
to sort all of the users, ExecSort first loads all of the values into a buffer,
by calling the subplan repeatedly until there are no values left. That means
that &lt;em&gt;ExecSeqScan will continue to scan to the end of the table&lt;/em&gt;, until it has
all of the matching users. If our users table contained thousands or even
millions of records (imagine we work at Facebook or Twitter), ExecSeqScan will
have to loop over every single user record and execute the string comparison
for each one. This is obviously inefficient and slow, and will get slower as
more and more user records are added.&lt;/p&gt;

&lt;p&gt;If we have only one Captain Nemo record, then ExecSort will “sort” just that
single matching record, and ExecLimit will pass that single record through its
offset/limit filter… but only after ExecSeqScan has iterated over all of the
names.&lt;/p&gt;

&lt;h2&gt;Next Time&lt;/h2&gt;

&lt;p&gt;How do we fix this problem? What should we do if our SQL queries on the users
table take more and more time to execute? The answer is simple: we  create an
index.&lt;/p&gt;

&lt;p&gt;In the next and final post in this series we’ll learn how to create a Postgres
index and to avoid the use of ExecSeqScan. More importantly, I’ll show you what
a Postgres index looks like: &lt;em&gt;how&lt;/em&gt; it works and &lt;em&gt;why&lt;/em&gt; it speeds up queries like
this one.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How Arel Converts Ruby Queries Into SQL Statements</title>
    <link href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements</id>
    <published>2014-09-23T00:00:00Z</published>
    <updated>2014-09-23T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/battle.png"&gt;&lt;br/&gt;
  &lt;i&gt;In one of the climactic scenes in &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the&lt;br/&gt;Sea&lt;/a&gt;, Captain Nemo and his crew battle a giant octopus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the second in a serie</summary>
    <content type="html">&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/battle.png"&gt;&lt;br/&gt;
  &lt;i&gt;In one of the climactic scenes in &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the&lt;br/&gt;Sea&lt;/a&gt;, Captain Nemo and his crew battle a giant octopus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the second in a series of posts based on a presentation I did at the
&lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt; called “20,000 Leagues Under
ActiveRecord” (&lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).&lt;/b&gt; I took an innocent and unsuspecting audience on an adventure
inside and underneath ActiveRecord to find out how Rails and PostgreSQL
actually execute a simple SQL query.&lt;/p&gt;

&lt;p&gt;In the &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;first part of the
presentation&lt;/a&gt;
I showed what ActiveRecord does internally when you call methods such as &lt;span
class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;limit&lt;/span&gt;. We saw how each
scoping method returns a new instance of the &lt;span
class="code"&gt;ActiveRecord::Relation&lt;/span&gt; class, gradually building up a
description of your query.&lt;/p&gt;

&lt;p&gt;Today I’ll continue by looking at what ActiveRecord does next: How it uses the
Arel gem to convert the &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; object
describing your query into a string containing a SQL statement. Later, in the
third post we’ll dive down inside the PostgreSQL database server itself to see
how it executes this SQL statement.&lt;/p&gt;

&lt;h2&gt;The Arel Gem&lt;/h2&gt;

&lt;p&gt;Here again is the instance of the &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; class that represents
our query to find the user named “Captain Nemo:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/ar-relation1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now that we’ve specified the query we want to execute, what does ActiveRecord
do next? How does it actually execute the query and return the results to us?
We can find a clue by looking more closely at the relation object and the
metadata values it stores:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/AR-Relation2.png"/&gt;&lt;/p&gt;

&lt;p&gt;If you inspect an &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; object in
the Rails console, you’ll find that its instance variables are not simple
values, but instead references to other Ruby objects. These objects have class
names such as &lt;span class="code"&gt;Arel::Nodes::Equality&lt;/span&gt; and &lt;span
class="code"&gt;Arel::Nodes::Attribute&lt;/span&gt;. What are these Ruby objects?  Where
are they created? What do these class names mean?&lt;/p&gt;

&lt;p&gt;It turns out that ActiveRecord itself doesn’t convert your
&lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; query to SQL; instead, it uses
a separate gem called Arel to do that. Googling for “Arel” we can easily find
its Github repo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel1.png"/&gt;&lt;br/&gt;
&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The gem’s description is simply “A Relational Algebra.” What in the world does
this mean? And farther down in the Readme there’s another interesting line:
“Arel is a SQL AST manager for Ruby.” What does “AST” mean, and what does an
“AST manager” do?&lt;/p&gt;

&lt;p&gt;AST stands for “Abstract Syntax Tree,” an important concept from computer
science. I’ll explain what that means in a minute. But first let’s look at some
computer science history to find out what Relational Algebra is.&lt;/p&gt;

&lt;h2&gt;Relational Algebra&lt;/h2&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/codd.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Edgar Codd&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Relational Algebra is a branch of computer science that forms the mathematical
foundation underpinning relational database servers and the SQL language. An
influential computer scientist named &lt;a href="http://en.wikipedia.org/wiki/Edgar_F._Codd"&gt;Edgar
Codd&lt;/a&gt; first described Relational
Algebra in his groundbreaking academic paper &lt;a href="http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf"&gt;A Relational Model of Data for
Large Shared Data Banks&lt;/a&gt;,
published in 1970. Codd described the term “relation” as follows:&lt;/p&gt;

&lt;blockquote&gt;
1.3. A RELATIONAL VIEW OF DATA&lt;br/&gt;
The term relation is used here in its accepted mathematical sense. Given sets
S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ... , S&lt;sub&gt;n&lt;/sub&gt;, (not necessarily distinct), R is a relation on
these n sets if it is a set of n-tuples each of which has its first element
from S&lt;sub&gt;1&lt;/sub&gt;, its second element from S&lt;sub&gt;2&lt;/sub&gt;, and so on.
&lt;/blockquote&gt;


&lt;p&gt;He later went on to define various mathematical operations on relations,
including &lt;em&gt;projection&lt;/em&gt;, &lt;em&gt;restriction&lt;/em&gt;, and &lt;em&gt;join&lt;/em&gt;. He also used terms such as &lt;em&gt;normal
form&lt;/em&gt;, &lt;em&gt;primary key&lt;/em&gt; and &lt;em&gt;foreign key&lt;/em&gt;. Today, almost 45 years later, we still use
Codd’s terminology and the associated mathematical theories when discussing
database tables and queries.&lt;/p&gt;

&lt;p&gt;In another interesting passage, Codd wrote about the need for a language we
could use to articulate and describe Relational Algebra concepts:&lt;/p&gt;

&lt;blockquote&gt;
1.5. SOME LINGUISTIC ASPECTS&lt;br/&gt;
The adoption of a relational model of data, as described above, permits the
development of a universal data sublanguage based on an applied predicate
calculus.
&lt;/blockquote&gt;


&lt;p&gt;This “universal sublanguage” is the Structured Query Language or SQL. I find
the term “sublanguage” to be very appropriate; SQL is a language used inside
larger applications written in some other programming language, such as Ruby.&lt;/p&gt;

&lt;p&gt;Returning to our example, here’s the SQL statement that represents our search
for the user named Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/sql.png"/&gt;&lt;/p&gt;

&lt;p&gt;The SQL language existed before Codd wrote his paper on Relational Algebra in
1970, but it didn’t resemble the version of SQL we all know and love today. The
mathematical concepts Codd first described form the basis for the modern
version of SQL.&lt;/p&gt;

&lt;p&gt;Now let’s return to the question of what an “AST manager” is.&lt;/p&gt;

&lt;h2&gt;Abstract Syntax Trees&lt;/h2&gt;

&lt;p&gt;An abstract syntax tree is a hierarchical arrangement of objects or memory
structures that represent a series of words or some syntax from a text
language. In this case, the AST inside of Arel is a tree of Ruby objects that
represents a SQL statement.&lt;/p&gt;

&lt;p&gt;Here’s the AST Arel creates internally for our example query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree1.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the top or root of the tree is a Ruby object called
&lt;span class="code"&gt;SelectStatement&lt;/span&gt;, and under that the various branches
of the tree represent the from, where, order by and limit clauses in our
select statement.&lt;/p&gt;

&lt;p&gt;The Arel gem “is a Relational Algebra” in the sense that it provides a Ruby API
that contains methods such as &lt;span class="code"&gt;project&lt;/span&gt;, &lt;span
class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;order&lt;/span&gt; that represent
concepts from Relational Algebra. Internally, these methods create Ruby objects
and save them in the AST. Arel’s API is similar to ActiveRecord’s, but is
somewhat more granular and detailed. When we call ActiveRecord methods such as
&lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;limit&lt;/span&gt;, internally
ActiveRecord calls the corresponding methods in the Arel gem.&lt;/p&gt;

&lt;p&gt;Here’s our example query written using both ActiveRecord (top) and Arel
(bottom) method calls:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel-and-ar.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 60px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/window.png"&gt;&lt;br/&gt;
  &lt;i&gt;Professor Aronnax, Conseil and Ned Land spent hours marveling&lt;br/&gt;at the underwater world through the windows of the Nautilus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Notice the Arel query is longer and more verbose. Expressing our query using Arel we call:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class="code"&gt;project&lt;/span&gt; to specify which columns or attributes we
are looking for (&lt;em&gt;projection&lt;/em&gt; in Codd’s Relational Algebra)&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;eq&lt;/span&gt; to specify
how to filter the result set (&lt;em&gt;restriction&lt;/em&gt; in Relational Algebra)&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;order&lt;/span&gt; to specify the sort order, and&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;limit&lt;/span&gt; to specify how many records we want.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Each time you call an ActiveRecord scoping method, it calls down into one of
these Arel methods, inserting objects into the same AST.&lt;/p&gt;

&lt;h2&gt;The Visitor Pattern&lt;/h2&gt;

&lt;p&gt;Creating an AST containing Ruby objects is one thing, but generating an actual
SQL statement is another. How does Arel do this? Why is building up an AST
useful in any way?&lt;/p&gt;

&lt;p&gt;Using a very elegant algorithm, Arel iterates over the nodes in the AST and
concatenates different SQL fragments to form a complete SQL statement. This
algorithm is an example of the “visitor pattern.” The term visitor pattern
simply means that some object, function or other piece of code is executed once
for each node in some data structure, such as an array, linked list or tree.&lt;/p&gt;

&lt;p&gt;To understand this a bit better, let’s take our example AST and follow Arel’s
visitor as it traverses the tree, starting at the &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; root node:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The blue arrow at the top is the visitor, a Ruby object. Depending on which
database server you are using, Arel creates a different visitor object. This is
a fascinating detail about Arel’s internal design: Arel can generate different
variations of SQL equally well by using different visitor objects. If you
connect your Rails app to SQLite, Arel uses a SQLite visitor. If you are using
MySQL, Arel uses a MySQL visitor. Because we’re using PostgreSQL today, Arel
creates a Postgres visitor.&lt;/p&gt;

&lt;h2&gt;Visiting All the Nodes in the AST&lt;/h2&gt;

&lt;p&gt;Now let’s follow Arel’s visitor as it iterates over the Ruby objects in the
AST, shown as a moving blue arrow. Above each diagram I’ll show the SQL string
the visitor cumulatively builds up as it goes.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree2b.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see the visitor arrow next to the &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; node. Above the diagram I’ve written the
word “SELECT.” Arel’s visitor knows to write SELECT when it encounters &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; root node.&lt;/p&gt;

&lt;p&gt;Next Arel moves down to the left:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree3.png"/&gt;&lt;/p&gt;

&lt;p&gt;This time Arel doesn’t write anything new into the string; &lt;span
class="code"&gt;SelectCode&lt;/span&gt; is just a container for other branches of the
tree.&lt;/p&gt;

&lt;p&gt;Next, Arel moves down and left again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now Arel’s visitor see the &lt;span class="code"&gt;Attribute&lt;/span&gt; node. This
represents the projection or list of attributes we want in the result set. Arel
appends &lt;span class="code"&gt;&amp;quot;users&amp;quot;.*&lt;/span&gt; to the SQL string.&lt;/p&gt;

&lt;p&gt;Next, the visitor moves to the right:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree5.png"/&gt;&lt;/p&gt;

&lt;p&gt;Encountering the &lt;span class="code"&gt;JoinSource&lt;/span&gt; node, Arel writes &lt;span
class="code"&gt;FROM &amp;quot;users&amp;quot;&lt;/span&gt; onto the end of the SQL statement. &lt;span
class="code"&gt;JoinSource&lt;/span&gt; and its child nodes list the tables that our
query will read from. In this example, we don’t have any joins and just a
single table, so &lt;span class="code"&gt;JoinSource&lt;/span&gt; has only one &lt;span
class="code"&gt;Table&lt;/span&gt; child node.&lt;/p&gt;

&lt;p&gt;Next, the visitor moves to the right again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree6.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now Arel writes the where clause for our SQL statement: &lt;span class="code"&gt;WHERE &amp;quot;users&amp;quot;.&amp;quot;name&amp;quot; =
$1&lt;/span&gt;. The &lt;span class="code"&gt;And&lt;/span&gt; node is the root of a subbranch of the AST that represents the
boolean expression we want the database server to use to filter our result set.
In our example we are only checking that the name column equals “Captain Nemo”
so the AST contains a single &lt;span class="code"&gt;Equality&lt;/span&gt; node under
&lt;span class="code"&gt;And&lt;/span&gt;. The &lt;span class="code"&gt;And&lt;/span&gt; node doesn’t
really do anything in this case.&lt;/p&gt;

&lt;p&gt;Now the visitor continues to the right:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree7.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see Arel finds the &lt;span class="code"&gt;Ascending&lt;/span&gt; node and appends our order by clause.&lt;/p&gt;

&lt;p&gt;Finally, the visitor moves to the right one last time:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree8.png"/&gt;&lt;/p&gt;

&lt;p&gt;Finding the &lt;span class="code"&gt;Limit&lt;/span&gt; node, Arel’s visitor completes the
SQL statement by concatenating &lt;span class="code"&gt;LIMIT 1&lt;/span&gt; onto our select statement.&lt;/p&gt;

&lt;p&gt;Using the visitor pattern in this way, Arel has converted our query from a
collection of Ruby objects into a single string containing a SQL select
statement. Arel has expressed our Ruby query using Codd’s Relational Algebra.&lt;/p&gt;

&lt;p&gt;Every time you execute a simple database query using ActiveRecord in your Rails
app, you are relying on a series of elegant algorithms and computer science
theories developed many years ago. Rails is so simple and easy to use only
because we are standing on the shoulders of giants &amp;ndash; computer scientists like
Edgar Codd &amp;ndash; who have already done the difficult theoretical work that makes
building apps today possible.&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/south-pole.png"&gt;&lt;br/&gt;
  &lt;i&gt;A citizen of no country, Captain Nemo claimed the &lt;br/&gt;south pole as his own using a black flag with a large "N."&lt;/i&gt;
&lt;/div&gt;


&lt;h2&gt;Why Stop Here?&lt;/h2&gt;

&lt;p&gt;We’ve learned a lot about ActiveRecord and the Arel gem. Now we know what
happens when we call scoping methods such as &lt;span class="code"&gt;where&lt;/span&gt;
and &lt;span class="code"&gt;first&lt;/span&gt;. We’ve seen how ActiveRecord calls Arel’s
lower level, more granular API, and now we know how Arel uses the visitor
pattern and an AST to convert these Ruby method calls into a SQL string.&lt;/p&gt;

&lt;p&gt;But why stop here? Why not dive even deeper? … farther below the surface of
your Rails app into the PostgreSQL server itself! Next we’ll leave the world of
Ruby entirely and look at what the Postgres server does when it receives this
select statement. How does it understand the SQL we send it? How does it
actually find our data, the user record with the name “Captain Nemo?” In my next
post, I’ll continue our underwater adventure by looking at Postgres internals.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>20,000 Leagues Under ActiveRecord</title>
    <link href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord</id>
    <published>2014-09-17T00:00:00Z</published>
    <updated>2014-09-17T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/title.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;First published in 1870, &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the Sea&lt;/a&gt;&lt;br/&gt;describes an underwater adventure that takes place&lt;br/&gt;onboard a submarine called the “Nautilus.”&lt;/i&gt;
&lt;/div&gt;


</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/title.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;First published in 1870, &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the Sea&lt;/a&gt;&lt;br/&gt;describes an underwater adventure that takes place&lt;br/&gt;onboard a submarine called the “Nautilus.”&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the first in a series of posts based on a presentation I just did
last Friday at the &lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt;. You can
also watch the &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video recording of the
presentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Let me start with a question: How many of you have actually read 20,000 Leagues
Under the Sea, either in the original French or in some translation? [ A few
people raised their hands, but most people in the audience did not. ] Yes, I’m
not surprised. 20,000 Leagues is one of those classic novels we have all heard
of, but few of us take the time to read.&lt;/p&gt;

&lt;p&gt;While thinking about this presentation over the Summer, I decided to actually
read the novel &amp;ndash; and I’m glad that I did! It blew my mind on a number of
different levels. Today I’m going to take the time to tell you a bit about the
novel itself as we go.&lt;/p&gt;

&lt;p&gt;However, actually I’m here today to talk about ActiveRecord. I’d like to explore
how ActiveRecord works internally; how it finds the information we ask for and
returns it to us as a Ruby object.&lt;/p&gt;

&lt;div style="clear: left"/&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/example1.png"/&gt;&lt;/p&gt;

&lt;p&gt;But why talk about ActiveRecord? We all know how to use ActiveRecord; most of
you understand exactly what this line of code does. You didn’t need to come to
Barcelona to learn how to use ActiveRecord.&lt;/p&gt;

&lt;p&gt;The reason why I want to discuss this is that ActiveRecord hooked me; it
first got me excited about using Rails. I came across Rails back in 2008, about
six years ago now. And I can still remember the moment when I first typed a
line of code similar to this one into the Rails console or into a Rails app
somewhere. It was amazing!  Before that I was using PHP or Java &amp;ndash; I’ve since
blocked out all memory of that so I’m not quite sure which it was :) &amp;ndash; and when
I saw how easy it was to use Rails to query a database I was very impressed.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/irb.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/underwater-walk.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax, Conseil and Ned Land&lt;br/&gt;on a hike through an underwater “forest.” Verne’s novel has&lt;br/&gt;many beautiful, detailed descriptions of underwater worlds&lt;br/&gt;he had never actually seen, and could only imagine.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Somehow Rails could take a simple, beautiful and readable line of Ruby code and
convert it into a SQL statement like this. How could this possibly work? It
seemed like magic!&lt;/p&gt;

&lt;p&gt;But it’s not magic. There are thousands of lines of code and years of computer
science research behind this simple line of code, the hard work behind the
scenes that makes ActiveRecord queries possible.&lt;/p&gt;

&lt;p&gt;Just as Professor Aronnax went on an underwater adventure with Captain Nemo,
I’d like to take you on an adventure inside of ActiveRecord to find out how it
works, how ActiveRecord generates and executes SQL statements.&lt;/p&gt;

&lt;p&gt;And why stop there? Later we’ll dive underneath ActiveRecord and inside an
actual database server to find out how it works too. How does it understand the SQL
statements we give it? How does it find the data we ask for and return it to
us? Let’s find out!&lt;/p&gt;

&lt;h2&gt;Agenda&lt;/h2&gt;

&lt;p&gt;Here’s our plan: First we’ll start with a look at &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;, the top, public API for
ActiveRecord many of you use everyday. Then, we’ll look deeper inside of
ActiveRecord to find out how it converts our Ruby queries into SQL statements.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/agenda.png"/&gt;&lt;/p&gt;

&lt;p&gt;Later, in the second half of the presentation we’ll dive even deeper and
directly into an actual relational database server (RDBMS); today I’ll use
PostgreSQL as an example. How does Postgres understand the SQL statement that
ActiveRecord sent it? How does it find the data we want? Finally, if we have
time we’ll look at the B-Tree Algorithm, which is part of the real magic that
allows database servers to work.&lt;/p&gt;

&lt;h2&gt;ActiveRecord::Relation&lt;/h2&gt;

&lt;p&gt;Let’s use my line of code from earlier as an example &amp;ndash; today we’ll be searching
for Captain Nemo together. Therefore, we’ll start with a &lt;span
class='code'&gt;User&lt;/span&gt; class, a subclass of &lt;span
class='code'&gt;ActiveRecord::Base&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-base.png"/&gt;&lt;/p&gt;

&lt;p&gt;When I call &lt;span class='code'&gt;where&lt;/span&gt; what happens? It turns out the
&lt;span class='code'&gt;where&lt;/span&gt; method is defined in the &lt;span
class='code'&gt;ActiveRecord::Querying&lt;/span&gt; module:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-querying.png"/&gt;&lt;/p&gt;

&lt;p&gt;But as you can see, ActiveRecord delegates the &lt;span class='code'&gt;where&lt;/span&gt;
method over to another method called &lt;span class='code'&gt;all&lt;/span&gt;, which
returns a new instance of a different class called &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;. In fact, my call to &lt;span
class='code'&gt;User.where&lt;/span&gt; is entirely equivalent to calling &lt;span
class='code'&gt;User.all.where&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/user-all.png"/&gt;&lt;/p&gt;

&lt;p&gt;ActiveRecord actually implements the &lt;span class='code'&gt;where&lt;/span&gt; method
using the new instance of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;.
Internally, &lt;span class='code'&gt;where&lt;/span&gt; is implemented by the &lt;span
class='code'&gt;ActiveRecord::QueryMethods&lt;/span&gt; module, included into &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;.  Next, &lt;span
class='code'&gt;ActiveRecord::QueryMethods#where&lt;/span&gt; returns, in turn, a second
new instance of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-relation1.png"/&gt;&lt;/p&gt;

&lt;p&gt;If you look at the right, you can see the second &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object contains information about
what record we’re looking for, that we want the records where the name is
“Captain Nemo.”&lt;/p&gt;

&lt;p&gt;Of course, we don’t want all of the Captain Nemo users; we just
want the first one. Next, we call the &lt;span class='code'&gt;first&lt;/span&gt; method on
the new &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-relation2.png"/&gt;&lt;/p&gt;

&lt;h2&gt;The Internal Implementation of ActiveRecord::FinderMethods#first&lt;/h2&gt;

&lt;p&gt;Now you can see ActiveRecord creates a third instance of &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;
&amp;ndash; this time with even more information about the query we’d like to execute.
  But what are all those other values: &lt;span class='code'&gt;order&lt;/span&gt;, &lt;span
  class='code'&gt;limit&lt;/span&gt; and &lt;span class='code'&gt;offset&lt;/span&gt;? Where do they
  come from? We can find out by taking a look at the implementation of &lt;span
  class='code'&gt;first&lt;/span&gt;. The &lt;span
  class='code'&gt;ActiveRecord::FinderMethods&lt;/span&gt; module implements this, which
  ActiveRecord includes into the &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; class.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/first1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see because we didn’t pass in a value for &lt;span class='code'&gt;limit&lt;/span&gt;, ActiveRecord
calls &lt;span class='code'&gt;find_nth&lt;/span&gt; and passes in a value of 0,
indicating we want the first record from the query result set. The second
argument, &lt;span class='code'&gt;offset_index&lt;/span&gt;, turns out to have a value of
zero, meaning we want to count into a window of records at the beginning of the
result set, not a window located somewhere farther along the result set.&lt;/p&gt;

&lt;p&gt;ActiveRecord implements a series of similar methods that will return the
second, third, fourth or even fifth record:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/second-fifth.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the pattern here; the first argument is a zero-based index
indicating which record we want. And just in case we want the forty second
record from the result set, ActiveRecord implements this useful method&amp;hellip; :)&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/forty-second.png"/&gt;&lt;/p&gt;

&lt;p&gt;It’s no joke! &lt;span class='code'&gt;forty_two&lt;/span&gt; is actually in the
ActiveRecord source code; you can try it for yourself. Replacing &lt;span
class='code'&gt;first&lt;/span&gt; with the equivalent call to &lt;span
class='code'&gt;find_nth&lt;/span&gt;, here’s our example again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/find-nth.png"/&gt;&lt;/p&gt;

&lt;p&gt;Following the code path through the &lt;span
class='code'&gt;ActiveRecord::FinderMethods&lt;/span&gt; module, we can see &lt;span
class='code'&gt;find_nth&lt;/span&gt; calls, in turn, &lt;span
class='code'&gt;find_nth_with_limit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/find-nth-with-limit.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now the arguments have been reversed; the first argument, 0, is now the offset
and the second, 1, is the number of records we want, or the limit value.&lt;/p&gt;

&lt;p&gt;Substituting one more time, let’s replace &lt;span
class='code'&gt;find_nth_with_limit&lt;/span&gt; with more detailed calls it makes to
&lt;span class='code'&gt;order&lt;/span&gt; and &lt;span class='code'&gt;limit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/detailed-calls.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now you can see where all of the values in the final &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object come from. Each call to a
scoping method saves a new piece of information about our query, and returns a
new instance of the &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; class.
(We’ll see what &lt;span class='code'&gt;arel_table&lt;/span&gt; means in a minute.)&lt;/p&gt;

&lt;h2&gt;The Beauty of ActiveRecord::Relation&lt;/h2&gt;

&lt;p&gt;Taking a step back, we can see that our simple line of code, &lt;span
class='code'&gt;User.where(name: &amp;quot;Captain Nemo&amp;quot;).first&lt;/span&gt;, is creating a
series of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; objects like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/method-chain.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/south-pacific.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo allowed Canadian harpoonist Ned Land&lt;br/&gt;to leave the submarine for a short time and explore a&lt;br/&gt;tropical island off the coast of Papua New Guinea.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;There are two interesting and beautiful things about this, I think. First,
notice the pattern that ActiveRecord uses: each call to a method returns a new
instance of the class that implemented that method. This is what allows us to
easily chain together different method calls. We can add on as many different
scopes as we wish; because each new object is also an &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;, it implements all of the same
methods. You can use the same pattern in your own code. All you need to do is
create a new instance of the class that implements each method, and return
that. One reason to study internal code like this is to learn about and find
new ideas that you can use in your own code.&lt;/p&gt;

&lt;p&gt;The second beautiful thing about &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; is that it’s lazy.  Using this chain
of method calls we are building up metadata or information about our query,
without actually executing the query itself. It’s almost as if we were using a
functional programming language like Haskell or Lisp. Using this trick,
ActiveRecord allows us to specify exactly the query we want, without having to
worry about executing it until we’re ready.&lt;/p&gt;

&lt;p&gt;It’s not until we call the &lt;span class='code'&gt;to_a&lt;/span&gt; method, in other to convert the
&lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object into an array and access the result set, that
ActiveRecord executes the query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/to-a.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see here that &lt;span class='code'&gt;to_a&lt;/span&gt; calls &lt;span class='code'&gt;load&lt;/span&gt; internally,
which later calls the &lt;span class='code'&gt;DatabaseStatements#select_all&lt;/span&gt;
method. Note the &lt;span class="code"&gt;find_nth_with_limit&lt;/span&gt; method calls
&lt;span class="code"&gt;to_a&lt;/span&gt;, so &lt;span class="code"&gt;first&lt;/span&gt;,
&lt;span class="code"&gt;second&lt;/span&gt; and &lt;span class="code"&gt;forty_two&lt;/span&gt; are
not lazy and will all execute the query immediately. Because of this, these are
known as “terminating methods.” To prevent the query from executing immediately &amp;ndash;
to keep it lazy &amp;ndash; just use &lt;span class="code"&gt;order&lt;/span&gt; and &lt;span
class="code"&gt;limit&lt;/span&gt; instead.&lt;/p&gt;

&lt;h2&gt;Next time&lt;/h2&gt;

&lt;p&gt;In the next few days I’ll post &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;the second part of my presentation from
Barcelona&lt;/a&gt;.
We’ll look at what “Relational Algebra” means and how the Arel gem converts our
&lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object into a string
containing a SQL statement.&lt;/p&gt;
</content>
  </entry>
</feed>

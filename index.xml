<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pat Shaughnessy</title>
  <id>http://patshaughnessy.net</id>
  <updated>2008-09-03T00:00:00Z</updated>
  <author>
    <name></name>
  </author>
  <entry>
    <title>Using Rake to Generate a Blog</title>
    <link href="http://patshaughnessy.net/2015/1/8/using-rake-to-generate-a-blog" rel="alternate"/>
    <id>http://patshaughnessy.net/2015/1/8/using-rake-to-generate-a-blog</id>
    <published>2015-01-08T01:00:00Z</published>
    <updated>2015-01-08T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/1/8/power-rake.png"&gt;&lt;br/&gt;
  &lt;i&gt;Jim Weirich showing a real power rake at &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;GORUCO 2012&lt;/a&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last year I needed to replace the software I use to serve this web site.
Instead of just using &lt;a href="h</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2015/1/8/power-rake.png"&gt;&lt;br/&gt;
  &lt;i&gt;Jim Weirich showing a real power rake at &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;GORUCO 2012&lt;/a&gt;&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last year I needed to replace the software I use to serve this web site.
Instead of just using &lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt;,
&lt;a href="https://middlemanapp.com"&gt;Middleman&lt;/a&gt;, &lt;a href="http://nanoc.ws"&gt;Nanoc&lt;/a&gt; or one of the
&lt;a href="https://www.ruby-toolbox.com/categories/static_website_generation"&gt;many other available
options&lt;/a&gt;, I
decided to implement my own &lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io"&gt;custom blog
software&lt;/a&gt;. After a
fair amount of work, I was able to implement a static blog site generator using
only &lt;a href="https://github.com/jimweirich/rake"&gt;Rake&lt;/a&gt; and a handful of simple Ruby classes. Although it took a bit longer,
it was a lot of fun and I learned a few tricks which I’d like to pass along
today.&lt;/p&gt;

&lt;p&gt;I first got the idea of using Rake as a static site generator from a
presentation called &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;Power Rake&lt;/a&gt;,
given by the late Jim Weirich at GORUCO 2012. This was one of the first Ruby
conferences I had ever attended, and was also the first time I had ever seen
Jim speak in public. It still stands out in my memory as one of the best
conference presentations I&amp;rsquo;ve ever seen. Funny, engaging, interesting, but most
of all &lt;em&gt;genuine&lt;/em&gt;, Jim had me and the rest of the audience enthralled as he talked
about &lt;a href="https://github.com/jimweirich/rake"&gt;Rake&lt;/a&gt;, his Ruby reinterpretation of
the old C make utility from the 1970s.&lt;/p&gt;

&lt;p&gt;The key idea behind using Rake to generate a static site is to generate and
manipulate files using Rake file tasks. What are file tasks? How are they
different from standard Rake tasks? To find out watch Jim’s presentation, or
read &lt;a href="http://devblog.avdi.org/2014/04/21/rake-part-1-basics/."&gt;an excellent series of articles and
screencasts&lt;/a&gt; by Avdi
Grimm. Today I’ll explain how I used Rake to create this blog. But first, let’s review
what a blog really is.&lt;/p&gt;

&lt;h2&gt;A Blog or a Static Web Site?&lt;/h2&gt;

&lt;p&gt;Most of the blogs in the world consist of a few dynamically generated web pages
served by either &lt;a href="http://wordpress.com"&gt;wordpress.com&lt;/a&gt; or
&lt;a href="http://blogger.com"&gt;blogger.com&lt;/a&gt;. To be honest, I should just use one of these
two free services for my site as well. However, I have a few years worth of
markdown files that contain all of my old content which would be a hassle to
import into whatever format Wordpress or Google uses. Plus using these sites
would be no fun at all; instead, I was looking for an excuse to write some Ruby
code and to learn more about Rake.&lt;/p&gt;

&lt;p&gt;What I really needed was an automated process for converting my markdown source
files into a series of static HTML files that were navigable using URL patterns that
readers expect. That is, I wanted a Rake task that would do this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/convert-file.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the top is one of my markdown files; on the bottom is the HTML version. I
needed a way to generate the bottom file from the top one. I needed to write a Rake
task that would iterate over all of the markdown files in the “posts” directory,
and generate the corresponding HTML files in the proper target directory.  The
markdown file name (“posts/2014-10-13-…”) was a naming convention I used to stay
organized. However, the name and path of the HTML file was what readers would see
in the post’s URL online &amp;ndash; for example:
&lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals&lt;/a&gt;.
This was a problem well suited to Rake file tasks, because they allow you to
create a series of dependencies between source and target files.&lt;/p&gt;

&lt;p&gt;But before I was ready to use file tasks, I needed to use a few tricks to make
those tasks easier to write.&lt;/p&gt;

&lt;h2&gt;Iterating Over Files Using Rake::FileList&lt;/h2&gt;

&lt;p&gt;Ruby objects are easier to work with than text files are, so the first thing I
decided to do was to write a Ruby class that represented one of my markdown
files. I called it &lt;span class="code"&gt;Post&lt;/span&gt; because each markdown file represented a single blog
post.&lt;/p&gt;

&lt;p&gt;Next, I needed to create a post object for each of the files in the posts
directory, by listing the files and iterating over them. It turns out Rake
provides a very simple way to do this: the &lt;span class="code"&gt;Rake::FileList&lt;/span&gt; class. To quote &lt;a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/rake/rdoc/Rake/FileList.html"&gt;the
documentation&lt;/a&gt;:&lt;/p&gt;

&lt;br/&gt;




&lt;blockquote&gt;
A FileList is essentially an array with a few helper methods defined to make file manipulation a bit easier.
&lt;/blockquote&gt;


&lt;p&gt;I like things that are easier. Here’s how I used &lt;span class="code"&gt;FileList&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/mapping-posts.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the left are my markdown files with the corresponding post objects on the right. My
code above first created a &lt;span class="code"&gt;FileList&lt;/span&gt;, using the &lt;span class="code"&gt;posts/*.markdown&lt;/span&gt; pattern. You
can think of the &lt;span class="code"&gt;FileList&lt;/span&gt; as an array of files that match the given pattern.
Once I had this array, I &lt;em&gt;mapped&lt;/em&gt; the array to a second array of ruby objects using
&lt;span class="code"&gt;Enumerable#map&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Blog Post Routing&lt;/h2&gt;

&lt;p&gt;Now that I had a &lt;span class="code"&gt;Post&lt;/span&gt; object for each source markdown file, I could add methods
to the &lt;span class="code"&gt;Post&lt;/span&gt; class to make manipulating the markdown files easier. Most
importantly, what I needed to know for each markdown file is where its HTML
should go in the generated site. That is, I needed to know the URL of the post:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/post-url.png"/&gt;&lt;/p&gt;

&lt;p&gt;This did the trick. The &lt;span class="code"&gt;date&lt;/span&gt; and &lt;span class="code"&gt;title&lt;/span&gt; methods parsed some metadata values I
saved in the markdown file along with the text. The &lt;span class="code"&gt;url&lt;/span&gt; method returned a string using
the year/month/day pattern most people are familiar with. The &lt;span class="code"&gt;slugize&lt;/span&gt; method
removed characters from the title that weren’t compatible with URL strings. As I
explained earlier, the URL is also the file system path for each post’s HTML
file: The single line of code above mapped the posts to an array of strings, each
one the path to an HTML file, the URL of that post appended with a file
extension.&lt;/p&gt;

&lt;h2&gt;Grouping Two Arrays Together&lt;/h2&gt;

&lt;p&gt;Now I had two arrays: &lt;span class="code"&gt;Post&lt;/span&gt; objects and HTML file paths. I was almost ready to
write a Rake file task that would convert the posts into HTML files. But, as
you&amp;rsquo;ll see in a minute, writing a file task requires two files: a source file
and a target file. Somehow I needed to convert these two separate arrays into a
single array of pairs, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/zipping.png"/&gt;&lt;/p&gt;

&lt;p&gt;As you can see, Ruby’s &lt;span class="code"&gt;Enumerable#zip&lt;/span&gt; method was
perfect solution. It yielded object pairs, one object taken from the receiver
(&lt;span class="code"&gt;html_files&lt;/span&gt;) and the other object taken from the
argument (&lt;span class="code"&gt;posts&lt;/span&gt;). If you pass in 2, 3 or more
arguments, it will yield triplets, quadruplets or n-tuples to the block
instead. I first learned about &lt;span class="code"&gt;zip&lt;/span&gt; from Jim Weirich’s
2012 Power Rake presentation; he used it in his static web site example in a
very similar way.  Of course, you can use &lt;span class="code"&gt;zip&lt;/span&gt; to
process multiple arrays for any purpose. It’s one of Ruby’s most beautiful
features I think.&lt;/p&gt;

&lt;h2&gt;Writing Rake File Tasks&lt;/h2&gt;

&lt;p&gt;As you probably know, a standard Rake task runs when you execute the task
directly, or when you run another task that depends on it. A file task,
however, will only execute the Ruby code inside the block if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The source file is newer than the target file, or&lt;/li&gt;
&lt;li&gt;The target file doesn’t exist at all.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This behavior is ideal for generating a static web site, or for any other job
that requires generating a file from another file. Rake will build the target
file for the first time if it doesn’t exist, or update it if the source file
has changed.&lt;/p&gt;

&lt;p&gt;Now that I had pairs of HTML paths and &lt;span class="code"&gt;Post&lt;/span&gt; objects,
it was easy for me to write a file task using one of these pairs. Here’s what I
came up with:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/file-task.png"/&gt;&lt;/p&gt;

&lt;p&gt;By calling &lt;span class="code"&gt;file&lt;/span&gt; inside of the &lt;span class="code"&gt;zip&lt;/span&gt; block, I created a file task for each one
of the paths in &lt;span class="code"&gt;html_files&lt;/span&gt;. Now if I created a single, standard Rake task that
depended on the array of html file paths, I could test whether any or all of the
HTML files needed to be generated:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/rake-posts.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now I could generate all of my blog posts with one command: &lt;span class="code"&gt;rake posts&lt;/span&gt;!&lt;/p&gt;

&lt;h2&gt;Rendering Each Post Using ERB&lt;/h2&gt;

&lt;p&gt;What did the code inside the file task do? It generated the HTML file for a
single post using &lt;span class="code"&gt;ERB&lt;/span&gt;, using a method I wrote called &lt;span class="code"&gt;Layout#render&lt;/span&gt;. If you’re
interested, here’s the &lt;span class="code"&gt;Layout&lt;/span&gt; class (&lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/lib/layout.rb"&gt;github&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/layout.png"/&gt;&lt;/p&gt;

&lt;p&gt;I won’t explain this line by line, but there were a couple of interesting tricks
here also. First, the &lt;span class="code"&gt;contents&lt;/span&gt; method used nested calls to
ERB to render a page layout surrounding the post, along
with the article text itself. This required I call &lt;span
class="code"&gt;yield&lt;/span&gt; somewhere inside my &lt;span class="code"&gt;layout.erb&lt;/span&gt; file in just the same
way I would in &lt;span class="code"&gt;application.html.erb&lt;/span&gt; for a Rails app.&lt;/p&gt;

&lt;p&gt;The complex line of code at the bottom that uses &lt;span class="code"&gt;instance_eval&lt;/span&gt; and
&lt;span class="code"&gt;binding&lt;/span&gt; seems impossible to understand at first. But actually it’s fairly
standard boilerplate Ruby metaprogramming code that evaluates the ERB template
in the context of the &lt;span class="code"&gt;page&lt;/span&gt; object and the current method.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/metaprogramming.png"/&gt;&lt;/p&gt;

&lt;p&gt;On the left I show the the &lt;span class="code"&gt;page&lt;/span&gt; object, an instance of the &lt;span class="code"&gt;Post&lt;/span&gt; class, in the
center the code running the ERB transformation, and on the right the Ruby call
stack.&lt;/p&gt;

&lt;p&gt;The arrow from ERB going to the left represents the use of &lt;span class="code"&gt;instance_eval&lt;/span&gt;. This
method, built into the Ruby language, resets the &lt;span class="code"&gt;self&lt;/span&gt; pointer to the
receiver or the &lt;span class="code"&gt;page&lt;/span&gt; object in this example. This allows the ERB code to access
the instance variables of the &lt;span class="code"&gt;page&lt;/span&gt; object and the methods of the &lt;span class="code"&gt;Post&lt;/span&gt; class.&lt;/p&gt;

&lt;p&gt;The arrow from ERB going to the right, in turn, represents the call to &lt;span class="code"&gt;binding&lt;/span&gt;.
The &lt;span class="code"&gt;binding&lt;/span&gt; method, also part of the Ruby core language, refers to the
current Ruby stack frame allowing the ERB code to access all of the local
variables present there, such as &lt;span class="code"&gt;recent_posts&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;My Rakefile&lt;/h2&gt;

&lt;p&gt;Of course, I’m glossing over some other important details here, such as
generating the index or home page, the RSS feed and a few other things. For
reference, here’s my entire Rakefile (&lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/Rakefile"&gt;github&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2015/1/8/rakefile.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the call to &lt;span class="code"&gt;Layout#render&lt;/span&gt; and the &lt;span class="code"&gt;rake :posts&lt;/span&gt; task I described
above. Here are some other coding details, if you’re interested:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;After creating the &lt;span class="code"&gt;posts&lt;/span&gt; array, I sort it by date, reversed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I generate the home page using another file task: &lt;span class="code"&gt;index.html&lt;/span&gt;, and a &lt;span class="code"&gt;HomePage&lt;/span&gt; class.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I generate the RSS in a similar way using a third file task: &lt;span class="code"&gt;index.xml&lt;/span&gt;, and a &lt;span class="code"&gt;Feed&lt;/span&gt; class.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Ideas, Not Code&lt;/h2&gt;

&lt;p&gt;If you’re interested in using this code for your own site, it’s on &lt;a href="https://github.com/patshaughnessy/patshaughnessy.github.io"&gt;github&lt;/a&gt;.
However, I wouldn’t recommended using it: It’s always a better idea to use a
well tested, robust free service such as wordpress.com or Jekyll.&lt;/p&gt;

&lt;p&gt;Instead of using this code, use the ideas behind it! Take the time to use
&lt;span class="code"&gt;Rake::FileList&lt;/span&gt; and Rake file tasks in whatever application you’re working on. And
please take the time to watch the &lt;a href="http://www.confreaks.com/videos/988-goruco2012-power-rake"&gt;PowerRake presentation&lt;/a&gt;. You’ll learn more about one
of Ruby’s most powerful tools &amp;ndash; and you’ll be able spend some time with Jim.
Jim’s bright personality and sense of humor can live on in our memory, at
least.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Koichi Sasada Encourages Us To Contribute To Ruby</title>
    <link href="http://patshaughnessy.net/2014/12/17/koichi-sasada-encourages-us-to-contribute-to-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/12/17/koichi-sasada-encourages-us-to-contribute-to-ruby</id>
    <published>2014-12-17T01:00:00Z</published>
    <updated>2014-12-17T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div class="epigraph"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/17/microscope.png"&gt;
  &lt;div class="epigraph-text"&gt;Ruby処理系開発コミュニティは、&lt;br/&gt;あなたの挑戦を歓迎する。&lt;/div&gt;
  &lt;div class="epigraph-caption"&gt;
  The Ruby core community welcomes your challenge.
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Today I’m happy to post an English translation of a new appendix to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ru</summary>
    <content type="html">&lt;div class="epigraph"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/17/microscope.png"&gt;
  &lt;div class="epigraph-text"&gt;Ruby処理系開発コミュニティは、&lt;br/&gt;あなたの挑戦を歓迎する。&lt;/div&gt;
  &lt;div class="epigraph-caption"&gt;
  The Ruby core community welcomes your challenge.
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Today I’m happy to post an English translation of a new appendix to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt; written by
Koichi Sasada (&lt;a href="https://twitter.com/_ko1"&gt;@_ko1&lt;/a&gt;), included in the Japanese
edition last month. As you probably know, Koichi is the developer behind the
virtual machine used by Ruby since Ruby 1.9 was released, known as “YARV.” He
writes about the early days of YARV (apparently he wrote the first version
during a single vacation week!) as well as some interesting aspects of its
technical design.&lt;/p&gt;

&lt;p&gt;But what struck me the most about this essay &amp;ndash; what I found encouraging and
inspiring &amp;ndash; was the story about how Koichi first became involved in Ruby
core development. He writes about how certain Ruby meetups and book
clubs created an environment that enabled him to learn and innovate. This
environment lead directly to the development of YARV, which enables all our
Ruby programs to run faster today.&lt;/p&gt;

&lt;p&gt;He concludes with a message for all of us: We should follow in his footsteps
and not be afraid to contribute to Ruby, to create “yet another Ruby
implementation.” Thinking about his story, to do this maybe we need to seek out
&amp;ndash; or to create &amp;ndash; the right learning environment, like the one Koichi found in
Japan 10 years ago. Thanks for writing this, Koichi! I’m happy and proud that
RUM now concludes with this message.&lt;/p&gt;

&lt;p&gt;Japanese-language edition copyright &amp;copy; 2014 by Ohmsha, Ltd. Reproduced with
permission of the copyright owner.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;




&lt;div class="appendix"&gt;A&lt;/div&gt;


&lt;div class="appendix-title"&gt;さらにそのほかの&lt;br/&gt;Ruby仮想マシン&lt;/div&gt;


&lt;br/&gt;


&lt;div class="appendix-translation"&gt;
Yet More Ruby Virtual Machines
&lt;/div&gt;




&lt;div class="jp"&gt;
&lt;p&gt;今回、私（笹田）がYARV：Yet Another RubyVMの開発者であるという縁で、本書の付録にYARVについて寄稿する機会を得た。本書では、多くのページを割いてYARVの中身を解説していただいている。しかも、原著は英語の著作であるので、世界中で読まれていることになる。ソフトウェア開発者として、たいへん光栄であると共に、読みながら実装の非効率な部分などを見つけてしまい、恥ずかしい思いもある。本稿では、YARVについて少し補足する。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;I (Koichi Sasada) am thankful to have a chance to write about YARV in this
appendix as a developer of YARV: Yet Another Ruby VM. Many pages of this book
describe the internals of YARV. Furthermore, the original edition is written in
English and has been read by people all over the world. I am greatly honored by
that as a software developer, although it humbles me to have found several
inefficiencies in YARV’s implementation while reading the book. In this appendix,
I will give some supplemental information and background on the design and
implementation of YARV.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARV: Yet Another RubyVM&lt;/h2&gt;
&lt;p&gt;YARVは、2004年の正月に、その当時より興味のあったRuby向け仮想マシンとして開発に着手し、簡単なものを1週間程度で開発した。おそらく、暇だったのだと思う。最初のアナウンスメール（[ruby-dev:22494]）を見ると、フィボナッチ数を求めるプログラムは動いていたようである。&lt;/p&gt;
&lt;p&gt;開発当初、YARVはRuby 1.8向けの拡張ライブラリとして実装していた。つまり、実行エンジンをすべて差し替えるのではなく、Ruby 1.8処理系から、指定したRubyプログラムをYARV上で実行する、という構造としていた。Ruby 1.8処理系の上に、もう1つRuby処理系を重ねていたことになる。この構造により、十分に安定しているRuby 1.8処理系を用いて、YARVの試験を比較的容易に行うことができた。また、GCやC APIなどの関数といった基盤コードをそのまま利用することもできた。そして、開発が進んだ後、スレッドなどをサポートするため、一気にRuby 1.8処理系のコア部分を取り除き、YARVに置き換えた。しかし、GCなどの基盤コードはその後も流用を続けた。当初より、Rubyインタプリタ（MRI/CRuby）はC言語と親和性の高い処理系として知られているが、YARVもその特長を受け継いでいる。そして、置き換えたものがRuby 1.9としてリリースされ、2014年現在も、RubyVMとして利用されている。&lt;/p&gt;
&lt;p&gt;よく、YARV：Yet Another RubyVMは、公式に取り込まれたので、Yet Anotherな処理系ではないのではないか、という指摘を受けるが、なんとなく語呂が良いので利用を続けている。ただし、ファイル名やクラス名には利用しないようにしている。開発当時、Ruby向け仮想マシンは、既にいくつか提案されていた。特に、Rubyの生みの親であるまつもと氏によるRiteVM、そしてByteCodeRubyというプロジェクトが知られていたと思う。そのため、“Yet Another”という名前を付けた。もちろん、yaccに代表されるように、この業界では“Yet Another”なものが多く利用されることも多かったため、同じようにYARVも多く利用されるよう、願をかけたということもある。ちなみに、RiteVMは、まつもと氏が鋭意開発しているmrubyの仮想マシンの名前となっている。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;YARV: Yet Another RubyVM&lt;/h2&gt;

&lt;p&gt;I started the development of YARV during the New Year&amp;rsquo;s holiday in 2004. I had
already been interested in a virtual machine for Ruby at that time. I built a
simple prototype within about a week. I must have had plenty of time to kill
back then. According to the first announcement ([ruby-dev:22494]), it was
capable of running a program to calculate Fibonacci numbers.&lt;/p&gt;

&lt;p&gt;In its early stages of development, I implemented YARV as an extension library
for Ruby 1.8. Instead of replacing the whole runtime engine, I designed it to
be used by Ruby 1.8 as a VM to run specific programs. In other words, it was
another Ruby implementation on top of the Ruby 1.8 implementation. This
architecture allowed us to test YARV with relative ease using Ruby 1.8, which
was sufficiently stable. We could continue using the base mechanisms of Ruby
1.8, such as GC, C APIs and so on. After finishing a substantial part of the
development, the Ruby 1.8 core was removed and replaced with YARV all at once,
in order to support features such as threads. However, we kept using
infrastructure code, such as GC, after that. The Ruby interpreter (MRI/CRuby)
is known to have an affinity to the C programming language. YARV inherits that
characteristic as well. Then a new version of Ruby containing YARV at its core
was released as Ruby 1.9. As of this writing in 2014, YARV has been used as the
Ruby VM since then.&lt;/p&gt;

&lt;p&gt;People often point out that YARV is not &amp;ldquo;Yet Another&amp;rdquo; anymore, because it is
the official VM now. Though we still use the name because it somehow sounds
familiar, we make it a rule not to use &amp;ldquo;YARV&amp;rdquo; in file names or class names. When
I started working on YARV, there had already been several proposals for the
development of new virtual machines for Ruby. RiteVM by Matz, the creator of
Ruby, and ByteCodeRuby were the most well known projects then, as far as I can
remember. That lead me to prefix the name of our VM with “Yet Another.” Of
course, I named it so hoping it would become popular. There are many examples
of software programs that have “Yet Another” in their names and nevertheless became
popular: for example yacc. By the way, RiteVM is now the name of the mruby VM
which Matz is actively developing.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARVの設計方針&lt;/h2&gt;
&lt;p&gt;YARVは当時の最新版であるRuby 1.8の仕様を踏襲するのではなく、その次の版である、Ruby 1.9の仕様を実装することとした。当時はRuby 1.9の仕様をどうするか議論していた。YARVではそのRuby 1.9の仕様のもとで開発を進めることにした。別の戦略として、Ruby 1.8に完全互換の仮想マシンを開発することで、多くの人に、即座に利用してもらうこともできた。しかし、いくつかのRuby 1.8の仕様がYARVで用いているスタックマシンでは実現困難であろうと思われたため、新しい仕様をベースに実装しつつ、困難な仕様は仕様変更できないか、交渉しながら開発を進めることとした。この戦略により、Ruby 1.9を実現するRubyインタプリタのひとつとなることができた。後に公式処理系としてマージされた理由のひとつだろうと思う。&lt;/p&gt;
&lt;p&gt;YARVの詳細設計は本書で解説しているとおりである。ただし、本書で説明している設計に辿り着くまでには紆余曲折があった。特に思い浮かぶのは仮想マシンのスタックの構造である。本書では、2重スタックマシンと表現されているが、当初は1つのスタックしか用いていなかった。仮想ではない現実のプロセッサでは、1つのスタックの上に、計算領域と関数呼び出しフレーム構造を交互に確保する。YARVも当初はそのような構造であったが、あまりに複雑となってしまい、性能を犠牲にしても、2つのスタックを用いて管理しよう、という結論に至った。ブロックをクロージャとして取り出す仕組みを実装するとき、特に操作が複雑となったためである。幸いにして本書ではこのあたりの説明をうまく回避しており、読者がこのような複雑さに悩まなくて済むようになっている。ただ、一番難しく、苦労した部分でもあるため、機会があれば解説してみたい。ちなみに、2つのスタックを持つ、ということは、スタックオーバーフローのチェックコストも2倍になる、ということである。そこで、2つのスタックを、1つのメモリブロックで下端から上へ伸ばすスタック、上端から下へ伸ばすスタックとして実装した。この工夫により、2つのスタックのスタックオーバフローのチェックは、2つのスタックポインタの位置関係を1度確認するだけでよく、若干軽量にすることができた。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;Design Principles of YARV&lt;/h2&gt;

&lt;p&gt;We chose to implement YARV for the Ruby 1.9 specification, instead of 1.8. At
the time, Ruby 1.9 was the next version, and we were discussing its
specification. We targeted YARV at that specification. We also had the option
of implementing it for Ruby 1.8, thereby supporting a large number of users
instantly. But some of the Ruby 1.8 features seemed difficult to implement with
the stack machine which YARV is based on. So I decided to implement my VM for
the newer spec, while negotiating with Ruby developers to change the parts of
the specification that were hard to implement. This strategy worked well, and
YARV became one of the interpreters to run Ruby 1.9. I think that was one of
the reasons that it was finally merged in as an official VM.&lt;/p&gt;

&lt;p&gt;This book correctly explains YARV’s design details. I would, however, like to add
that it was not so straightforward to get to the current design. One of the
things I remember is the stack structure of the virtual machine. The book
describes YARV as a &amp;ldquo;double stack machine,&amp;rdquo; but it was using only one stack at
first.  Actual microprocessors allocate a calculation area and a function call
frame one after another on a single stack. YARV used a similar architecture at
first, but it became too complicated. Later I concluded that it should have two
stacks, even if I had to give up some efficiency. YARV’s operation became too
complex especially when implementing the extraction of a block as a closure.
Because this book cleverly avoids such hairy details, readers fortunately do
not have to confront this sort of complexity. I hope, though, I have chance to
explain that, because it was one of the most difficult parts to implement. By
the way, having two stacks means that the cost of checking for stack overflows
also doubles. So I implemented them both in the same memory block: one going
from bottom to top and the other going from top to bottom.  This trick somewhat
reduced the cost of checking for stack overflows, because we only have to check
the positions of two stack pointers once.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;YARVの開発までの経緯&lt;/h2&gt;
&lt;p&gt;開発に至った経緯についても触れておく。もともと、私は言語処理系の実装に興味があったため、Javaの仮想マシンを2つほど開発したことがあった。そのため、オブジェクト指向言語処理系に必要となる仮想マシンに必要な要件を、既にいくつか知っていた。そのころ、「計算機プログラムの構造と解釈」、通称SICPの読書会が山下伸夫氏により定期的に開催されており、これに参加することで、Schemeの言語処理系についての知見を得ることができた。本書の第8章で紹介されているように、RubyのブロックはLispの関数にあたるものであったため、この知見は重要なものであった。&lt;/p&gt;
&lt;p&gt;2002年12月に青木峰郎氏による、Rubyのソースコードを逐一解説するという異色の書、「Rubyソースコード完全解説」、通称RHGが発売された。そして、高橋征義氏によりRHG読書会が企画され、月1度程度の頻度で開催された。参加者で本書を読み上げていく、というスタイルであったが、不明点は著者である青木氏を含めた参加者で議論できたため、Ruby処理系の詳細を知ることができた。余談だが、SICP読書会、およびRHG読書会は、当時山下氏が勤めていた、新宿にある株式会社タイムインターメディアの会議室で行われていた。私は、これらの読書会に参加するために、月に数回、タイムインターメディアに通っていたことになる。このような大切な機会を与えてくれた諸氏に深く感謝したい。&lt;/p&gt;
&lt;p&gt;RHGによってRuby処理系の構造を学べば、Rubyプログラムを実行する心臓部となる評価器が、Java仮想マシンなどに比べ、あまりに非効率であることは明らかであった。そのため、Rubyの文法を適切に、高速に評価する仮想マシンはどのようなものであるか、ということに興味を持ち、検討を続けた。そして、正月休みの機会に一気に書き上げた。その頃は、まさかRuby 1.9の一部としてリリースされることになるとは思わなかった。最初の動機が性能向上であったため、最初から性能のことを強く意識したソースコードであった。今思えば、早すぎる最適化といえると思う。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;YARV Development Prehistory&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;d like to describe the history of how I came to develop YARV. Because earlier
I had been interested in programming language processors, I had the experience
of implementing two Java virtual machines. That gave me some knowledge of what
was required to implement virtual machines intended for object-oriented
programming languages. At the time, Mr.  Nobuo Yamashita was periodically
holding meetups to read the book &lt;i&gt;The Structure and Interpretation of
Computer Programs&lt;/i&gt; (or SICP). Attending them, I acquired knowledge and
insight about implementations of Scheme. This insight was important since
Ruby&amp;rsquo;s block design was based on Lisp functions, as Chapter 8 of this book
points out.&lt;/p&gt;

&lt;p&gt;It was December 2002 when &lt;i&gt;Ruby Source Code Kanzen Kaisetsu&lt;/i&gt; (the &lt;i&gt;Ruby
Hacking Guide&lt;/i&gt;, or RHG), by Mr. Minero Aoki was published, which is a unique
book that explains the entire Ruby source code. Mr. Masayoshi Takahashi held
meetings to read RHG about once a month. We took turns in a reading group, but
because the author Aoki-san himself was one of the members the other members
could talk with him in person when they had questions. In this way, we learned
the implementation details of Ruby very well. Let me add that both of these
meetups are held in the meeting rooms at Time Intermedia, Ltd., where Mr.
Yamashita was working then. I attended the meetups frequently: several times a
month. I wish to express my deep gratitude to the people who provided such an
environment for learning.&lt;/p&gt;

&lt;p&gt;After reading RHG and learning more about the structure of Ruby’s
implementation, it became clear to me that the evaluation module Ruby used to
run programs &amp;ndash; the heart of the Ruby interpreter &amp;ndash; was not efficient enough. I
kept on studying and thinking about the ideal design of a virtual machine to run
Ruby programs precisely and efficiently, which I finally implemented all at
once during that New Year&amp;rsquo;s holiday. I didn’t foresee that it would be released
as a part of Ruby 1.9. My first motivation was performance improvement &amp;ndash; my
source code surely reflected that. In hindsight, it was such an early
optimization.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;h2&gt;さらにそのほかのRuby仮想マシン&lt;/h2&gt;
&lt;p&gt;本書では、YARVの構造を既知のものとして紹介しており、もしかしたら、このように実装するのが正しいRuby処理系だ、とも読めるかもしれない。しかし、本稿で紹介したとおり、YARVをはじめ、Ruby処理系は人間が試行錯誤しながら、なんとか作り上げてきたソフトウェアにすぎない。本書はRuby 2.0をベースに紹介しているが、Ruby 2.1では、さらに品質を向上するためにさまざまな修正を行った。そして、これからリリースする予定であるRuby 2.2を、より良いものにするため、改善を続けている。&lt;/p&gt;
&lt;p&gt;たとえば、キーワード引数の改善である。本書の第4章では、キーワード引数の実装方法について紹介している。簡単に要約すると、呼び出しにおいて、キーワード引数として渡した名前と値の対を、1つのHashオブジェクトとしてまとめ、通常の引数として渡す。受け側はそのHashオブジェクトから必要な値を読み出すコードをコンパイル時に暗黙に展開する。さて、キーワード引数はRuby 2.0から導入された新機能なので、利用頻度が低いようであり、問題になっていないが、この実装は非効率である。メソッド呼び出しごとにHashオブジェクトが生成されることになり、Hashオブジェクト生成、およびGCのコストがかかる。また、暗黙に展開されるHashオブジェクトの読み込みも、複数のメソッド呼び出しを含むため、遅い。&lt;/p&gt;
&lt;p&gt;この問題を改善するため、Ruby 2.2から、可能な限りHashオブジェクトを生成しないようにキーワード引数を実装し直した。その代わり、コンパイル時にキーワード引数の名前をまとめておき、呼び出し側では値のみ渡すことにした。そして、受け側では渡された値と、コンパイル時に作成した名前を用いて対を復元するようにした。この工夫によりキーワード引数を用いるメソッド呼び出しを、場合によっては10倍以上高速化することができた。今後も、実行速度を含む、Ruby処理系の品質向上を続けていきたい。&lt;/p&gt;
&lt;/div&gt;


&lt;h2&gt;Yet More Ruby Virtual Machines&lt;/h2&gt;

&lt;p&gt;This book explains the current architecture of YARV, which you might conclude
is the correct way of implementing Ruby. But, as I have explained in this
appendix so far, all of Ruby’s implementations, including YARV, are not much
different from any other software application: they are all developed through
trial and error by humans. While this book covers Ruby 2.0, we have already
made various improvements for Ruby 2.1. And we are working on even more
improvements that will make the forthcoming Ruby 2.2 even better.&lt;/p&gt;

&lt;p&gt;For example, keyword arguments will be more efficient. Chapter 4 explains the
implementation of keyword arguments. Quickly summarizing: Ruby first passes a
hash object containing keyword name and value pairs as a normal argument. Then,
at compile time, the receiver implicitly expands code that reads the values
from the argument hash. Users don’t seem to be complaining about its
performance for now. I assume keyword arguments are not widely used, because it
is a new feature introduced in Ruby 2.0. But this implementation is not
efficient. Hash objects are created every time, incurring object creation and
GC costs. Also, reading from Hash objects using the implicitly expanded code is
slow, because it involves multiple method calls.&lt;/p&gt;

&lt;p&gt;In order to address this problem, we are reimplementing how Ruby 2.2 handles
keyword arguments to avoid creating Hash objects as much as possible.
Meanwhile, we are implementing a new design that will collect the names of
keyword arguments at compile time, so that caller need only pass the values at
runtime. The callee will then recombine the values with the names collected
by the compiler. This design change will allow Ruby to process keyword
arguments 10 times faster. I would like to keep on improving the quality of
Ruby&amp;rsquo;s implementation, including runtime efficiency.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;p&gt;もし、本書によってYARV、そしてRuby処理系に興味を持ち、改良方法を思いついたら、ぜひ「さらにそのほかのRuby処理系」として実装し、試してほしい。Ruby処理系開発コミュニティは、あなたの挑戦を歓迎する。
&lt;br/&gt;
&lt;br/&gt;
2014年11月&lt;br/&gt;
笹田耕一&lt;br/&gt;
Heroku, Inc.
&lt;/div&gt;


&lt;p&gt;If you become interested in YARV and Ruby implementations after reading this
book, if you have ideas for improving them, I encourage you to develop your own
“Yet Another Ruby Implementation.” The Ruby core community will welcome your
challenge.&lt;/p&gt;

&lt;p&gt;November 2014&lt;br/&gt;
Koichi Sasada&lt;br/&gt;
Heroku, Inc.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Matz’s Foreword to Ruby Under a Microscope</title>
    <link href="http://patshaughnessy.net/2014/12/15/matzs-forward-to-ruby-under-a-microscope" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/12/15/matzs-forward-to-ruby-under-a-microscope</id>
    <published>2014-12-15T01:00:00Z</published>
    <updated>2014-12-15T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/15/rumja_cover.png"&gt;&lt;br/&gt;
  &lt;i&gt;&lt;a href="http://shop.ohmsha.co.jp/shopdetail/000000004065/"&gt;A Japanese translation&lt;/a&gt; of Ruby Under a&lt;br/&gt;Microscope was published last month.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Matz wrote a new foreword to &lt;a href="http://patshaughnessy.net/ruby-under-a-micros</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/12/15/rumja_cover.png"&gt;&lt;br/&gt;
  &lt;i&gt;&lt;a href="http://shop.ohmsha.co.jp/shopdetail/000000004065/"&gt;A Japanese translation&lt;/a&gt; of Ruby Under a&lt;br/&gt;Microscope was published last month.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Matz wrote a new foreword to &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt;, which was
included in the Japanese version of the book published just last month. Today
I’d like to share a translation so everyone has a chance to read it. The
Japanese edition also includes a new appendix written by Koichi Sasada about
YARV, Ruby’s virtual machine. I’ll post a translation of that tomorrow.&lt;/p&gt;

&lt;p&gt;I love Matz’s sentiment about inspiring someone to work on Ruby… I hope that
might happen too. Thank you for writing this, Matz! You’ve already inspired so
many of us for years with your personality, your philosophy and with the
beautiful programming language you created.&lt;/p&gt;

&lt;p&gt;Japanese-language edition copyright &amp;copy; 2014 by Ohmsha, Ltd. Reproduced with
permission of the copyright owner.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;




&lt;div class="jp"&gt;
&lt;h2&gt;日本語版序文&lt;/h2&gt;
&lt;p class="jp"&gt;
私が小学生のときに読んで記憶に残っている一冊として、マーク・トウェインによる「アーサー王とあった男」&lt;sup&gt;*1&lt;/sup&gt;というSF作品があります。1880年代のアメリカ人がアーサー王時代にタイムスリップしてしまうものの、現代（出版当時）の知識を活用して活躍するというストーリーです。5世紀に電話や自転車、銃などの知識を持ち込めばさぞかし無敵でしょう。しかし、仮に21世紀の我々が5世紀にタイムスリップしたとして、我々の持っている知識をどれだけ活用することができるでしょう。自転車くらいならともかく、何もないところからコンピュータやネットワークを構築することなどできそうもありません。現代のテクノロジーは個人レベルで再現するには高度化しすぎています。普段はなにげなく使っている技術でも中身までは理解していないものです。
&lt;/p&gt;
&lt;/div&gt;




&lt;h2&gt;Foreword for Japanese Edition&lt;/h2&gt;


&lt;p&gt;The science fiction novel &lt;cite class="book"&gt;A Connecticut Yankee in King Arthur's
Court&lt;/cite&gt;&lt;sup&gt;*1&lt;/sup&gt; by Mark Twain is one of the books I still remember reading from my
elementary school days. It is the story of an American living in the 1880s who accidentally
time travels to King Arthur era England and nonetheless survives, taking
advantage of his knowledge from the modern (1880) era. Surely you would be very
powerful in the 5th century if you had knowledge of telephones, bicycles, and
guns.  But if we time travelled from the 21st century to the 5th century, how
much of our knowledge could we utilize?  Bicycles are okay, but how about
computers? It seems almost impossible to build computers and networks from
scratch ourselves.  Modern technology products are too advanced for individuals
to reproduce. We don't know how technologies work even when we use them in our
everyday lives.&lt;/p&gt;




&lt;div class="jp"&gt;
&lt;p&gt;
私たちが普段使っているRubyもそのような現代テクノロジーのひとつです。Rubyを便利に使っていても、その中がどうなっていて、どのように実行されているのか、あるいはRubyのような言語をどうすれば再現できるのか正確な知識を持っている人はほとんどいないでしょう。本書はそのような謎に包まれている「Rubyの中身」を明らかにしてくれる一冊です。
&lt;/p&gt;
&lt;p&gt;
本書はRubyのソフトウェア構造から、オブジェクトシステムの構成、性能を向上させるための工夫まで解説されています。さらにCRubyだけでなく、JRubyやRubiniusについてまでカバーしています。このような知識を学べる書籍はなかなかありません。日本には類書として「Rubyソースコード完全解説」&lt;sup&gt;*2&lt;/sup&gt;がありますが、入手困難になって久しいですし、対象のRubyバージョンも1.7と古いので、YARVのような新しい技術については当然解説されていません。このような書物の登場は、Rubyの内部知識の一般化に貢献すると信じます。
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Ruby is one such technology. Even though we use it every day, not many of us
seem to know what it looks like on the inside, how it runs internally, or how
one could recreate such a programming language. This book sheds light on this and
reveals the mystery of Ruby internals.&lt;/p&gt;

&lt;p&gt;This book explains the software architecture of Ruby, the structure of its
object system, and tips for performance improvement. In addition to that, it
covers not only CRuby but also JRuby and Rubinius as well. I know of few books
where you can find this type of knowledge. Though we have the &lt;cite
class="book"&gt;Ruby Hacking Guide&lt;/cite&gt;&lt;sup&gt;*2&lt;/sup&gt; in Japan, it&amp;rsquo;s been
difficult to obtain a copy for a long time. It explains a version of Ruby as
old as 1.7 and naturally does not cover newer technologies like YARV. I believe
RUM will contribute to a wider understanding of Ruby internals.&lt;/p&gt;

&lt;div class="jp"&gt;
&lt;p&gt;
本書の知識をもとにして、もしかすると本書の読者のうちの誰か、もしかするとあなたがRubyの開発に関わるようになるかもしれませんし、そうなれば我々は大歓迎します。あるいは、次世代の言語処理系を開発するきっかけになるかもしれません。そのような未来が見たいものです。
&lt;/p&gt;
&lt;p&gt;
&lt;br/&gt;
2014年10月、松江にて&lt;br/&gt;
まつもと ゆきひろ
&lt;/p&gt;
&lt;br/&gt;
&lt;hr align="left"/&gt;
&lt;small&gt;*1 マーク・トウェーン作、亀山龍樹訳「アーサー王とあった男」（岩崎書店、1971）&lt;br/&gt;
*2 青木峰郎著「Rubyソースコード完全解説」（インプレス、2002）&lt;/small&gt;
&lt;/div&gt;


&lt;p&gt;In the future someone inspired by this book may join the development of Ruby.
It may be you. We will definitely welcome that. Or, he/she may begin creating a
next generation programming language. I hope to see that happen.&lt;/p&gt;

&lt;p&gt;In Matsue, October 2014&lt;br/&gt;
Yukihiro Matsumoto&lt;/p&gt;

&lt;br/&gt;


&lt;hr align="left"/&gt;


&lt;p&gt;&lt;small&gt;*1 Twain, Mark, A Connecticut Yankee in King Arthur’s Court. (Kameyama Nagarjuna translation, Iwasaki Bookstore, 1971)&lt;br/&gt;
*2 Aoki Minero al., Ruby Hacking Guide. (Impress, 2002)&lt;/small&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Discovering the Computer Science Behind Postgres Indexes</title>
    <link href="http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes</id>
    <published>2014-11-11T01:00:00Z</published>
    <updated>2014-11-11T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/engineering-plans.png"&gt;&lt;br/&gt;
  &lt;i&gt; Captain Nemo and Professor Aronnax discussing the&lt;br/&gt;engineering and science behind
  the Nautilus.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;&lt;b&gt; This is the last post in a series based on a
  presentation I did at the &lt;a href="http://www.baruco.org"&gt;Barcelona</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/engineering-plans.png"&gt;&lt;br/&gt;
  &lt;i&gt; Captain Nemo and Professor Aronnax discussing the&lt;br/&gt;engineering and science behind
  the Nautilus.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;&lt;b&gt; This is the last post in a series based on a
  presentation I did at the &lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt;
  called “20,000 Leagues Under ActiveRecord.” (other posts:
  &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;one&lt;/a&gt;
  &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;two&lt;/a&gt;
  &lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;three&lt;/a&gt;
  and &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).  &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;We all know indexes are one of the most powerful and important features of
relational database servers. How do you search for a value quickly? Create an
index. What do you have to remember to do when joining two tables together?
Create an index. How do you speed up a SQL statement that’s beginning to run
slowly? Create an index.&lt;/p&gt;

&lt;p&gt;But what are indexes, exactly? And &lt;em&gt;how&lt;/em&gt; do they speed up our database searches?
To find out, I decided to read the C source code inside the PostgreSQL database
server, to follow along as it searched an index for a simple string value. I
expected to find sophisticated algorithms and efficient data structures. And I
did. Today I’ll show you what indexes look like inside Postgres and explain how
they work.&lt;/p&gt;

&lt;p&gt;What I didn’t expect to find &amp;ndash; what I discovered for the first time reading the
Postgres C source code &amp;ndash; was the Computer Science theory behind what it was
doing. Reading the Postgres source was like going back to school and taking
that class I never had time for when I was younger. The C comments inside
Postgres not only explain what Postgres does, but &lt;em&gt;why&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Sequence Scans: A Mindless Search&lt;/h2&gt;

&lt;p&gt;When we left the crew of the Nautilus, they were exhausted and beginning to
faint: the Postgres sequence scan algorithm was mindlessly looping over all of
the records in the users table! Recall in &lt;a href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals"&gt;my last
post&lt;/a&gt;
we had executed this simple SQL statement to find Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/select-users.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres first parsed, analyzed and planned the query. Then
&lt;a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html#af80d84501ff7621d2ef6249b148e7f44"&gt;ExecSeqScan&lt;/a&gt;,
the C function inside of Postgres that implements the sequence scan (SEQSCAN)
plan node, quickly found Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan4.png"/&gt;&lt;/p&gt;

&lt;p&gt;But then inexplicably Postgres continued to loop through the entire user table,
comparing each name to “Captain Nemo,” even though we had already found what we
were looking for!&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan5.png"/&gt;&lt;/p&gt;

&lt;p&gt;Imagine if our users table had millions of records; this could take a very long
time. Of course, we could have avoided this by removing the sort and rewriting
our query to accept the first name, but the deeper problem here is the
inefficient way Postgres searches for our target string. Using a sequence scan
to compare every single value in the users table with “Captain Nemo” is slow,
inefficient and depends on the random order the names appear in the table. What
are we doing wrong? There must be a better way!&lt;/p&gt;

&lt;p&gt;The answer is simple: We forgot to create an Index. Let’s do that now.&lt;/p&gt;

&lt;h2&gt;Creating an Index&lt;/h2&gt;

&lt;p&gt;Creating an index is straightforward &amp;ndash; we just need to run this command:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/create-index.png"/&gt;&lt;/p&gt;

&lt;p&gt;As Ruby developers, of course, we would use the &lt;span class="code"&gt;add_index&lt;/span&gt; ActiveRecord
migration instead; this would run the same &lt;span class="code"&gt;CREATE INDEX&lt;/span&gt; command behind the
scenes. When we rerun our select statement, Postgres will create a plan tree as usual &amp;ndash;
but this time the plan tree will be slightly different:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/11/11/indexscan-plan.png"/&gt;&lt;/p&gt;

&lt;p&gt;Notice at the bottom Postgres now uses INDEXSCAN instead of SEQSCAN. Unlike
SEQSCAN, INDEXSCAN won’t iterate over the entire users table. Instead, it will
use the index we just created to find and return the Captain Nemo records
quickly and efficiently.&lt;/p&gt;

&lt;p&gt;Creating an index has solved our performance problem, but it’s also left us with many interesting, unanswered questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;What&lt;/em&gt; is a Postgres index, exactly?&lt;/li&gt;
&lt;li&gt;If I could go inside of a Postgres database and take a close look at an index, &lt;em&gt;what would it look like&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;And &lt;em&gt;how&lt;/em&gt; does an index speed up searches?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Let’s try to answer these questions by reading the Postgres C source code.&lt;/p&gt;

&lt;h2&gt;What Is a Postgres Index, Exactly?&lt;/h2&gt;

&lt;p&gt;We can get started with a look at the
&lt;a href="http://www.postgresql.org/docs/9.3/static/sql-createindex.html"&gt;documentation&lt;/a&gt;
for the CREATE INDEX command.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/documentation.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see all of the options we can use to create an index, such as
&lt;span class="code"&gt;UNIQUE&lt;/span&gt; and &lt;span class="code"&gt;CONCURRENTLY&lt;/span&gt;. Notice there’s an option called &lt;span class="code"&gt;USING method&lt;/span&gt;. This
tells Postgres what kind of index we want. Farther down the same page is some
information about &lt;span class="code"&gt;method&lt;/span&gt;, the argument to the &lt;span class="code"&gt;USING&lt;/span&gt; keyword:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/method.png"/&gt;&lt;/p&gt;

&lt;p&gt;It turns out Postgres implements four different types of indexes. You can use
them for different types of data and in different situations. Because we didn’t
specify &lt;span class="code"&gt;USING&lt;/span&gt; at all, our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index is a “btree” (or B-Tree) index,
the default type.&lt;/p&gt;

&lt;p&gt;This is our first clue: a Postgres index is a B-Tree. But what is a B-Tree?
Where can we find one? Inside of Postgres, of course! Let’s search the Postgres
C source code for files containing “btree:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/find.png"/&gt;&lt;/p&gt;

&lt;p&gt;The key result is in bold: “./backend/access/nbtree.” Inside this directory is
a README file; let’s read it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/readme.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/atlantis.png"&gt;&lt;br/&gt;
  &lt;i&gt;Nemo found the lost continent of Atlantis&lt;br/&gt;next to an underwater
  volcano.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Amazingly, this README file turns out to be an extensive 12 page document! The
Postgres source code not only contains helpful and interesting C comments, it
also contains documentation about the theory and implementation of the database
server. Reading and understanding the code in open source projects can often be
intimidating and difficult, but not for Postgres. The developers behind
Postgres have gone to great lengths to help the rest of us understand their
work.&lt;/p&gt;

&lt;p&gt;The title of the README document, “Btree Indexing,” confirms this directory
contains the C code that implements Postgres B-Tree indexes. But the first
sentence is even more interesting: it’s a reference to an academic paper that
explains what a B-Tree is, and how Postgres indexes work: &lt;a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf"&gt;Efficient Locking for
Concurrent Operations on B-Trees&lt;/a&gt;, by Lehman and Yao.&lt;/p&gt;

&lt;p&gt;We’ll find our first look at a B-Tree inside this academic paper.&lt;/p&gt;

&lt;h2&gt;What Does a B-Tree Index Look Like?&lt;/h2&gt;

&lt;p&gt;Lehman and Yao’s paper explains an innovation they made to the B-Tree algorithm
in 1981. I’ll discuss this a bit later. But they start with a simple
introduction to the B-Tree data structure, which was actually invented 9 years
earlier in 1972. One of their diagrams shows an example of a simple B-Tree:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/11/11/figure2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The term B-Tree actually stands for “balanced tree.” B-Trees make searching
easy and fast. For example, if we wanted to search for the value 53 in this
example, we first start at the root node which contains the value 40:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node1.png"/&gt;&lt;/p&gt;

&lt;p&gt;We compare our target value of 53 with the value we find in the tree node. Is
53 greater than or less than 40? Because 53 is greater than 40 we follow the
pointer down to the right. If we were searching for 29, we would go down to the
left. Pointers on the right lead to larger values; pointers on the left to
smaller ones.&lt;/p&gt;

&lt;p&gt;Following the pointer down the tree to the next child tree node, we encounter a
node that contains 2 values:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node2.png"/&gt;&lt;/p&gt;

&lt;p&gt;This time we compare 53 with both 47 and 62, and find that 47 &amp;lt; 53 &amp;lt; 62. Note
the values in the tree node are sorted, so this will be easy to do. This time
we follow the center pointer down.&lt;/p&gt;

&lt;p&gt;Now we get to another tree node, this one with 3 values in it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node3.png"/&gt;&lt;/p&gt;

&lt;p&gt;Looking through the sorted list of numbers, we find 51 &amp;lt; 53 &amp;lt; 56, and follow
the second of four pointers down.&lt;/p&gt;

&lt;p&gt;Finally, we come to a leaf node in the tree:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/node4.png"/&gt;&lt;/p&gt;

&lt;p&gt;And we’ve found the value 53!&lt;/p&gt;

&lt;p&gt;B-Trees speed up searches because:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They sort the values (known as &lt;em&gt;keys&lt;/em&gt;) inside of each node.&lt;/li&gt;
&lt;li&gt;They are &lt;em&gt;balanced&lt;/em&gt;: B-Trees evenly distribute the keys among the nodes,
minimizing the number of times we have to follow a pointer from one node to
another. Each pointer leads to a child node that contains more or less the
same number of keys each other child node does.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;What Does a Postgres Index Look Like?&lt;/h2&gt;

&lt;p&gt;Lehman and Yao drew this diagram over 30 years ago &amp;ndash; what does it have to do
with how Postgres works today? Astonishingly, the &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index we created earlier looks very
similar to Figure 2: We created an index in 2014 that looks just like a diagram
from 1981!&lt;/p&gt;

&lt;p&gt;When we executed the &lt;span class="code"&gt;CREATE INDEX&lt;/span&gt; command, Postgres
saved all of the names from our users table into a B-Tree. These became the
keys of the tree. Here’s what a node inside a Postgres B-Tree index looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Each entry in the index consists of a C structure called &lt;span class="code"&gt;IndexTupleData&lt;/span&gt;, and is
followed by a bitmap and a value. Postgres uses the bitmap to record whether
any of the index attributes in a key are NULL, to save space. The actual values
in the index appear after the bitmap.&lt;/p&gt;

&lt;p&gt;Let’s take a closer look at the &lt;span class="code"&gt;IndexTupleData&lt;/span&gt;
structures:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see each IndexTupleData structure contains:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class="code"&gt;t_tid&lt;/span&gt;: This is a pointer to either another index
tuple, or to a database record. Note this isn&amp;rsquo;t a C pointer to physical
memory; instead, it contains numbers Postgres can use to find the referenced
value among its memory pages.&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;t_info&lt;/span&gt;: This contains information about the index
tuple, such as how many values it contains, and whether or not there are null
values.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To understand this better, let’s show a few entries from our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/index-tuple-data3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Now I’ve replaced “value” with some names from my users table. The upper tree
node includes the keys “Dr. Edna Kunde” and “Julius Powlowski,” while the lower
tree node contains “Julius Powlowski” and “Juston Quitzon.” Notice that, unlike
Lehman and Yao’s diagram, Postgres repeats the parent keys in each child node.
Here “Julius Powlowski” is a key in the upper node and in the child node. The
&lt;span class="code"&gt;t_tid&lt;/span&gt; pointer from Julius in the upper node
references the same Julius name in the lower node.&lt;/p&gt;

&lt;p&gt;To learn more about exactly how Postgres stores key values into a B-Tree node,
refer to the itup.h C header file:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;IndexTupleData&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/itup_8h_source.html"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/itup.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Finding the B-Tree Node Containing Captain Nemo&lt;/h2&gt;

&lt;p&gt;Now let’s return to our original SELECT statement again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/select-users.png"/&gt;&lt;/p&gt;

&lt;p&gt;How exactly does Postgres search our &lt;span
class="code"&gt;index_users_on_name&lt;/span&gt; index for “Captain Nemo?” Why is
using the index faster than the sequence scan we saw in my last post? To find
out, let’s zoom out a bit and take a look at some of the user names in our
index:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/root-names1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;This is the root node of the &lt;span class="code"&gt;index_users_on_name&lt;/span&gt;
B-Tree. I’ve turned the tree on its side so the names would fit. You can see 4
names and a NULL value. Postgres created this root node when I created
&lt;span class="code"&gt;index_users_on_name&lt;/span&gt;. Note that, aside from the
first NULL value which represents the beginning of the index, the other 4 names
are more or less evenly distributed in alphabetical order.&lt;/p&gt;

&lt;p&gt;Remember that a B-Tree is a balanced tree. In this example, the B-Tree has 5 child nodes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the names that appear before Dr. Edna Kunde alphabetically&lt;/li&gt;
&lt;li&gt;names that appear between Dr. Edna Kunde and Julius Powlowski&lt;/li&gt;
&lt;li&gt;names that appear between Julius Powlowski and Monte Nicolas&lt;/li&gt;
&lt;li&gt;etc…&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Because we’re searching for Captain Nemo, Postgres follows the first, top arrow
to the right. This is because Captain Nemo comes before Dr. Edna Kunde
alphabetically:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/root-names2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;You can see on the right that Postgres has found the B-Tree node that contains
Captain Nemo. For my test I added 1000 names to the users table; this child
node in the B-Tree contained about 200 names (240 actually). The B-Tree has
narrowed down Postgres’s search considerably.&lt;/p&gt;

&lt;p&gt;To learn more about the precise algorithm Postgres uses to search for the
target B-Tree node among all of the nodes in the tree, read the &lt;span
class="code"&gt;_bt_search&lt;/span&gt; function.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;_bt_search&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nbtsearch_8c.html#a9053c37f2c25187580f3f690ad41bf01"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/bt_search.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Finding Captain Nemo Inside a Single B-Tree Node&lt;/h2&gt;

&lt;p&gt;Now that Postgres has narrowed down the search to a B-Tree node containing
about 200 names, it still has to find Captain Nemo… how does it do this? Does
it perform a sequence scan on this shorter list?&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search1.svg"/&gt;&lt;/p&gt;

&lt;p&gt;No. To search for a key value inside of a tree node, Postgres switches to use a
binary search algorithm. It starts by comparing the key that appears at the 50%
position in the tree node with “Captain Nemo:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search2.svg"/&gt;&lt;/p&gt;

&lt;p&gt;Because Captain Nemo comes after Breana Witting alphabetically, Postgres
jumps down to the 75% position and performs another comparison:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search3.svg"/&gt;&lt;/p&gt;

&lt;p&gt;This time Captain Nemo comes before Curtis Wolf, so Postgres jumps back a bit.
Skipping a few more steps (it actually took Postgres 8 comparisons to find
Captain Nemo in my example), Postgres eventually finds what we are looking for:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/binary-search4.svg"/&gt;&lt;/p&gt;

&lt;p&gt;To learn more about exactly how Postgres searches for a value in a single
B-Tree node, read the &lt;span class="code"&gt;_bt_binsrch&lt;/span&gt; function:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;_bt_binsrch&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nbtsearch_8c.html#acd3770ac6d3bc26d6f319d3255721280"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/11/11/bt_binsrch.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;So Much More to Learn&lt;/h2&gt;

&lt;p&gt;I don’t have space in this blog post to cover many other fascinating details
about B-Trees, database indexes or Postgres internals… maybe I should write
&lt;em&gt;Postgres Under a Microscope&lt;/em&gt; :) But for now, here are just a few interesting
bits of theory you can read about in &lt;a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf"&gt;Efficient Locking for Concurrent
Operations on B-Trees&lt;/a&gt; or in
the other academic papers it references.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Inserting into B-Trees: The most beautiful part of the B-Tree algorithm has
to do with inserting new keys into a tree. Key are inserted in sorted order
into the proper tree node &amp;ndash; but what happens when there’s no more room for a
new key? In this situation, Postgres splits the node into two, inserts the
new key into one of them, and also adds the key from the split point into the
parent node, along with a pointer to the new child node. Of course, the
parent node might also have to be split to fit its new key, resulting in a
complex, recursive operation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Deleting from B-Trees: The converse operation is also interesting. When
deleting a key from a node, Postgres will combine sibling nodes together when
possible, removing a key from their parent. This can also be a recursive
operation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B-Link-Trees: Lehman and Yao’s paper actually discusses an innovation they
researched related to concurrency and locking when multiple threads are using
the same B-Tree. Remember, Postgres’s code and algorithms need to be
multithreaded because many clients could be searching or modifying the same
index at the same time. By adding another pointer from each B-Tree node to
the next sibling node &amp;ndash; the so-called “right arrow” &amp;ndash; one thread can search a
tree even while a second thread is splitting a node without locking the
entire index:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/11/11/right-arrow.png"/&gt;&lt;/p&gt;

&lt;h2&gt;Don’t Be Afraid To Explore Beneath The Surface&lt;/h2&gt;

&lt;div style="float: right; padding: 22px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/11/11/at-the-helm.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo at the helm&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Professor Aronnax risked his life and career to find the elusive Nautilus and
to join Captain Nemo on a long series of amazing underwater adventures. We
should do the same: Don’t be afraid to dive underwater &amp;ndash; inside and underneath
the tools, languages and technologies that you use every day. You may know all
about how to use Postgres, but do you really know how Postgres itself works
internally? Take a look inside; before you know it, you’ll be on an underwater
adventure of your own.&lt;/p&gt;

&lt;p&gt;Studying the Computer Science at work behind the scenes of our applications
isn’t just a matter of having fun, it’s part of being a good developer. As
software development tools improve year after year, and as building web sites
and mobile apps becomes easier and easier, we shouldn’t loose sight of the
Computer Science we depend on. We’re all standing on the shoulders of giants &amp;ndash;
people like Lehman and Yao, and the open source developers who used their
theories to build Postgres. Don’t take the tools you use everyday for granted &amp;ndash;
take a look inside them! You’ll become a wiser developer and you’ll find
insights and knowledge you could never have imagined before.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Following a Select Statement Through Postgres Internals</title>
    <link href="http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/10/13/following-a-select-statement-through-postgres-internals</id>
    <published>2014-10-13T00:00:00Z</published>
    <updated>2014-10-13T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/engine-room.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax on a tour&lt;br/&gt;of the engine room, a fascinating description&lt;br/&gt;of future technology from an 1870 perspective.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the third of a series of posts based on a presentation I did at the</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/engine-room.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax on a tour&lt;br/&gt;of the engine room, a fascinating description&lt;br/&gt;of future technology from an 1870 perspective.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the third of a series of posts based on a presentation I did at the
&lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt; called “20,000 Leagues Under
ActiveRecord.” (posts:
&lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;one&lt;/a&gt;
&lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;two&lt;/a&gt;
and &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).  &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Preparing for this presentation over the Summer, I decided to read through
parts of the PostgreSQL C source code. I executed a very simple select
statement and watched what Postgres did with it using LLDB, a C debugger. How
did Postgres understand my query? How did it actually find the data I was
looking for?&lt;/p&gt;

&lt;p&gt;This post is an informal journal of my trip through the guts of Postgres. I’ll
describe the path I took and what I saw along the way. I’ll use a series of
simple, conceptual diagrams to explain how Postgres executed my query.
In case you understand C, I’ll also leave you a few landmarks and signposts you
can look for if you ever decide to hack on Postgres internals.&lt;/p&gt;

&lt;p&gt;In the end, the Postgres source code delighted me. It was clean, well
documented and easy to follow. Find out for yourself how Postgres works
internally by following me on a journey deep inside a tool you use everyday.&lt;/p&gt;

&lt;div style="clear: left"&gt;&lt;/div&gt;


&lt;h2&gt;Finding Captain Nemo&lt;/h2&gt;

&lt;p&gt;Here’s the example query from &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;the first half of my
presentation&lt;/a&gt;;
we’ll follow Postgres as it searches for Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/sql.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/maps.png"&gt;&lt;br/&gt;
  &lt;i&gt;Professor Aronnax and Captain Nemo&lt;br/&gt;plot the course of the Nautilus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Finding a single name in string column like this should be straightforward,
shouldn’t it? We’ll hold tightly onto this select statement while we explore
Postgres internals, like a rope deep sea divers use to find their way back to
the surface.&lt;/p&gt;

&lt;h2&gt;The Big Picture&lt;/h2&gt;

&lt;p&gt;What does Postgres do with this SQL string? How does it understand what we
meant? How does it know what data we are looking for?&lt;/p&gt;

&lt;p&gt;Postgres processes each SQL command we send it using a four step process.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/4-steps.png"/&gt;&lt;/p&gt;

&lt;p&gt;In the first step, Postgres &lt;em&gt;parses&lt;/em&gt; our SQL statement and converts it into a
series of C memory structures, a &lt;em&gt;parse tree&lt;/em&gt;. Next Postgres &lt;em&gt;analyzes and
rewrites&lt;/em&gt; our query, optimizing and simplifying it using a series of complex
algorithms. After that, Postgres generates a &lt;em&gt;plan&lt;/em&gt; for finding our data. Like
an obsessive compulsive person who won’t leave home without every suitcase
packed perfectly, Postgres doesn’t run our query until it has a plan. Finally,
Postgres actually &lt;em&gt;executes&lt;/em&gt; our query. In this presentation I’ll briefly touch
on the first three topics, and then focus more on the last step: &lt;em&gt;Execute&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The C function inside of Postgres that implements this 4 step process is called
&lt;span class="code"&gt;exec_simple_query&lt;/span&gt;. You can find a link to it below, along with an LLDB
backtrace which gives some context about exactly when and how Postgres calls
&lt;span class="code"&gt;exec_simple_query&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;exec_simple_query&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a7908e75bd9f9494fdb8c4b47f01a9de9"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_simple_query.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_simple_query_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Parse&lt;/h2&gt;

&lt;p&gt;How does Postgres understand the SQL string we sent it? How does it make sense
of the SQL keywords and expressions in our select statement? Through a process
called &lt;em&gt;parsing&lt;/em&gt;, Postgres converts our SQL string into an internal data
structure it understands, the parse tree.&lt;/p&gt;

&lt;p&gt;It turns out that Postgres uses the same parsing technology that Ruby does, a
&lt;em&gt;parser generator&lt;/em&gt; called &lt;a href="http://www.gnu.org/software/bison/"&gt;Bison&lt;/a&gt;. Bison
runs during the Postgres C build process and generates parser code based on a
series of grammar rules. The generated parser code is what runs inside of
Postgres when we send it SQL commands. Each grammar rule is triggered when the
generated parser finds a corresponding pattern or syntax in the SQL string,
and inserts a new C memory structure into the parse tree data structure.&lt;/p&gt;

&lt;p&gt;I won’t take the time today to explain how parsing algorithms work in detail.
If you’re interested in that sort of thing, I’d suggest taking a look at my
book &lt;a href="http://patshaughnessy.net/ruby-under-a-microscope"&gt;Ruby Under a
Microscope&lt;/a&gt;. In Chapter One
I go through a detailed example of the LALR parse algorithm used by Bison and
Ruby. Postgres parses SQL statements in exactly the same way.&lt;/p&gt;

&lt;p&gt;Using LLDB and enabling some C logging code, I observed the Postgres parser
produce this parse tree for our Captain Nemo query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/parse-tree.png"/&gt;&lt;/p&gt;

&lt;p&gt;At the top is a node representing the entire SQL statement, and below that are
child nodes or branches that represent the different portions of the SQL
statement syntax: the target list (a list of columns), the from clause (a list
of tables), the where clause, the sort order and a limit count.&lt;/p&gt;

&lt;p&gt;If you want to learn more about how Postgres parses SQL statements, follow the
flow of control down from &lt;span class="code"&gt;exec_simple_query&lt;/span&gt; through
another C function called &lt;span class="code"&gt;pg_parse_query&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;pg_parse_query&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a0449a974d1a66a2fcdee8896a0690521"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_parse_query.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_parse_query_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;As you can see there are many helpful and detailed comments in the Postgres
source code that not only explain what is happening but also point out important
design decisions.&lt;/p&gt;

&lt;h2&gt;All That Hard Work For Nothing&lt;/h2&gt;

&lt;p&gt;The parse tree above should look familiar &amp;ndash; it’s almost precisely the same as
the abstract syntax tree (AST) we saw ActiveRecord create earlier. Recall from
the &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;first half of the
presentation&lt;/a&gt;
ActiveRecord generated our Captain Nemo select statement when we executed this
Ruby query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/example1.png"/&gt;&lt;/p&gt;

&lt;p&gt;We saw that ActiveRecord internally created an AST when we called methods such
as &lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;first&lt;/span&gt;. Later
(see the &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;second
post&lt;/a&gt;),
we watched as the Arel gem converted the AST into our example select statement
using an algorithm based on the visitor pattern.&lt;/p&gt;

&lt;p&gt;Thinking about this, it’s ironic that the first thing Postgres does with your
SQL statement is convert it from a string back into an AST. Postgres’s parse
process reverses everything ActiveRecord did earlier; all of that hard work the
Arel gem did was for nothing! The only reason for creating the SQL string at
all was to communicate with Postgres over a network connection. Once Postgres
has the string, it converts it back into an AST, which is a much more
convenient and useful way of representing queries.&lt;/p&gt;

&lt;p&gt;Learning this you might ask: Is there a better way? Is there some way of
conceptually specifying the data we want to Postgres without writing a SQL
statement? Without learning the complex SQL language or paying the performance
overhead of using ActiveRecord and Arel? It seems like a waste of time to go to
such lengths to generate a SQL string from an AST, just to convert it back to
an AST again. Maybe we should be using a NoSQL database solution instead?&lt;/p&gt;

&lt;p&gt;Of course, the AST Postgres uses is much different from the AST used by
ActiveRecord. ActiveRecord’s AST was comprised of Ruby objects, while
Postgres’s AST is formed of a series of C memory structures. Same idea but very
different implementations.&lt;/p&gt;

&lt;h2&gt;Analyze and Rewrite&lt;/h2&gt;

&lt;p&gt;Once Postgres has generated a parse tree, it then converts it into a another
tree structure using a different set of nodes. This is known as the &lt;em&gt;query
tree&lt;/em&gt;. Returning to the &lt;span class="code"&gt;exec_simple_query&lt;/span&gt; C
function, you can see it next calls another C function &lt;span
class="code"&gt;pg_analyze_and_rewrite&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;pg_analyze_and_rewrite&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a66930c41c305d22f3371cad134fd3dee"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_analyze_and_rewrite.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_analyze_and_rewrite_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;Waving my hands a bit and glossing over many important details, the analyze and
rewrite process applies a series of sophisticated algorithms and heuristics to
try to optimize and simplify your SQL statement. If you had executed a complex
select statement with sub-selects and multiple inner and outer joins, then
there is a lot of room for optimization. It’s quite possible that Postgres
could reduce the number of sub-select clauses or joins to produce a simpler
query that runs faster.&lt;/p&gt;

&lt;p&gt;For our simple select statement, here’s the query tree that &lt;span
class="code"&gt;pg_analyze_and_rewrite&lt;/span&gt; produces:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/query-tree.png"/&gt;&lt;/p&gt;

&lt;p&gt;I don’t pretend to understand the detailed algorithms behind &lt;span
class="code"&gt;pg_analyze_and_rewrite&lt;/span&gt;. I simply observed that for our
example the query tree largely resembled the parse tree. This means the
select statement was so straightforward Postgres wasn’t able to simplify it further.&lt;/p&gt;

&lt;h2&gt;Plan&lt;/h2&gt;

&lt;p&gt;The last step Postgres takes before starting to execute our query is to create
a plan. This involves generating a third tree of nodes that form a list of
instructions for Postgres to follow. Here’s the plan tree for our select
statement.&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/plan-tree.png"/&gt;&lt;/p&gt;

&lt;p&gt;Imagine that each node in the plan tree is a machine or worker of some
kind. The plan tree resembles a pipeline of data or a conveyor belt in a
factory. In my simple example there is only one branch in the tree. Each node
in the plan tree takes some the output data from the node below, processes it,
and returns results as input to the node above. We’ll follow Postgres as it
executes the plan in the next section.&lt;/p&gt;

&lt;p&gt;The C function that starts the query planning process is called &lt;span
class="code"&gt;pg_plan_queries&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;pg_plan_queries&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/postgres_8c.html#a34e18d3874224b3b670ec0a3ae9c970c"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_plan_queries.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/pg_plan_queries_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;Note the &lt;span class="code"&gt;startup_cost&lt;/span&gt; and &lt;span
class="code"&gt;total_cost&lt;/span&gt; values in each plan node. Postgres uses these
values to estimate how long the plan will take to complete. You don’t have
to use a C debugger to see the execution plan for your query. Just prepend the
SQL &lt;span class="code"&gt;EXPLAIN&lt;/span&gt; command to your query, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/explain.png"/&gt;&lt;/p&gt;

&lt;p&gt;This is a powerful way to understand what Postgres is doing internally with one
of your queries, and why it might be slow or inefficient &amp;ndash; despite the
sophisticated planning algorithms in &lt;span class="code"&gt;pg_plan_queries&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Executing a Limit Plan Node&lt;/h2&gt;

&lt;p&gt;By now, Postgres has parsed your SQL statement and converted it back into an
AST. Then it optimized and rewrote your query, possibly in a simpler way.
Third, Postgres wrote a plan which it will follow to find and return the data
you are looking for. Finally it’s time for Postgres to actually execute your
query. How does it do this? It follows the plan, of course!&lt;/p&gt;

&lt;p&gt;Let’s start at the top of the plan tree and move down. Skipping the root node,
the first worker that Postgres uses for our Captain Nemo query is called Limit.
The Limit node, as you might guess, implements the &lt;span
class="code"&gt;LIMIT&lt;/span&gt; SQL command, which limits the result set to the
specified number of records. The same plan node also implements the &lt;span
class="code"&gt;OFFSET&lt;/span&gt; command, which starts the result set window at the
specified row.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/limit1.png"/&gt;&lt;/p&gt;

&lt;p&gt;The first time Postgres calls the Limit node, it calculates what the limit and
offset values should be, because they might be set to the result of some
dynamic calculation. In our example, offset is 0 and limit is 1.&lt;/p&gt;

&lt;p&gt;Next, the Limit plan node repeatedly calls the subplan, in our case Sort,
counting until it reaches the offset value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/limit2.png"/&gt;&lt;/p&gt;

&lt;p&gt;In our example the offset value is zero, so this loop will load the first data
value and stop iterating. Then Postgres returns the last data value loaded from
the subplan to the calling or upper plan. For us, this will be that first value
from the subplan.&lt;/p&gt;

&lt;p&gt;Finally when Postgres continues to call the Limit node, it will pass the data
values through from the subplan one at a time:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/limit3.png"/&gt;&lt;/p&gt;

&lt;p&gt;In our example, because the limit value is 1 Limit will immediately return NULL
indicating to the upper plan there is no more data available.&lt;/p&gt;

&lt;p&gt;Postgres implements the Limit node using code in a file called nodeLimit.c&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecLimit&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeLimit_8c.html#a9fe32874f36f4a955f5b4b762d814631"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_limit.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_limit_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;p&gt;You can see the Postgres source code uses words such as &lt;em&gt;tuple&lt;/em&gt; (a set a
values, one from each column) and &lt;em&gt;subplan&lt;/em&gt;. The subplan in this example is the
Sort node, which appears below Limit in the plan.&lt;/p&gt;

&lt;h2&gt;Executing a Sort Plan Node&lt;/h2&gt;

&lt;p&gt;Where do the data values Limit filters come from? From the Sort plan node
that appears under Limit in the plan tree. Sort loads data values from its
subplan and returns them to its calling plan, Limit. Here’s what Sort does when
the Limit node calls it for the first time, to get the first data value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/sort1.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see that Sort functions very differently from Limit. It immediately
loads all of the available data from the subplan into a buffer, before
returning anything. Then it sorts the buffer using the
&lt;a href="http://en.wikipedia.org/wiki/Quicksort"&gt;Quicksort&lt;/a&gt; algorithm, and finally
returns the first sorted value.&lt;/p&gt;

&lt;p&gt;For the second and subsequent calls, Sort simply returns additional values from
the sorted buffer, and never needs to call the subplan again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/10/13/sort2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The Sort plan node is implemented by a C function called ExecSort:&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecSort&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeSort_8c.html#afe145ec8ff9b3d3a654022f73eab2810"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_sort.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_sort_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;Executing a SeqScan Plan Node&lt;/h2&gt;

&lt;p&gt;Where does ExecSort get its values? From its subplan, or the SeqScan node that
appears at the bottom of the plan tree. SeqScan stands for &lt;em&gt;sequence scan&lt;/em&gt;, which
means to look through the values in a table, returning values that match a
given filter. To understand how the scan works with our filter, let’s step
through an imaginary users table filled with fake names, looking for Captain
Nemo.&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres starts at the first record in a table (known as a &lt;em&gt;relation&lt;/em&gt; in the
Postgres source code) and executes the boolean expression from the plan tree.
In simple terms, Postgres asks the question: “Is this Captain Nemo?” Because
Laurianne Goodwin is not Captain Nemo, Postgres steps down to the next record.&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan2.png"/&gt;&lt;/p&gt;

&lt;p&gt;No, Candace is also not Captain Nemo. Postgres continues:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan3.png"/&gt;&lt;/p&gt;

&lt;p&gt;… and eventually finds Captain Nemo!&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Postgres implements the SeqScan node using a C function called ExecSeqScan.&lt;/p&gt;

&lt;p&gt;
&lt;div class="sign"&gt;
  &lt;div class="sign-icon"&gt;&lt;/div&gt;
  &lt;div class="function-info"&gt;
    &lt;div class="function-name"&gt;ExecSeqScan&lt;/div&gt;
    &lt;div class="function-link"&gt;&lt;a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html#af80d84501ff7621d2ef6249b148e7f44"&gt;view on postgresql.org&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="function-code"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_seq_scan.png"/&gt;
  &lt;/div&gt;
  &lt;div class="function-bt"&gt;
    &lt;img src="http://patshaughnessy.net/assets/2014/10/13/exec_seq_scan_bt.png"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;


&lt;h2&gt;What Are We Doing Wrong?&lt;/h2&gt;

&lt;p&gt;Now we’re done! We’ve followed a simple select statement all the way through
the guts of Postgres, and have seen how it was parsed, rewritten, planned and finally
executed. After executing many thousands of lines of C code, Postgres has found the
data we are looking for! Now all Postgres has to do is return the Captain Nemo
string back to our Rails application and ActiveRecord can create a Ruby object.
We can finally return to the surface of our application.&lt;/p&gt;

&lt;p&gt;But Postgres doesn’t stop! Instead of simply returning, Postgres continues to
scan through the users table, even though we’ve already found Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img class="centered" src="http://patshaughnessy.net/assets/2014/10/13/seqscan5.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 117px 0px 70px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/10/13/suffocating.png"&gt;&lt;br/&gt;
  &lt;i&gt;While returning from the South Pole, the air&lt;br/&gt; supply inside the Nautilus began to run out.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;What’s going on here? Why is Postgres wasting its time, continuing to search
even though it’s already found the data we’re looking for?&lt;/p&gt;

&lt;p&gt;The answer lies farther up the plan tree in the Sort node. Recall that in order
to sort all of the users, ExecSort first loads all of the values into a buffer,
by calling the subplan repeatedly until there are no values left. That means
that &lt;em&gt;ExecSeqScan will continue to scan to the end of the table&lt;/em&gt;, until it has
all of the matching users. If our users table contained thousands or even
millions of records (imagine we work at Facebook or Twitter), ExecSeqScan will
have to loop over every single user record and execute the string comparison
for each one. This is obviously inefficient and slow, and will get slower as
more and more user records are added.&lt;/p&gt;

&lt;p&gt;If we have only one Captain Nemo record, then ExecSort will “sort” just that
single matching record, and ExecLimit will pass that single record through its
offset/limit filter… but only after ExecSeqScan has iterated over all of the
names.&lt;/p&gt;

&lt;h2&gt;Next Time&lt;/h2&gt;

&lt;p&gt;How do we fix this problem? What should we do if our SQL queries on the users
table take more and more time to execute? The answer is simple: we  create an
index.&lt;/p&gt;

&lt;p&gt;In the next and final post in this series we’ll learn how to create a Postgres
index and to avoid the use of ExecSeqScan. More importantly, I’ll show you what
a Postgres index looks like: &lt;em&gt;how&lt;/em&gt; it works and &lt;em&gt;why&lt;/em&gt; it speeds up queries like
this one.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How Arel Converts Ruby Queries Into SQL Statements</title>
    <link href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements</id>
    <published>2014-09-23T00:00:00Z</published>
    <updated>2014-09-23T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/battle.png"&gt;&lt;br/&gt;
  &lt;i&gt;In one of the climactic scenes in &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the&lt;br/&gt;Sea&lt;/a&gt;, Captain Nemo and his crew battle a giant octopus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the second in a serie</summary>
    <content type="html">&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/battle.png"&gt;&lt;br/&gt;
  &lt;i&gt;In one of the climactic scenes in &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the&lt;br/&gt;Sea&lt;/a&gt;, Captain Nemo and his crew battle a giant octopus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the second in a series of posts based on a presentation I did at the
&lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt; called “20,000 Leagues Under
ActiveRecord” (&lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video&lt;/a&gt;).&lt;/b&gt; I took an innocent and unsuspecting audience on an adventure
inside and underneath ActiveRecord to find out how Rails and PostgreSQL
actually execute a simple SQL query.&lt;/p&gt;

&lt;p&gt;In the &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;first part of the
presentation&lt;/a&gt;
I showed what ActiveRecord does internally when you call methods such as &lt;span
class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;limit&lt;/span&gt;. We saw how each
scoping method returns a new instance of the &lt;span
class="code"&gt;ActiveRecord::Relation&lt;/span&gt; class, gradually building up a
description of your query.&lt;/p&gt;

&lt;p&gt;Today I’ll continue by looking at what ActiveRecord does next: How it uses the
Arel gem to convert the &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; object
describing your query into a string containing a SQL statement. Later, in the
third post we’ll dive down inside the PostgreSQL database server itself to see
how it executes this SQL statement.&lt;/p&gt;

&lt;h2&gt;The Arel Gem&lt;/h2&gt;

&lt;p&gt;Here again is the instance of the &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; class that represents
our query to find the user named “Captain Nemo:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/ar-relation1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now that we’ve specified the query we want to execute, what does ActiveRecord
do next? How does it actually execute the query and return the results to us?
We can find a clue by looking more closely at the relation object and the
metadata values it stores:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/AR-Relation2.png"/&gt;&lt;/p&gt;

&lt;p&gt;If you inspect an &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; object in
the Rails console, you’ll find that its instance variables are not simple
values, but instead references to other Ruby objects. These objects have class
names such as &lt;span class="code"&gt;Arel::Nodes::Equality&lt;/span&gt; and &lt;span
class="code"&gt;Arel::Nodes::Attribute&lt;/span&gt;. What are these Ruby objects?  Where
are they created? What do these class names mean?&lt;/p&gt;

&lt;p&gt;It turns out that ActiveRecord itself doesn’t convert your
&lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; query to SQL; instead, it uses
a separate gem called Arel to do that. Googling for “Arel” we can easily find
its Github repo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel1.png"/&gt;&lt;br/&gt;
&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The gem’s description is simply “A Relational Algebra.” What in the world does
this mean? And farther down in the Readme there’s another interesting line:
“Arel is a SQL AST manager for Ruby.” What does “AST” mean, and what does an
“AST manager” do?&lt;/p&gt;

&lt;p&gt;AST stands for “Abstract Syntax Tree,” an important concept from computer
science. I’ll explain what that means in a minute. But first let’s look at some
computer science history to find out what Relational Algebra is.&lt;/p&gt;

&lt;h2&gt;Relational Algebra&lt;/h2&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/codd.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Edgar Codd&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Relational Algebra is a branch of computer science that forms the mathematical
foundation underpinning relational database servers and the SQL language. An
influential computer scientist named &lt;a href="http://en.wikipedia.org/wiki/Edgar_F._Codd"&gt;Edgar
Codd&lt;/a&gt; first described Relational
Algebra in his groundbreaking academic paper &lt;a href="http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf"&gt;A Relational Model of Data for
Large Shared Data Banks&lt;/a&gt;,
published in 1970. Codd described the term “relation” as follows:&lt;/p&gt;

&lt;blockquote&gt;
1.3. A RELATIONAL VIEW OF DATA&lt;br/&gt;
The term relation is used here in its accepted mathematical sense. Given sets
S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ... , S&lt;sub&gt;n&lt;/sub&gt;, (not necessarily distinct), R is a relation on
these n sets if it is a set of n-tuples each of which has its first element
from S&lt;sub&gt;1&lt;/sub&gt;, its second element from S&lt;sub&gt;2&lt;/sub&gt;, and so on.
&lt;/blockquote&gt;


&lt;p&gt;He later went on to define various mathematical operations on relations,
including &lt;em&gt;projection&lt;/em&gt;, &lt;em&gt;restriction&lt;/em&gt;, and &lt;em&gt;join&lt;/em&gt;. He also used terms such as &lt;em&gt;normal
form&lt;/em&gt;, &lt;em&gt;primary key&lt;/em&gt; and &lt;em&gt;foreign key&lt;/em&gt;. Today, almost 45 years later, we still use
Codd’s terminology and the associated mathematical theories when discussing
database tables and queries.&lt;/p&gt;

&lt;p&gt;In another interesting passage, Codd wrote about the need for a language we
could use to articulate and describe Relational Algebra concepts:&lt;/p&gt;

&lt;blockquote&gt;
1.5. SOME LINGUISTIC ASPECTS&lt;br/&gt;
The adoption of a relational model of data, as described above, permits the
development of a universal data sublanguage based on an applied predicate
calculus.
&lt;/blockquote&gt;


&lt;p&gt;This “universal sublanguage” is the Structured Query Language or SQL. I find
the term “sublanguage” to be very appropriate; SQL is a language used inside
larger applications written in some other programming language, such as Ruby.&lt;/p&gt;

&lt;p&gt;Returning to our example, here’s the SQL statement that represents our search
for the user named Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/sql.png"/&gt;&lt;/p&gt;

&lt;p&gt;The SQL language existed before Codd wrote his paper on Relational Algebra in
1970, but it didn’t resemble the version of SQL we all know and love today. The
mathematical concepts Codd first described form the basis for the modern
version of SQL.&lt;/p&gt;

&lt;p&gt;Now let’s return to the question of what an “AST manager” is.&lt;/p&gt;

&lt;h2&gt;Abstract Syntax Trees&lt;/h2&gt;

&lt;p&gt;An abstract syntax tree is a hierarchical arrangement of objects or memory
structures that represent a series of words or some syntax from a text
language. In this case, the AST inside of Arel is a tree of Ruby objects that
represents a SQL statement.&lt;/p&gt;

&lt;p&gt;Here’s the AST Arel creates internally for our example query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree1.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the top or root of the tree is a Ruby object called
&lt;span class="code"&gt;SelectStatement&lt;/span&gt;, and under that the various branches
of the tree represent the from, where, order by and limit clauses in our
select statement.&lt;/p&gt;

&lt;p&gt;The Arel gem “is a Relational Algebra” in the sense that it provides a Ruby API
that contains methods such as &lt;span class="code"&gt;project&lt;/span&gt;, &lt;span
class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;order&lt;/span&gt; that represent
concepts from Relational Algebra. Internally, these methods create Ruby objects
and save them in the AST. Arel’s API is similar to ActiveRecord’s, but is
somewhat more granular and detailed. When we call ActiveRecord methods such as
&lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;limit&lt;/span&gt;, internally
ActiveRecord calls the corresponding methods in the Arel gem.&lt;/p&gt;

&lt;p&gt;Here’s our example query written using both ActiveRecord (top) and Arel
(bottom) method calls:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel-and-ar.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 60px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/window.png"&gt;&lt;br/&gt;
  &lt;i&gt;Professor Aronnax, Conseil and Ned Land spent hours marveling&lt;br/&gt;at the underwater world through the windows of the Nautilus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Notice the Arel query is longer and more verbose. Expressing our query using Arel we call:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class="code"&gt;project&lt;/span&gt; to specify which columns or attributes we
are looking for (&lt;em&gt;projection&lt;/em&gt; in Codd’s Relational Algebra)&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;eq&lt;/span&gt; to specify
how to filter the result set (&lt;em&gt;restriction&lt;/em&gt; in Relational Algebra)&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;order&lt;/span&gt; to specify the sort order, and&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;limit&lt;/span&gt; to specify how many records we want.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Each time you call an ActiveRecord scoping method, it calls down into one of
these Arel methods, inserting objects into the same AST.&lt;/p&gt;

&lt;h2&gt;The Visitor Pattern&lt;/h2&gt;

&lt;p&gt;Creating an AST containing Ruby objects is one thing, but generating an actual
SQL statement is another. How does Arel do this? Why is building up an AST
useful in any way?&lt;/p&gt;

&lt;p&gt;Using a very elegant algorithm, Arel iterates over the nodes in the AST and
concatenates different SQL fragments to form a complete SQL statement. This
algorithm is an example of the “visitor pattern.” The term visitor pattern
simply means that some object, function or other piece of code is executed once
for each node in some data structure, such as an array, linked list or tree.&lt;/p&gt;

&lt;p&gt;To understand this a bit better, let’s take our example AST and follow Arel’s
visitor as it traverses the tree, starting at the &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; root node:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The blue arrow at the top is the visitor, a Ruby object. Depending on which
database server you are using, Arel creates a different visitor object. This is
a fascinating detail about Arel’s internal design: Arel can generate different
variations of SQL equally well by using different visitor objects. If you
connect your Rails app to SQLite, Arel uses a SQLite visitor. If you are using
MySQL, Arel uses a MySQL visitor. Because we’re using PostgreSQL today, Arel
creates a Postgres visitor.&lt;/p&gt;

&lt;h2&gt;Visiting All the Nodes in the AST&lt;/h2&gt;

&lt;p&gt;Now let’s follow Arel’s visitor as it iterates over the Ruby objects in the
AST, shown as a moving blue arrow. Above each diagram I’ll show the SQL string
the visitor cumulatively builds up as it goes.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree2b.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see the visitor arrow next to the &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; node. Above the diagram I’ve written the
word “SELECT.” Arel’s visitor knows to write SELECT when it encounters &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; root node.&lt;/p&gt;

&lt;p&gt;Next Arel moves down to the left:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree3.png"/&gt;&lt;/p&gt;

&lt;p&gt;This time Arel doesn’t write anything new into the string; &lt;span
class="code"&gt;SelectCode&lt;/span&gt; is just a container for other branches of the
tree.&lt;/p&gt;

&lt;p&gt;Next, Arel moves down and left again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now Arel’s visitor see the &lt;span class="code"&gt;Attribute&lt;/span&gt; node. This
represents the projection or list of attributes we want in the result set. Arel
appends &lt;span class="code"&gt;&amp;quot;users&amp;quot;.*&lt;/span&gt; to the SQL string.&lt;/p&gt;

&lt;p&gt;Next, the visitor moves to the right:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree5.png"/&gt;&lt;/p&gt;

&lt;p&gt;Encountering the &lt;span class="code"&gt;JoinSource&lt;/span&gt; node, Arel writes &lt;span
class="code"&gt;FROM &amp;quot;users&amp;quot;&lt;/span&gt; onto the end of the SQL statement. &lt;span
class="code"&gt;JoinSource&lt;/span&gt; and its child nodes list the tables that our
query will read from. In this example, we don’t have any joins and just a
single table, so &lt;span class="code"&gt;JoinSource&lt;/span&gt; has only one &lt;span
class="code"&gt;Table&lt;/span&gt; child node.&lt;/p&gt;

&lt;p&gt;Next, the visitor moves to the right again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree6.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now Arel writes the where clause for our SQL statement: &lt;span class="code"&gt;WHERE &amp;quot;users&amp;quot;.&amp;quot;name&amp;quot; =
$1&lt;/span&gt;. The &lt;span class="code"&gt;And&lt;/span&gt; node is the root of a subbranch of the AST that represents the
boolean expression we want the database server to use to filter our result set.
In our example we are only checking that the name column equals “Captain Nemo”
so the AST contains a single &lt;span class="code"&gt;Equality&lt;/span&gt; node under
&lt;span class="code"&gt;And&lt;/span&gt;. The &lt;span class="code"&gt;And&lt;/span&gt; node doesn’t
really do anything in this case.&lt;/p&gt;

&lt;p&gt;Now the visitor continues to the right:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree7.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see Arel finds the &lt;span class="code"&gt;Ascending&lt;/span&gt; node and appends our order by clause.&lt;/p&gt;

&lt;p&gt;Finally, the visitor moves to the right one last time:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree8.png"/&gt;&lt;/p&gt;

&lt;p&gt;Finding the &lt;span class="code"&gt;Limit&lt;/span&gt; node, Arel’s visitor completes the
SQL statement by concatenating &lt;span class="code"&gt;LIMIT 1&lt;/span&gt; onto our select statement.&lt;/p&gt;

&lt;p&gt;Using the visitor pattern in this way, Arel has converted our query from a
collection of Ruby objects into a single string containing a SQL select
statement. Arel has expressed our Ruby query using Codd’s Relational Algebra.&lt;/p&gt;

&lt;p&gt;Every time you execute a simple database query using ActiveRecord in your Rails
app, you are relying on a series of elegant algorithms and computer science
theories developed many years ago. Rails is so simple and easy to use only
because we are standing on the shoulders of giants &amp;ndash; computer scientists like
Edgar Codd &amp;ndash; who have already done the difficult theoretical work that makes
building apps today possible.&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/south-pole.png"&gt;&lt;br/&gt;
  &lt;i&gt;A citizen of no country, Captain Nemo claimed the &lt;br/&gt;south pole as his own using a black flag with a large "N."&lt;/i&gt;
&lt;/div&gt;


&lt;h2&gt;Why Stop Here?&lt;/h2&gt;

&lt;p&gt;We’ve learned a lot about ActiveRecord and the Arel gem. Now we know what
happens when we call scoping methods such as &lt;span class="code"&gt;where&lt;/span&gt;
and &lt;span class="code"&gt;first&lt;/span&gt;. We’ve seen how ActiveRecord calls Arel’s
lower level, more granular API, and now we know how Arel uses the visitor
pattern and an AST to convert these Ruby method calls into a SQL string.&lt;/p&gt;

&lt;p&gt;But why stop here? Why not dive even deeper? … farther below the surface of
your Rails app into the PostgreSQL server itself! Next we’ll leave the world of
Ruby entirely and look at what the Postgres server does when it receives this
select statement. How does it understand the SQL we send it? How does it
actually find our data, the user record with the name “Captain Nemo?” In my next
post, I’ll continue our underwater adventure by looking at Postgres internals.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>20,000 Leagues Under ActiveRecord</title>
    <link href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord</id>
    <published>2014-09-17T00:00:00Z</published>
    <updated>2014-09-17T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/title.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;First published in 1870, &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the Sea&lt;/a&gt;&lt;br/&gt;describes an underwater adventure that takes place&lt;br/&gt;onboard a submarine called the “Nautilus.”&lt;/i&gt;
&lt;/div&gt;


</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/title.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;First published in 1870, &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the Sea&lt;/a&gt;&lt;br/&gt;describes an underwater adventure that takes place&lt;br/&gt;onboard a submarine called the “Nautilus.”&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the first in a series of posts based on a presentation I just did
last Friday at the &lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt;. You can
also watch the &lt;a href="https://www.youtube.com/watch?v=rnLnRPZZ1Q4"&gt;video recording of the
presentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Let me start with a question: How many of you have actually read 20,000 Leagues
Under the Sea, either in the original French or in some translation? [ A few
people raised their hands, but most people in the audience did not. ] Yes, I’m
not surprised. 20,000 Leagues is one of those classic novels we have all heard
of, but few of us take the time to read.&lt;/p&gt;

&lt;p&gt;While thinking about this presentation over the Summer, I decided to actually
read the novel &amp;ndash; and I’m glad that I did! It blew my mind on a number of
different levels. Today I’m going to take the time to tell you a bit about the
novel itself as we go.&lt;/p&gt;

&lt;p&gt;However, actually I’m here today to talk about ActiveRecord. I’d like to explore
how ActiveRecord works internally; how it finds the information we ask for and
returns it to us as a Ruby object.&lt;/p&gt;

&lt;div style="clear: left"/&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/example1.png"/&gt;&lt;/p&gt;

&lt;p&gt;But why talk about ActiveRecord? We all know how to use ActiveRecord; most of
you understand exactly what this line of code does. You didn’t need to come to
Barcelona to learn how to use ActiveRecord.&lt;/p&gt;

&lt;p&gt;The reason why I want to discuss this is that ActiveRecord hooked me; it
first got me excited about using Rails. I came across Rails back in 2008, about
six years ago now. And I can still remember the moment when I first typed a
line of code similar to this one into the Rails console or into a Rails app
somewhere. It was amazing!  Before that I was using PHP or Java &amp;ndash; I’ve since
blocked out all memory of that so I’m not quite sure which it was :) &amp;ndash; and when
I saw how easy it was to use Rails to query a database I was very impressed.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/irb.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/underwater-walk.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax, Conseil and Ned Land&lt;br/&gt;on a hike through an underwater “forest.” Verne’s novel has&lt;br/&gt;many beautiful, detailed descriptions of underwater worlds&lt;br/&gt;he had never actually seen, and could only imagine.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Somehow Rails could take a simple, beautiful and readable line of Ruby code and
convert it into a SQL statement like this. How could this possibly work? It
seemed like magic!&lt;/p&gt;

&lt;p&gt;But it’s not magic. There are thousands of lines of code and years of computer
science research behind this simple line of code, the hard work behind the
scenes that makes ActiveRecord queries possible.&lt;/p&gt;

&lt;p&gt;Just as Professor Aronnax went on an underwater adventure with Captain Nemo,
I’d like to take you on an adventure inside of ActiveRecord to find out how it
works, how ActiveRecord generates and executes SQL statements.&lt;/p&gt;

&lt;p&gt;And why stop there? Later we’ll dive underneath ActiveRecord and inside an
actual database server to find out how it works too. How does it understand the SQL
statements we give it? How does it find the data we ask for and return it to
us? Let’s find out!&lt;/p&gt;

&lt;h2&gt;Agenda&lt;/h2&gt;

&lt;p&gt;Here’s our plan: First we’ll start with a look at &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;, the top, public API for
ActiveRecord many of you use everyday. Then, we’ll look deeper inside of
ActiveRecord to find out how it converts our Ruby queries into SQL statements.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/agenda.png"/&gt;&lt;/p&gt;

&lt;p&gt;Later, in the second half of the presentation we’ll dive even deeper and
directly into an actual relational database server (RDBMS); today I’ll use
PostgreSQL as an example. How does Postgres understand the SQL statement that
ActiveRecord sent it? How does it find the data we want? Finally, if we have
time we’ll look at the B-Tree Algorithm, which is part of the real magic that
allows database servers to work.&lt;/p&gt;

&lt;h2&gt;ActiveRecord::Relation&lt;/h2&gt;

&lt;p&gt;Let’s use my line of code from earlier as an example &amp;ndash; today we’ll be searching
for Captain Nemo together. Therefore, we’ll start with a &lt;span
class='code'&gt;User&lt;/span&gt; class, a subclass of &lt;span
class='code'&gt;ActiveRecord::Base&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-base.png"/&gt;&lt;/p&gt;

&lt;p&gt;When I call &lt;span class='code'&gt;where&lt;/span&gt; what happens? It turns out the
&lt;span class='code'&gt;where&lt;/span&gt; method is defined in the &lt;span
class='code'&gt;ActiveRecord::Querying&lt;/span&gt; module:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-querying.png"/&gt;&lt;/p&gt;

&lt;p&gt;But as you can see, ActiveRecord delegates the &lt;span class='code'&gt;where&lt;/span&gt;
method over to another method called &lt;span class='code'&gt;all&lt;/span&gt;, which
returns a new instance of a different class called &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;. In fact, my call to &lt;span
class='code'&gt;User.where&lt;/span&gt; is entirely equivalent to calling &lt;span
class='code'&gt;User.all.where&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/user-all.png"/&gt;&lt;/p&gt;

&lt;p&gt;ActiveRecord actually implements the &lt;span class='code'&gt;where&lt;/span&gt; method
using the new instance of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;.
Internally, &lt;span class='code'&gt;where&lt;/span&gt; is implemented by the &lt;span
class='code'&gt;ActiveRecord::QueryMethods&lt;/span&gt; module, included into &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;.  Next, &lt;span
class='code'&gt;ActiveRecord::QueryMethods#where&lt;/span&gt; returns, in turn, a second
new instance of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-relation1.png"/&gt;&lt;/p&gt;

&lt;p&gt;If you look at the right, you can see the second &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object contains information about
what record we’re looking for, that we want the records where the name is
“Captain Nemo.”&lt;/p&gt;

&lt;p&gt;Of course, we don’t want all of the Captain Nemo users; we just
want the first one. Next, we call the &lt;span class='code'&gt;first&lt;/span&gt; method on
the new &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/activerecord-relation2.png"/&gt;&lt;/p&gt;

&lt;h2&gt;The Internal Implementation of ActiveRecord::FinderMethods#first&lt;/h2&gt;

&lt;p&gt;Now you can see ActiveRecord creates a third instance of &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;
&amp;ndash; this time with even more information about the query we’d like to execute.
  But what are all those other values: &lt;span class='code'&gt;order&lt;/span&gt;, &lt;span
  class='code'&gt;limit&lt;/span&gt; and &lt;span class='code'&gt;offset&lt;/span&gt;? Where do they
  come from? We can find out by taking a look at the implementation of &lt;span
  class='code'&gt;first&lt;/span&gt;. The &lt;span
  class='code'&gt;ActiveRecord::FinderMethods&lt;/span&gt; module implements this, which
  ActiveRecord includes into the &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; class.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/first1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see because we didn’t pass in a value for &lt;span class='code'&gt;limit&lt;/span&gt;, ActiveRecord
calls &lt;span class='code'&gt;find_nth&lt;/span&gt; and passes in a value of 0,
indicating we want the first record from the query result set. The second
argument, &lt;span class='code'&gt;offset_index&lt;/span&gt;, turns out to have a value of
zero, meaning we want to count into a window of records at the beginning of the
result set, not a window located somewhere farther along the result set.&lt;/p&gt;

&lt;p&gt;ActiveRecord implements a series of similar methods that will return the
second, third, fourth or even fifth record:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/second-fifth.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the pattern here; the first argument is a zero-based index
indicating which record we want. And just in case we want the forty second
record from the result set, ActiveRecord implements this useful method&amp;hellip; :)&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/forty-second.png"/&gt;&lt;/p&gt;

&lt;p&gt;It’s no joke! &lt;span class='code'&gt;forty_two&lt;/span&gt; is actually in the
ActiveRecord source code; you can try it for yourself. Replacing &lt;span
class='code'&gt;first&lt;/span&gt; with the equivalent call to &lt;span
class='code'&gt;find_nth&lt;/span&gt;, here’s our example again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/find-nth.png"/&gt;&lt;/p&gt;

&lt;p&gt;Following the code path through the &lt;span
class='code'&gt;ActiveRecord::FinderMethods&lt;/span&gt; module, we can see &lt;span
class='code'&gt;find_nth&lt;/span&gt; calls, in turn, &lt;span
class='code'&gt;find_nth_with_limit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/find-nth-with-limit.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now the arguments have been reversed; the first argument, 0, is now the offset
and the second, 1, is the number of records we want, or the limit value.&lt;/p&gt;

&lt;p&gt;Substituting one more time, let’s replace &lt;span
class='code'&gt;find_nth_with_limit&lt;/span&gt; with more detailed calls it makes to
&lt;span class='code'&gt;order&lt;/span&gt; and &lt;span class='code'&gt;limit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/detailed-calls.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now you can see where all of the values in the final &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object come from. Each call to a
scoping method saves a new piece of information about our query, and returns a
new instance of the &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; class.
(We’ll see what &lt;span class='code'&gt;arel_table&lt;/span&gt; means in a minute.)&lt;/p&gt;

&lt;h2&gt;The Beauty of ActiveRecord::Relation&lt;/h2&gt;

&lt;p&gt;Taking a step back, we can see that our simple line of code, &lt;span
class='code'&gt;User.where(name: &amp;quot;Captain Nemo&amp;quot;).first&lt;/span&gt;, is creating a
series of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; objects like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/method-chain.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/17/south-pacific.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo allowed Canadian harpoonist Ned Land&lt;br/&gt;to leave the submarine for a short time and explore a&lt;br/&gt;tropical island off the coast of Papua New Guinea.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;There are two interesting and beautiful things about this, I think. First,
notice the pattern that ActiveRecord uses: each call to a method returns a new
instance of the class that implemented that method. This is what allows us to
easily chain together different method calls. We can add on as many different
scopes as we wish; because each new object is also an &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;, it implements all of the same
methods. You can use the same pattern in your own code. All you need to do is
create a new instance of the class that implements each method, and return
that. One reason to study internal code like this is to learn about and find
new ideas that you can use in your own code.&lt;/p&gt;

&lt;p&gt;The second beautiful thing about &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; is that it’s lazy.  Using this chain
of method calls we are building up metadata or information about our query,
without actually executing the query itself. It’s almost as if we were using a
functional programming language like Haskell or Lisp. Using this trick,
ActiveRecord allows us to specify exactly the query we want, without having to
worry about executing it until we’re ready.&lt;/p&gt;

&lt;p&gt;It’s not until we call the &lt;span class='code'&gt;to_a&lt;/span&gt; method, in other to convert the
&lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object into an array and access the result set, that
ActiveRecord executes the query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/17/to-a.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see here that &lt;span class='code'&gt;to_a&lt;/span&gt; calls &lt;span class='code'&gt;load&lt;/span&gt; internally,
which later calls the &lt;span class='code'&gt;DatabaseStatements#select_all&lt;/span&gt;
method. Note the &lt;span class="code"&gt;find_nth_with_limit&lt;/span&gt; method calls
&lt;span class="code"&gt;to_a&lt;/span&gt;, so &lt;span class="code"&gt;first&lt;/span&gt;,
&lt;span class="code"&gt;second&lt;/span&gt; and &lt;span class="code"&gt;forty_two&lt;/span&gt; are
not lazy and will all execute the query immediately. Because of this, these are
known as “terminating methods.” To prevent the query from executing immediately &amp;ndash;
to keep it lazy &amp;ndash; just use &lt;span class="code"&gt;order&lt;/span&gt; and &lt;span
class="code"&gt;limit&lt;/span&gt; instead.&lt;/p&gt;

&lt;h2&gt;Next time&lt;/h2&gt;

&lt;p&gt;In the next few days I’ll post &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;the second part of my presentation from
Barcelona&lt;/a&gt;.
We’ll look at what “Relational Algebra” means and how the Arel gem converts our
&lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object into a string
containing a SQL statement.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>A Rule of Thumb for Strong Parameters</title>
    <link href="http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters</id>
    <published>2014-06-16T00:00:00Z</published>
    <updated>2014-06-16T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/6/16/security.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;It can be hard to open the Strong Parameters&lt;br/&gt;door and let permitted values into your Rails 4 app.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last week I banged my head against the wall for a few hours trying to figure
out how to whitelist input values for my Rails 4 app</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/6/16/security.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;It can be hard to open the Strong Parameters&lt;br/&gt;door and let permitted values into your Rails 4 app.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last week I banged my head against the wall for a few hours trying to figure
out how to whitelist input values for my Rails 4 app using the &lt;a href="http://edgeguides.rubyonrails.org/action_controller_overview.html#strong-parameters"&gt;Strong
Parameters&lt;/a&gt;
feature. Calling &lt;span class="code"&gt;permit&lt;/span&gt; when you have a simple
attributes hash for a single new object is straightforward, but figuring out
how to call &lt;span class="code"&gt;permit&lt;/span&gt; for a complex, nested set of attributes can be nearly
impossible.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;TL;DR:&lt;/b&gt; Use this rule of thumb when trying to figure out how to whitelist nested attributes:&lt;/p&gt;

&lt;blockquote&gt;To Permit a Hash, Pass an Array&lt;br/&gt;
  To Permit an Array, Pass a Hash&lt;/blockquote&gt;


&lt;p&gt;After studying the problem for a while, I noticed this curious pattern: To whitelist a simple hash of attributes, you pass
&lt;span class="code"&gt;permit&lt;/span&gt; an array. To whitelist an array of nested objects, you pass it a hash,
including that hash in the surrounding array.&lt;/p&gt;

&lt;p&gt;Not familiar with Strong Parameters yet? What do I mean by “whitelist?” Why do
you need this rule of thumb? My post today will explain.&lt;/p&gt;

&lt;h2&gt;To Permit a Hash, Pass an Array&lt;/h2&gt;

&lt;p&gt;Rails 4 requires you to whitelist or authorize input values for your app. This
important new feature, known as Strong Parameters, adds an extra layer of
security that prevents attackers from posting harmful or garbage information to
your site.&lt;/p&gt;

&lt;p&gt;Here’s how it works: Suppose you have a &lt;span class="code"&gt;Post&lt;/span&gt; model
with title and body columns. Using Rails 4, you would write a create controller
action like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/simple_controller.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you first tell Rails which attributes are allowed for new post objects &amp;ndash;
title and body in this example &amp;ndash; and then you create the new post. This is
simple enough and quite readable. You are telling Rails: “data for a post is
required and it’s attributes may only include title and body attributes.”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/diagram1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In the diagram above you can see the post attribute hash on the left, and the
arguments for &lt;span class="code"&gt;permit&lt;/span&gt; on the right. Notice the arguments are actually a
single array (internally Rails processes the arguments as an array). Each key/value pair on the left maps to an array element on the
right. You permit a hash by passing an array.&lt;/p&gt;

&lt;h2&gt;Strong Parameters Confusion&lt;/h2&gt;

&lt;p&gt;However, now suppose you add a second model to your app, &lt;span
  class="code"&gt;Comment&lt;/span&gt;. Let’s suppose a post has many comments, and each
comment has a single text attribute.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/has-many.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because your app is a REST-ful JSON service (what else do people use Rails for
these days?) you have a requirement to create a post and its comments from a
single JSON string:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/json.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because the comment array is named “comments” you assume ActiveRecord will
create the associated comment models along with the new post. That is,
ActiveRecord should call &lt;span class="code"&gt;comments=&lt;/span&gt; on the new post
and pass in the comment attributes. But it doesn’t work. Instead, using the
code from earlier you get:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/warning.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Ah &amp;ndash; you forgot to whitelist the comments attribute. You try adjusting the call
to &lt;span class="code"&gt;permit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/permit-comments.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;It still doesn’t work. You get the same warning:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/warning.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Clearly Rails isn’t listening! You just told it comments is permitted &amp;ndash; why
does Rails give you the same warning again? Maybe you need to create the
comment objects yourself, as a separate step:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/create-comments.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now things are even worse: Rails raises an exception!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/exception.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The problem here is that the &lt;span class="code"&gt;Comment&lt;/span&gt; model is
complaining that you haven’t whitelisted its attributes. Somehow each
ActiveRecord model has knowledge about which attributes were whitelisted and
which weren’t!&lt;/p&gt;

&lt;p&gt;If you happened to know that Rails 4 saves the parameters inside an &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object, you could try
creating a separate instance of this class for each comment, and whitelist it&amp;rsquo;s text attribute directly:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/permit-comments2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But you’ll still get the same “Unpermitted parameters” warning when you try to
create the post next &amp;ndash; not to mention that your code has become incredibly
confusing and verbose. What’s going on here? There must be some way of creating
nested objects without warnings or exceptions.&lt;/p&gt;

&lt;h2&gt;To Permit an Array, Pass a Hash&lt;/h2&gt;

&lt;p&gt;The solution is to permit all the post and comment attributes with a single
call to &lt;span class="code"&gt;ActionController::Parameters#permit&lt;/span&gt;, like
this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/nested-solution.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;What? What does the complex argument list to &lt;span class="code"&gt;permit&lt;/span&gt; mean? How in the world
would anyone know to pass that in?&lt;/p&gt;

&lt;p&gt;My rule of thumb can help. In this example, you are permitting an array of
comments by passing a hash. Imagine if your app received a post with two
comments, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/diagram2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left you see the nested attributes for the post and its comments. Rails
has parsed this for you from a JSON string. On the right are the arguments you
pass to &lt;span class="code"&gt;permit&lt;/span&gt;. Notice how the hash of post
attributes contains an array for the comments &amp;ndash; in the call to &lt;span class="code"&gt;permit&lt;/span&gt; you
replace this array with a hash! To permit an array, pass a hash.&lt;/p&gt;

&lt;p&gt;This hash, in turn, contains an array listing the attributes of each comment
object (just &lt;span class="code"&gt;[:text]&lt;/span&gt; here).&lt;/p&gt;

&lt;h2&gt;Whitelisting Rails Nested Attributes&lt;/h2&gt;

&lt;p&gt;Note: if your Rails app was in fact a web site, you might use the Rails nested
attributes feature with a complex HTML form. In this case, you would declare
that posts accept nested attributes for comments, directing ActiveRecord to
automatically create the comment objects for you:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/accepts-nested.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;To make this work you will need to adjust your call to &lt;span
class="code"&gt;permit&lt;/span&gt; slightly:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/nested-attribs-permit.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;With &lt;span class="code"&gt;accepts_nested_attribute_for&lt;/span&gt;, Rails expects the
comments to be saved as &lt;span class="code"&gt;comments_attributes&lt;/span&gt;. Also,
each comment must have an &lt;span class="code"&gt;id&lt;/span&gt; attribute in order for
the web forms to update existing comments properly. (Also, Rails represents the
comment array as a hash, with the id as the key for each comment.)&lt;/p&gt;

&lt;p&gt;But the syntax is almost the same, and the same rule applies: to permit an
array of comments you call &lt;span class="code"&gt;permit&lt;/span&gt; with a hash.&lt;/p&gt;

&lt;h2&gt;Under the Hood&lt;/h2&gt;

&lt;p&gt;Internally, Rails uses a trick to tell ActiveRecord which attributes were
permitted and which weren’t. Here’s how it works:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/hashes.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left is a normal hash &amp;ndash; you can create an ActiveRecord model using this
hash without worrying about whitelisting parameters. On the right is an &lt;span
class="code"&gt;ActionController::Parameters&lt;/span&gt; object; notice it looks almost
the same.  &lt;span class="code"&gt;ActionController::Parameters&lt;/span&gt; is actually a
subclass of &lt;span class="code"&gt;Hash&lt;/span&gt; (via &lt;span
class="code"&gt;ActiveSupport::HashWithIndifferentAccess&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;But on the right notice that the &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object contains a &lt;span class="code"&gt;permitted?&lt;/span&gt;
method. This tells ActiveRecord whether the attributes in that hash were
whitelisted or not.&lt;/p&gt;

&lt;p&gt;When you create a new post or any &lt;span class="code"&gt;ActiveRecord::Base&lt;/span&gt;
object, code inside of Rails checks whether the attributes hash implements the
&lt;span class="code"&gt;permitted?&lt;/span&gt; method or not:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/internals1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because a normal hash doesn’t respond to &lt;span class="code"&gt;permitted?&lt;/span&gt;,
ActiveRecord creates the new post without complaining.&lt;/p&gt;

&lt;p&gt;However, if you try to create a post from an &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object, Rails finds the
&lt;span class="code"&gt;permitted?&lt;/span&gt; method:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/internals2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;If you didn’t whitelist this hash using a call to &lt;span class="code"&gt;permit&lt;/span&gt;, &lt;span class="code"&gt;permitted?&lt;/span&gt; will
return &lt;span class="code"&gt;false&lt;/span&gt; and Rails will raise the &lt;span class="code"&gt;ActiveModel::ForbiddenAttributesError&lt;/span&gt;
exception.&lt;/p&gt;

&lt;h2&gt;Still Confused? Just Use a Normal Hash&lt;/h2&gt;

&lt;p&gt;If all of this is still confusing you &amp;ndash; if you’re still having trouble figuring
out the call to &lt;span class="code"&gt;permit&lt;/span&gt; properly for your complex JSON input &amp;ndash; then remember you
can always just use normal hashes instead of &lt;span class="code"&gt;ActionController::Parameters&lt;/span&gt;
objects.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/normal-hashes.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you are whitelisting or permitting each attribute manually by copying them
into normal hashes. Since &lt;span class="code"&gt;Hash&lt;/span&gt; doesn&amp;rsquo;t implement &lt;span
class="code"&gt;permitted?&lt;/span&gt;, ActiveRecord won’t raise a &lt;span
class="code"&gt;ActiveModel::ForbiddenAttributesError&lt;/span&gt; exception.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using a Ruby Class To Write Functional Code</title>
    <link href="http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code</id>
    <published>2014-04-08T00:00:00Z</published>
    <updated>2014-04-08T00:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet.jpg"&gt;&lt;br/&gt;
    &lt;i&gt;The time sheets I used at my first programming&lt;br/&gt;
    job in the Summer of 1986 looked just like this.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Recently I’ve been spending some of my free time studying Clojure and Haskell.
I’ve been learning how a program built with a</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet.jpg"&gt;&lt;br/&gt;
    &lt;i&gt;The time sheets I used at my first programming&lt;br/&gt;
    job in the Summer of 1986 looked just like this.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Recently I’ve been spending some of my free time studying Clojure and Haskell.
I’ve been learning how a program built with a series of small, pure functions
can be very robust and maintainable. However, I don’t want to give up on Ruby.
I want to keep the expressiveness, beauty and readability of Ruby, while
writing simple functions with no side effects.&lt;/p&gt;

&lt;p&gt;But how can this be possible? Unlike functional languages, Ruby encourages you
to hide state inside of objects, and to write functions (methods) that have
side effects, modifying an instance variable for example. Isn’t using an object
oriented language like Ruby, Python, or Java a decision to abandon the benefits
of functional programming?&lt;/p&gt;

&lt;p&gt;No. In fact, a couple of weeks ago Ruby’s object model helped me refactor one
confusing function into a series of small simple ones. Today I’ll show you what
happened, how using a Ruby class helped me write more functional code.&lt;/p&gt;

&lt;div style="clear: left"/&gt;&lt;/div&gt;


&lt;h2&gt;Parsing Timesheet Data&lt;/h2&gt;

&lt;p&gt;Let’s suppose you are a ScrumMaster&amp;trade; and want to make sure your team of
developers, including me, is putting in enough hours on your project (instead
of taking long lunches or writing blog posts). For example, suppose I report my
hours like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet-data.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You could parse my timesheet data using this simple Ruby program:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is simple enough to understand and works fine. &lt;span
class="code"&gt;parse1&lt;/span&gt; is small function; if you remove the calls to &lt;span class="code"&gt;puts&lt;/span&gt;
it only contains 3 lines of code, two simple calls to &lt;span class="code"&gt;split&lt;/span&gt;. How could this be
any simpler?&lt;/p&gt;

&lt;h2&gt;A First Pass at a Functional Solution&lt;/h2&gt;

&lt;p&gt;Next you decide to look for a more functional solution by &lt;a href="http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby"&gt;asking Ruby for what
you want, instead of telling it what to
do&lt;/a&gt;.
You try to break the problem up into small functions that return what you need.
But what functions should you write? What values should they return? In this
simple example, the answer is obvious: you can write a function to parse each
value in the timesheet data.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/asking.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You have divided the problem up into small pieces. Each function will return a
predictable value based on some input and doesn’t have any side effects. These
will be &lt;em&gt;pure&lt;/em&gt; functions: They will always return the same result given the same
arguments. You know that if you pass a line from my timesheet, &lt;span
  class="code"&gt;last_name&lt;/span&gt; will always return “Shaughnessy.” You’ve turned
the problem around; you’ve phrased the problem as a series of questions rather
than as a list of instructions.&lt;/p&gt;

&lt;p&gt;Refactoring &lt;span class="code"&gt;parse1&lt;/span&gt; above, you implement the
functions, at least in a somewhat verbose and ugly fashion:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/refactoring.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Testing Pure Functions&lt;/h2&gt;

&lt;p&gt;As a Certified ScrumMaster&amp;trade;, you believe in TDD and other extreme
programming practices. Originally, while writing &lt;span
  class="code"&gt;parse1&lt;/span&gt; above, it didn’t even occur to you to write tests
(and if it had, it would have been very difficult).  However, now after
breaking the problem up into a series of functions, it seems natural to write
tests for them.&lt;/p&gt;

&lt;p&gt;Next, you express your expectations for these functions using Minitest specs,
for example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/spec.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because the functions are small, the tests are small. Because the tests are
small, you actually take the time to write them. Because the functions are
decoupled from each other, it’s easy for you to decide which tests to write.&lt;/p&gt;

&lt;p&gt;To your surprise, you actually find a bug!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/spec-fails.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Earlier in &lt;span class="code"&gt;parse1&lt;/span&gt;, the extra space was lost in the
&lt;span class="code"&gt;puts&lt;/span&gt; output and you didn’t notice it. Separating this into a small function and
carefully testing it revealed a minor problem. You adjust two of the functions
to remove the extra space:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/fixing-bug.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Pushing Ruby Out Of Its Comfort Zone&lt;/h2&gt;

&lt;p&gt;You’re happy with your new tests. Ruby allowed you describe the behavior of the
functions in a very natural, readable way. Ruby at its best. As an added bonus,
the tests now also pass!&lt;/p&gt;

&lt;p&gt;However, your functions aren’t so pretty. There is a lot of obvious
duplication: The &lt;span class="code"&gt;office&lt;/span&gt;, &lt;span
  class="code"&gt;employee_id&lt;/span&gt; and &lt;span class="code"&gt;last_name&lt;/span&gt;
functions all call &lt;span class="code"&gt;line.split(&amp;#39;,&amp;#39;)&lt;/span&gt;. To fix this, you
decide to extract &lt;span class="code"&gt;line.split(&amp;#39;,&amp;#39;)&lt;/span&gt; into a separate
function, removing the duplication:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/extracting-method.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This doesn&amp;rsquo;t look any better; in fact, there’s a deeper problem here. To see
what I mean let’s refactor &lt;span class="code"&gt;parse1&lt;/span&gt; from earlier to use
our new functions:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is clean and easy to follow, but now you have a performance bug: Each time
around the loop, your code passes the same line to &lt;span
class="code"&gt;employee_id&lt;/span&gt;, &lt;span class="code"&gt;office&lt;/span&gt; and &lt;span
class="code"&gt;last_name&lt;/span&gt;. Now Ruby will call the &lt;span class="code"&gt;values&lt;/span&gt; function over and
over again. This is unnecessary and needless; in fact, our original &lt;span
  class="code"&gt;parse1&lt;/span&gt; code didn’t have this problem. By introducing
functions we have slowed down our code.&lt;/p&gt;

&lt;p&gt;However, because these are simple, pure functions, you know they will always
return the same value given the same input argument, the same line of text in
this example. This means theoretically you can avoid calling &lt;span
class="code"&gt;split&lt;/span&gt; over and over again by caching the results.&lt;/p&gt;

&lt;p&gt;At first, you try to cache the return value of &lt;span class="code"&gt;split&lt;/span&gt;
by using a hash table like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/hash1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This looks straightforward: The keys in &lt;span class="code"&gt;split_lines&lt;/span&gt;
are the lines and the values are the corresponding split lines. You use Ruby’s
elegant &lt;span class="code"&gt;||=&lt;/span&gt; operator either to return a cached value
from the hash or actually call &lt;span class="code"&gt;split&lt;/span&gt;, updating the
hash.&lt;/p&gt;

&lt;p&gt;The only problem with this is that it doesn’t work. The code inside of the
&lt;span class="code"&gt;values&lt;/span&gt; function can’t access the &lt;span
class="code"&gt;split_lines&lt;/span&gt; hash, located outside the method.  And if you
move &lt;span class="code"&gt;split_lines&lt;/span&gt; inside of &lt;span class="code"&gt;values&lt;/span&gt;, it would become a
local variable and not retain values across method calls.&lt;/p&gt;

&lt;p&gt;To work around this problem you could pass the cache as an additional argument
to &lt;span class="code"&gt;values&lt;/span&gt;, but this would make your program even more
verbose than it is now.  Or you could create the &lt;span
class="code"&gt;values&lt;/span&gt; method using &lt;span
class="code"&gt;define_method&lt;/span&gt;, instead of &lt;span class="code"&gt;def&lt;/span&gt;,
like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/hash2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This confusing Ruby syntax allows the code inside of the new &lt;span class="code"&gt;values&lt;/span&gt; method to
access the surrounding scope, including the hash table.&lt;/p&gt;

&lt;p&gt;However, taking a step back, something about your program now feels wrong.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/step-back.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Instead of making your code simpler and easier to understand, functional
programming has started to make your Ruby code more confusing and harder to
read. You’ve introduced a new data structure to cache results, and resorted to
confusing metaprogramming to make it work. And your functions are still quite
repetitive.&lt;/p&gt;

&lt;p&gt;What’s gone wrong? Possibly Ruby isn’t the right language to use with
functional programming.&lt;/p&gt;

&lt;h2&gt;Introducing a Ruby Class&lt;/h2&gt;

&lt;p&gt;Next, you decide to forget all about functional programming and to try again by
using a Ruby class. You write a &lt;span class="code"&gt;Line&lt;/span&gt; class,
representing a single line of text from the timesheet text file:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;And you decide to move your functions into the new &lt;span class="code"&gt;Line&lt;/span&gt; class:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now you have a lot less noise. The biggest improvement is that now there’s no
need to pass the line of text around as a parameter to each function. Instead,
you hide it away in an instance variable, making the code much easier to read.
Also, your functions have become methods. Now you know all the functions
related to parsing lines are in the &lt;span class="code"&gt;Line&lt;/span&gt; class. You
know where to find them, and more or less what they are for. Ruby has helped
you organize your code using a class, which is really just a collection of
functions.&lt;/p&gt;

&lt;p&gt;Continuing to simplify, you refactor the &lt;span class="code"&gt;value&lt;/span&gt; method at the bottom to remove
the confusing &lt;span class="code"&gt;define_method&lt;/span&gt; syntax:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/refactor-values.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now each instance of the &lt;span class="code"&gt;Line&lt;/span&gt; class, each line of text you program uses, will
have its own copy of &lt;span class="code"&gt;@values&lt;/span&gt;. By using a Ruby class, you don’t need to
resort to a hash table to map between lines (keys) and split lines (values).
Instead you employ a very common Ruby idiom, combining an instance variable
&lt;span class="code"&gt;@values&lt;/span&gt;, with the &lt;span class="code"&gt;||=&lt;/span&gt;
operator. Instance variables are the perfect place to cache information such as
method return values.&lt;/p&gt;

&lt;h2&gt;Breaking All the Rules&lt;/h2&gt;

&lt;p&gt;Now your code is much easier to read. Using an object oriented instead of a
functional design turned out to be a good idea.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;With your object oriented solution, you have broken some of the most important
rules of functional programming: First, you created hidden state, the &lt;span
class="code"&gt;@line&lt;/span&gt; instance variable, wrapping it up and hiding it
inside the &lt;span class="code"&gt;Line&lt;/span&gt; class. The &lt;span class="code"&gt;@values&lt;/span&gt; instance
variable holds even more state information. And second, the &lt;span class="code"&gt;initialize&lt;/span&gt; and
&lt;span class="code"&gt;values&lt;/span&gt; methods have side effects: They change the value of &lt;span
class="code"&gt;@line&lt;/span&gt; and &lt;span class="code"&gt;@values&lt;/span&gt;. Finally,
all the other methods of &lt;span class="code"&gt;Line&lt;/span&gt; are no longer pure functions! They return values
that depend on state located outside of each function: the &lt;span
class="code"&gt;@line&lt;/span&gt; variable. In fact, they can return different values
even though they take no arguments at all.&lt;/p&gt;

&lt;p&gt;But I believe these are technicalities. You haven’t lost the benefits of
functional programming with this refactoring. While the methods of &lt;span
  class="code"&gt;Line&lt;/span&gt; depend on external state (&lt;span
  class="code"&gt;@line&lt;/span&gt; and &lt;span class="code"&gt;@values&lt;/span&gt;), that state
  isn’t located very far away. It’s still easy to predict, understand and test
  what these small functions do. Also, while &lt;span class="code"&gt;@line&lt;/span&gt; is
  technically a mutable string that you change in your program, in practice it
  isn’t. You set it once using &lt;span class="code"&gt;initialize&lt;/span&gt; and then
  never change it again. While you may update &lt;span class="code"&gt;@values&lt;/span&gt;
  each time &lt;span class="code"&gt;values&lt;/span&gt; is called, it&amp;rsquo;s just a performance
  optimization. It doesn’t change the overall behavior of values.&lt;/p&gt;

&lt;p&gt;You’ve broken the rules and rewritten your pure, functional program is a more
idiomatic, Ruby manner. However, you haven’t lost the spirit of functional
programming. Your code is just as easy to understand, maintain and test.&lt;/p&gt;

&lt;h2&gt;Creating an Object Pipeline&lt;/h2&gt;

&lt;p&gt;Wrapping up, you refactor your original program to use your new &lt;span
class="code"&gt;Line&lt;/span&gt; class like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Of course, there’s not much difference here. You simply added a line of code to
create new line objects, and then called its methods instead of your original
functions.&lt;/p&gt;

&lt;p&gt;Finally, you decide to take one step further and refactor again by mapping the
array of text lines to an array of line objects:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/object-pipeline.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 80px 0px 25px 20px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/factory.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Again, not much difference in the code. However, the way you think about your
program has changed dramatically. Now your code implements a pipeline of sorts,
passing data through a series of operations or transformations. You start with
an array of text lines from a file, convert them into an array of Ruby objects,
and finally process each object using your parse functions.&lt;/p&gt;

&lt;p&gt;This pattern of passing data through a series of operations is common in
languages such as Haskell and Clojure. What’s interesting here is how Ruby
objects are the perfect target for these operations. You’ve used a Ruby class
to implement a functional programming pattern.&lt;/p&gt;

&lt;br/&gt;


&lt;br/&gt;


&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; &lt;a href="https://twitter.com/orend"&gt;Oren Dobzinski&lt;/a&gt; suggested adding a
&lt;span class="code"&gt;to_s&lt;/span&gt; method to &lt;span class="code"&gt;Line&lt;/span&gt;, which
would allow us to push the object pipeline idea even further. Thanks Oren! See
Dave Thomas&amp;rsquo;s article &lt;a href="http://pragdave.me/blog/2014/02/11/telling-asking-and-the-power-of-jargon/"&gt;Telling, Asking, and the Power of
Jargon&lt;/a&gt;
for more background on &amp;ldquo;Tell, Don&amp;rsquo;t Ask.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse5.png"&gt;&lt;br/&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Use An Ask, Don’t Tell Policy With Ruby</title>
    <link href="http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby</id>
    <published>2014-02-10T01:00:00Z</published>
    <updated>2014-02-10T01:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/2/10/innisfree.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Innisfree is an actual island in Lough Gill, County Sligo, Ireland&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;The next time you need to develop a new algorithm, ask Ruby for what you want,
don’t tell it what to do. Don’t think of your code as a series of instructions
for t</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/2/10/innisfree.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Innisfree is an actual island in Lough Gill, County Sligo, Ireland&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;The next time you need to develop a new algorithm, ask Ruby for what you want,
don’t tell it what to do. Don’t think of your code as a series of instructions
for the computer to follow. Instead, ask Ruby for what you need: Your code
should state the solution to your problem, even if you’re not sure what that
solution is yet! Then dive into more and more detail, filling in your
solution’s gaps as you do. This can lead to a more expressive, functional
solution that you might not find otherwise.&lt;/p&gt;

&lt;p&gt;Too often over the years I’ve written code that consists of instructions for
the computer to follow. Do this, do that, and then finish by doing this third
thing. As I write code I imagine I am the computer, in a way, asking myself:
What do I need to do first to solve this problem? When I decide, this becomes
the first line of code in my program. Then I continue, writing each line of
code as another instruction for the computer to follow.&lt;/p&gt;

&lt;p&gt;But what does “Ask, Don’t Tell” mean exactly? And how could Ruby possibly know
the answer when I ask it something? An example will help you understand what I
mean.&lt;/p&gt;

&lt;h2&gt;Parsing a Yeats Poem&lt;/h2&gt;

&lt;p&gt;Last week I needed to parse a text file to obtain the lines of text that
appeared after a certain word. My actual task was very boring (separating blog
articles from their metadata), so instead let’s work with something more
beautiful, &lt;em&gt;The Lake Isle Of Innisfree&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;




&lt;blockquote&gt;
  I will arise and go now, and go to Innisfree,&lt;br/&gt;
  And a small cabin build there, of clay and wattles made:&lt;br/&gt;
  Nine bean-rows will I have there, a hive for the honeybee,&lt;br/&gt;
  And live alone in the bee-loud glade.&lt;br/&gt;
  &lt;br/&gt;
  And I shall have some peace there, for peace comes dropping slow,&lt;br/&gt;
  Dropping from the veils of the morning to where the cricket sings;&lt;br/&gt;
  There midnight's all a glimmer, and noon a purple glow,&lt;br/&gt;
  And evening full of the linnet's wings.&lt;br/&gt;
  &lt;br/&gt;
  I will arise and go now, for always night and day&lt;br/&gt;
  I hear lake water lapping with low sounds by the shore;&lt;br/&gt;
  While I stand on the roadway, or on the pavements grey,&lt;br/&gt;
  I hear it in the deep heart's core.&lt;br/&gt;
&lt;/blockquote&gt;


&lt;p&gt;My task is to write a Ruby script to return the line that contains a given
word, along with the following lines:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/console.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Telling Ruby What To Do&lt;/h2&gt;

&lt;p&gt;When I first wrote this script, I put myself in the computer’s shoes: What do I
need to do to find the target word? I started writing instructions for Ruby to
follow.&lt;/p&gt;

&lt;p&gt;First I need to open the file and read in the poem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/one.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here &lt;span class="code"&gt;File#readlines&lt;/span&gt; saves all the lines of text into an array, which the &lt;span class="code"&gt;parse&lt;/span&gt;
method will process, returning the result in another array. Later I join the
result lines together and print them out.&lt;/p&gt;

&lt;p&gt;How do I implement &lt;span class="code"&gt;parse&lt;/span&gt;? Again, I imagine that I am the computer, that I am
Ruby. How do I find the lines that follow &lt;em&gt;glimmer&lt;/em&gt;? Well, obviously I need to
loop through the array looking for the target word.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/two.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Once I find the word, I’ll start saving the lines into a new array called
&lt;span class="code"&gt;result&lt;/span&gt;. Since I want to save all the following lines and not just the matching
line, I’ll also use a boolean flag to keep track of whether I’ve already seen
the target.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/three.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;What’s wrong with this code? Nothing really. It works just fine, and it’s
even somewhat idiomatic Ruby. In the past, I would have probably considered
this done and moved on.&lt;/p&gt;

&lt;p&gt;However, I can do better than this. I can ask Ruby for what I want, instead of
telling Ruby what to do.&lt;/p&gt;

&lt;h2&gt;Ask Ruby For What You Want&lt;/h2&gt;

&lt;p&gt;Don’t imagine you are the computer. Don’t think about how to solve a problem by
figuring out what Ruby should do and then writing down instructions for it to
follow. Instead, start by asking Ruby for the answer.&lt;/p&gt;

&lt;p&gt;What should my method return? An array of the lines that appear after the
target word. To reflect this, I’ll rename my method from &lt;span class="code"&gt;parse&lt;/span&gt; (telling Ruby
what to do) to &lt;span class="code"&gt;lines_after&lt;/span&gt; (asking Ruby for what I want).&lt;/p&gt;

&lt;p&gt;This might seem like an unimportant detail, but naming methods is one of the
most difficult and important things a programmer does. Picking a name for a
method gives the reader a hint about what the method does, about what your
intentions were when you wrote it. Think of writing code the same way you would
think of writing an essay or story. You want your readers to understand what
you are saying, and to be able to follow along. (You also want them to enjoy
reading enough that they consider the code to be their own someday.)&lt;/p&gt;

&lt;p&gt;To get started I’ll write the new method to return an empty array.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/four.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Notice on the left I changed the label from “Instructions:” to “What do I
want?” This reflects my new way of thinking about the problem.&lt;/p&gt;

&lt;p&gt;Now, what does “appear after the target word” mean exactly? It means the lines
that appear in the array after (and including) the line containing the target.
Ah… in other words, the &lt;span class="code"&gt;lines_after&lt;/span&gt; method should return a subset or slice of the
array. Rewriting the problem in a different way lead me towards a solution I
hadn&amp;rsquo;t thought of before.&lt;/p&gt;

&lt;p&gt;Now I can rewrite the “What do I want?” text like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/five.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I rewrote what I want from Ruby to be more specific: I want a “portion of the
array” and I want the portion “including and following the line containing the
target.” I haven’t written much code yet, but I’ve taken a big step forward in
how I think about the problem.&lt;/p&gt;

&lt;p&gt;On the right, I’ve written code to return a subset of the array,
&lt;span class="code"&gt;lines[target_index..-1]&lt;/span&gt;. But my solution is still incomplete; what should
&lt;span class="code"&gt;target_index&lt;/span&gt; be?&lt;/p&gt;

&lt;p&gt;Thinking about this a bit, it’s easy to see how to find the line containing the
target string: I can use &lt;span class="code"&gt;detect&lt;/span&gt; to find the line that includes the target word.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/six.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But I’m still not done. I need the index of the line containing the target, not
the line itself. How can I find &lt;span class="code"&gt;target_index&lt;/span&gt;? Again, I shouldn’t tell Ruby what
to do (maybe create a local variable and loop through the lines checking each
one). Instead, I should ask Ruby for what I need. What do I need? I need the
index which corresponds to the line containing the target. In other words, I
need to find (to detect) the target index, not the target line.&lt;/p&gt;

&lt;p&gt;Here’s how to do it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/seven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here I use Ruby’s &lt;span class="code"&gt;detect&lt;/span&gt; method to search a range of index values, not lines.
Inside the block I check whether the line corresponding to each index
(&lt;span class="code"&gt;lines[i]&lt;/span&gt;) contains the target. At the bottom I return the correct slice of the
array if I found the target, or an empty array if I didn’t.&lt;/p&gt;

&lt;h2&gt;Learning From Functional Languages&lt;/h2&gt;

&lt;p&gt;In my opinion this code is better than what I showed earlier. Why? They both
work equally well. What’s the difference? Let&amp;rsquo;s take a look at them side-by-side.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/compare.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;First of all, I have simpler, more terse code. Less code is better. The &lt;span class="code"&gt;lines_after&lt;/span&gt;
method contains just 4 lines of code while the &lt;span class="code"&gt;parse&lt;/span&gt; method
contains 9. Of course, I could find ways to rewrite &lt;span class="code"&gt;parse&lt;/span&gt; to use
fewer lines, but any way you look at it &lt;span class="code"&gt;lines_after&lt;/span&gt; is simpler than &lt;span class="code"&gt;parse&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;parse&lt;/span&gt; method contains two local variables which are changed, or &lt;em&gt;mutated&lt;/em&gt;, by
code inside the loop. This makes the method harder to understand. What is the
value of &lt;span class="code"&gt;flag&lt;/span&gt;? What about &lt;span class="code"&gt;result&lt;/span&gt;? To really understand how &lt;span class="code"&gt;parse&lt;/span&gt; works you
almost need to simulate the loop inside your head, thinking about how the flag
and result values change over time.&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;lines_after&lt;/span&gt; method also contains two local variables. However, they aren’t used
in the same way &amp;ndash; they aren’t changed as the program runs. The block
parameter, &lt;span class="code"&gt;i&lt;/span&gt;, while different each time the block is called, doesn’t change
inside the block. It’s meaning is clear and unambiguous while that block is
running. Similarly, the &lt;span class="code"&gt;target_index&lt;/span&gt; variable is set once to an intermediate
value, not changed once each time around a loop.&lt;/p&gt;

&lt;p&gt;Terse, simple code that doesn’t change values while it is running is the
hallmark of functional programming languages like Haskell or Clojure. While
these languages allow you to write concurrent code without using locks, their
chief benefit is that they encourage (Clojure) or even force you (Haskell) to write simple, terse
code. Code that asks the computer for what you need, not code that tells the
computer what to do.&lt;/p&gt;

&lt;p&gt;But, as we’ve seen, you don’t need to abandon Ruby to write functional code.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; Simon Kröger and Josh Cheek both suggested using &lt;span
  class="code"&gt;drop_while&lt;/span&gt;, which gives us an even more readable,
functional solution:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/eight.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I also decided to rename the &lt;span class="code"&gt;after&lt;/span&gt; method to &lt;span
  class="code"&gt;lines_after&lt;/span&gt;, based on the comments from TenderGlove and
John Kary. I agree with them &lt;span class="code"&gt;after&lt;/span&gt; would make more sense if I
called it as a method on an object containing the lines (e.g. &lt;span class="code"&gt;lines.after&lt;/span&gt;). But as a simple
function like in this example &lt;span class="code"&gt;lines_after&lt;/span&gt; is more
expressive.&lt;/p&gt;

&lt;p&gt;Thanks guys!&lt;/p&gt;

&lt;h2&gt;Learning From Sandi Metz&lt;/h2&gt;

&lt;p&gt;In her famous book, &lt;a href="http://www.poodr.com"&gt;Practical Object-Oriented Design in Ruby&lt;/a&gt;, Sandi Metz
mentions the Ask, Don’t Tell policy also, but using slightly different words.
With her brilliant bicycle examples, Sandy shows us in Chapter 4 of
POODR why we should be &lt;em&gt;Asking for &amp;ldquo;What&amp;rdquo; Instead of Telling &amp;ldquo;How&amp;rdquo;&lt;/em&gt;. When you
send a message to an object, you should ask it for what you want, not tell it
what to do or make assumptions about how it works internally. Sandi shows us
how this policy &amp;ndash; along with other important design principles &amp;ndash; helps us write
classes that are more independent and decoupled one from the other.&lt;/p&gt;

&lt;p&gt;The Ask, Don’t Tell policy applies equally well to functional programming and
object oriented programming. At a lower level, it helps us write more terse,
functional Ruby methods. Stepping back, it can also help us design object
oriented applications that are easier to maintain and extend.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update #2:&lt;/b&gt; Apparently I’ve (unknowingly) conflated “Ask, Don’t Tell” with the
“Tell, Don’t Ask,” advice Dave Thomas has been giving us for years to make a
different but related point about object oriented design.  Dave explains here:
&lt;a href="http://pragdave.me/blog/2014/02/11/telling-asking-and-the-power-of-jargon/"&gt;Telling, Asking, and the Power of
Jargon&lt;/a&gt;.
He also disagrees with my opinion that the &lt;span
  class="code"&gt;parse_lines&lt;/span&gt; example was written in a functional style.&lt;/p&gt;
</content>
  </entry>
</feed>

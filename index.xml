<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pat Shaughnessy</title>
  <id>http://patshaughnessy.net</id>
  <updated>2008-09-03T00:00:00Z</updated>
  <author>
    <name></name>
  </author>
  <entry>
    <title>How Arel Converts Ruby Queries Into SQL Statements</title>
    <link href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements</id>
    <published>2014-09-23T03:00:00Z</published>
    <updated>2014-09-23T03:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/battle.png"&gt;&lt;br/&gt;
  &lt;i&gt;In one of the climactic scenes in&lt;/i&gt; 20,000 Leagues Under the&lt;br/&gt;Sea, &lt;i&gt;Captain Nemo and his crew battle a giant octopus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the second in a series of posts based on a presentation I did at the
&lt;a href="http://www.baruco</summary>
    <content type="html">&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/battle.png"&gt;&lt;br/&gt;
  &lt;i&gt;In one of the climactic scenes in&lt;/i&gt; 20,000 Leagues Under the&lt;br/&gt;Sea, &lt;i&gt;Captain Nemo and his crew battle a giant octopus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the second in a series of posts based on a presentation I did at the
&lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt; called “20,000 Leagues Under
ActiveRecord.”&lt;/b&gt; I took an innocent and unsuspecting audience on an adventure
inside and underneath ActiveRecord to find out how Rails and PostgreSQL
actually execute a simple SQL query.&lt;/p&gt;

&lt;p&gt;In the &lt;a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord"&gt;first part of the
presentation&lt;/a&gt;
I showed what ActiveRecord does internally when you call methods such as &lt;span
class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;limit&lt;/span&gt;. We saw how each
scoping method returns a new instance of the &lt;span
class="code"&gt;ActiveRecord::Relation&lt;/span&gt; class, gradually building up a
description of your query.&lt;/p&gt;

&lt;p&gt;Today I’ll continue by looking at what ActiveRecord does next: How it uses the
Arel gem to convert the &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; object
describing your query into a string containing a SQL statement. Later, in the
third post we’ll dive down inside the PostgreSQL database server itself to see
how it executes this SQL statement.&lt;/p&gt;

&lt;h2&gt;The Arel Gem&lt;/h2&gt;

&lt;p&gt;Here again is the instance of the &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; class that represents
our query to find the user named “Captain Nemo:”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/ar-relation1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now that we’ve specified the query we want to execute, what does ActiveRecord
do next? How does it actually execute the query and return the results to us?
We can find a clue by looking more closely at the relation object and the
metadata values it stores:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/AR-Relation2.png"/&gt;&lt;/p&gt;

&lt;p&gt;If you inspect an &lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; object in
the Rails console, you’ll find that its instance variables are not simple
values, but instead references to other Ruby objects. These objects have class
names such as &lt;span class="code"&gt;Arel::Nodes::Equality&lt;/span&gt; and &lt;span
class="code"&gt;Arel::Nodes::Attribute&lt;/span&gt;. What are these Ruby objects?  Where
are they created? What do these class names mean?&lt;/p&gt;

&lt;p&gt;It turns out that ActiveRecord itself doesn’t convert your
&lt;span class="code"&gt;ActiveRecord::Relation&lt;/span&gt; query to SQL; instead, it uses
a separate gem called Arel. Googling for “Arel” we can easily find its Github
repo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel1.png"/&gt;&lt;br/&gt;
&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The gem’s description is simply “A Relational Algebra.” What in the world does
this mean? And farther down in the Readme there’s another interesting line:
“Arel is a SQL AST manager for Ruby.” What does “AST” mean, and what does an
“AST manager” do?&lt;/p&gt;

&lt;p&gt;AST stands for “Abstract Syntax Tree,” an important concept from computer
science. I’ll explain what that means in a minute. But first let’s look at some
computer science history to find out what Relational Algebra is.&lt;/p&gt;

&lt;h2&gt;Relational Algebra&lt;/h2&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/codd.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Edgar Codd&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Relational Algebra is a branch of computer science that forms the mathematical
foundation underpinning relational database servers and the SQL language. An
influential computer scientist named &lt;a href="http://en.wikipedia.org/wiki/Edgar_F._Codd"&gt;Edgar
Codd&lt;/a&gt; first described Relational
Algebra in his groundbreaking academic paper &lt;a href="http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf"&gt;A Relational Model of Data for
Large Shared Data Banks&lt;/a&gt;,
published in 1970. Codd described the term “relation” as follows:&lt;/p&gt;

&lt;blockquote&gt;
1.3. A RELATIONAL VIEW OF DATA&lt;br/&gt;
The term relation is used here in its accepted mathematical sense. Given sets
S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ... , S&lt;sub&gt;n&lt;/sub&gt;, (not necessarily distinct), R is a relation on
these n sets if it is a set of n-tuples each of which has its first element
from S&lt;sub&gt;1&lt;/sub&gt;, its second element from S&lt;sub&gt;2&lt;/sub&gt;, and so on.
&lt;/blockquote&gt;


&lt;p&gt;He later went on to define various mathematical operations on relations,
including &lt;em&gt;projection&lt;/em&gt;, &lt;em&gt;restriction&lt;/em&gt;, and &lt;em&gt;join&lt;/em&gt;. He also used terms such as &lt;em&gt;normal
form&lt;/em&gt;, &lt;em&gt;primary key&lt;/em&gt; and &lt;em&gt;foreign key&lt;/em&gt;. Today, almost 45 years later, we still use
Codd’s terminology and the associated mathematical theories when discussing
database tables and queries.&lt;/p&gt;

&lt;p&gt;In another interesting passage, Codd wrote about the need for a language we
could use to articulate and describe Relational Algebra concepts:&lt;/p&gt;

&lt;blockquote&gt;
1.5. SOME LINGUISTIC ASPECTS&lt;br/&gt;
The adoption of a relational model of data, as described above, permits the
development of a universal data sublanguage based on an applied predicate
calculus.
&lt;/blockquote&gt;


&lt;p&gt;This “universal sublanguage” is the Structured Query Language or SQL. I find
the term “sublanguage” to be very appropriate; SQL is a language used inside
larger applications written in some other programming language, such as Ruby.&lt;/p&gt;

&lt;p&gt;Returning to our example, here’s the SQL statement that represents our search
for the user named Captain Nemo:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/sql.png"/&gt;&lt;/p&gt;

&lt;p&gt;The SQL language existed before Codd wrote his paper on Relational Algebra in
1970, but it didn’t resemble the version of SQL we all know and love today. The
mathematical concepts Codd first described form the basis for the modern
version of SQL.&lt;/p&gt;

&lt;p&gt;Now let’s return to the question of what an “AST manager” is.&lt;/p&gt;

&lt;h2&gt;Abstract Syntax Trees&lt;/h2&gt;

&lt;p&gt;An abstract syntax tree is a hierarchical arrangement of objects or memory
structures that represent a series of words or some syntax from a text
language. In this case, the AST inside of Arel is a tree of Ruby objects that
represents a SQL statement.&lt;/p&gt;

&lt;p&gt;Here’s the AST Arel creates internally for our example query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree1.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the top or root of the tree is a Ruby object called
&lt;span class="code"&gt;SelectStatement&lt;/span&gt;, and under that the various branches
of the tree represent the where, order by and limit clauses in our
select statement.&lt;/p&gt;

&lt;p&gt;The Arel gem “is a Relational Algebra” in the sense that it provides a Ruby API
that contains methods such as &lt;span class="code"&gt;project&lt;/span&gt;, &lt;span
class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;order&lt;/span&gt; that represent
concepts from Relational Algebra. Internally, these methods create Ruby objects
and save them in the AST. Arel’s API is similar to ActiveRecord’s, but is
somewhat more granular and detailed. When we call ActiveRecord methods such as
&lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;limit&lt;/span&gt;, internally
ActiveRecord calls the corresponding methods in the Arel gem. Here’s our
example query written using both ActiveRecord (top) and Arel (bottom) method
calls:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/arel-and-ar.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 60px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/9/23/window.png"&gt;&lt;br/&gt;
  &lt;i&gt;Professor Aronnax, Conseil and Ned Land spent hours marveling&lt;br/&gt;at the underwater world through the windows of the Nautilus.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Notice the Arel query is longer and more verbose. Expressing our query using Arel we call:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class="code"&gt;project&lt;/span&gt; to specify which columns or attributes we
are looking for (&lt;em&gt;projection&lt;/em&gt; in Codd’s Relational Algebra)&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;where&lt;/span&gt; and &lt;span class="code"&gt;eq&lt;/span&gt; to specify
how to filter the result set (&lt;em&gt;restriction&lt;/em&gt; in Relational Algebra)&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;order&lt;/span&gt; to specify the sort order, and&lt;/li&gt;
&lt;li&gt;&lt;span class="code"&gt;limit&lt;/span&gt; to specify how many records we want.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Each time you call an ActiveRecord scoping method, it calls down into one of
these Arel methods, inserting objects into the same AST.&lt;/p&gt;

&lt;h2&gt;The Visitor Pattern&lt;/h2&gt;

&lt;p&gt;Creating an AST containing Ruby objects is one thing, but generating an actual
SQL statement is another. How does Arel do this? Why is building up an AST
useful in any way?&lt;/p&gt;

&lt;p&gt;Using a very elegant algorithm, Arel iterates over the nodes in the AST and
concatenates different SQL fragments to form a complete SQL statement. This
algorithm is an example of the “visitor pattern.” The term visitor pattern
simply means that some object, function or other piece of code is executed once
for each node in some data structure, such as an array, linked list or tree.&lt;/p&gt;

&lt;p&gt;To understand this a bit better, let’s take our example AST and follow Arel’s
visitor as it traverses the tree, starting at the &lt;span
class="code"&gt;SelectStatement&lt;/span&gt; root node:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree2.png"/&gt;&lt;/p&gt;

&lt;p&gt;The blue arrow at the top is the visitor, a Ruby object. Depending on which
database server you are using, Arel creates a different visitor object. This is
a fascinating detail about Arel’s internal design: Arel can generate different
variations of SQL equally well by using different visitor objects. If you
connect your Rails app to SQLite, Arel uses a SQLite visitor. If you are using
MySQL, Arel uses a MySQL visitor. Because we’re using PostgreSQL today, Arel
creates a Postgres visitor.&lt;/p&gt;

&lt;h2&gt;Visiting All the Nodes in the AST&lt;/h2&gt;

&lt;p&gt;Now let’s follow Arel’s visitor as it iterates over the Ruby objects in the
AST, shown as a moving blue arrow. Above each diagram I’ll show the SQL string
the visitor cumulatively builds up as it goes.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree2b.png"/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see the visitor arrow next to the &lt;span class="code"&gt;SelectStatement&lt;/span&gt; node. Above the
diagram I’ve written the word “SELECT.” Arel’s visitor knows to write SELECT
when it encounters &lt;span class="code"&gt;SelectStatement&lt;/span&gt; root node.&lt;/p&gt;

&lt;p&gt;Next Arel moves down to the left:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree3.png"/&gt;&lt;/p&gt;

&lt;p&gt;This time Arel doesn’t write anything new into the string; &lt;span
class="code"&gt;SelectCode&lt;/span&gt; is just a container for other branches of the
tree.&lt;/p&gt;

&lt;p&gt;Next, Arel moves down and left again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree4.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now Arel’s visitor see the &lt;span class="code"&gt;Attribute&lt;/span&gt; node. This
represents the projection or list of attributes we want in the result set. Arel
appends &lt;span class="code"&gt;&amp;quot;users&amp;quot;.*&lt;/span&gt; to the SQL string.&lt;/p&gt;

&lt;p&gt;Next, the visitor moves to the right:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree5.png"/&gt;&lt;/p&gt;

&lt;p&gt;Encountering the &lt;span class="code"&gt;JoinSource&lt;/span&gt; node, Arel writes &lt;span
class="code"&gt;FROM &amp;quot;users&amp;quot;&lt;/span&gt; onto the end of the SQL statement. &lt;span
class="code"&gt;JoinSource&lt;/span&gt; and its child nodes list the tables that our
query will read from. In this example, we don’t have any joins and just a
single table, so &lt;span class="code"&gt;JoinSource&lt;/span&gt; has only one &lt;span
class="code"&gt;Table&lt;/span&gt; child node.&lt;/p&gt;

&lt;p&gt;Next, the visitor moves to the right again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree6.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now Arel writes the where clause for our SQL statement: &lt;span class="code"&gt;WHERE &amp;quot;users&amp;quot;.&amp;quot;name&amp;quot; =
$1&lt;/span&gt;. The &lt;span class="code"&gt;And&lt;/span&gt; node is the root of a subbranch of the AST that represents the
boolean expression we want the database server to use to filter our result set.
In our example we are only checking that the name column equals “Captain Nemo”
so the AST contains a single &lt;span class="code"&gt;Equality&lt;/span&gt; node under
&lt;span class="code"&gt;And&lt;/span&gt;. The &lt;span class="code"&gt;And&lt;/span&gt; node doesn’t
really do anything in this case.&lt;/p&gt;

&lt;p&gt;Now the visitor continues to the right:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree7.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see Arel finds the &lt;span class="code"&gt;Ascending&lt;/span&gt; node and appends our order by clause.&lt;/p&gt;

&lt;p&gt;Finally, the visitor moves to the right one last time:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/9/23/tree8.png"/&gt;&lt;/p&gt;

&lt;p&gt;Finding the &lt;span class="code"&gt;Limit&lt;/span&gt; node, Arel’s visitor completes the
SQL statement by concatenating &lt;span class="code"&gt;LIMIT 1&lt;/span&gt; onto our select statement.&lt;/p&gt;

&lt;p&gt;Using the visitor pattern in this way, Arel has converted our query from a
collection of Ruby objects into a single string containing a SQL select
statement. Arel has expressed our Ruby query using Codd’s Relational Algebra.&lt;/p&gt;

&lt;p&gt;Every time you execute a simple database query using ActiveRecord in your Rails
app, you are relying on a series of elegant algorithms and computer science
theories developed many years ago. Rails is so simple and easy to use only
because we are standing on the shoulders of giants &amp;ndash; computer scientists like
Edgar Codd &amp;ndash; who have already done the difficult theoretical work that makes
building apps today possible.&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://localhost/assets/2014/9/23/south-pole.png"&gt;&lt;br/&gt;
  &lt;i&gt;A citizen of no country, Captain Nemo claimed the &lt;br/&gt;south pole as his own using a black flag with a large "N."&lt;/i&gt;
&lt;/div&gt;


&lt;h2&gt;Why Stop Here?&lt;/h2&gt;

&lt;p&gt;We’ve learned a lot about ActiveRecord and the Arel gem. Now we know what
happens when we call scoping methods such as &lt;span class="code"&gt;where&lt;/span&gt;
and &lt;span class="code"&gt;first&lt;/span&gt;. We’ve seen how ActiveRecord calls Arel’s
lower level, more granular API, and now we know how Arel uses the visitor
pattern and an AST to convert these Ruby method calls into a SQL string.&lt;/p&gt;

&lt;p&gt;But why stop here? Why not dive even deeper? … farther below the surface of
your Rails app into the PostgreSQL server itself! Next we’ll leave the world of
Ruby entirely and look at what the Postgres server does when it receives this
select statement. How does it understand the SQL we send it? How does it
actually find our data… the user record with the name “Captain Nemo?” In my next
post, I’ll continue our underwater adventure by looking at Postgres internals.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>20,000 Leagues Under ActiveRecord</title>
    <link href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord</id>
    <published>2014-09-17T03:00:00Z</published>
    <updated>2014-09-17T03:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://localhost/assets/2014/9/17/title.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;First published in 1870, &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the Sea&lt;/a&gt;&lt;br/&gt;describes an underwater adventure that takes place&lt;br/&gt;onboard a submarine called the “Nautilus.”&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
Th</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://localhost/assets/2014/9/17/title.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;First published in 1870, &lt;a href="http://en.wikipedia.org/wiki/Twenty_Thousand_Leagues_Under_the_Sea"&gt;20,000 Leagues Under the Sea&lt;/a&gt;&lt;br/&gt;describes an underwater adventure that takes place&lt;br/&gt;onboard a submarine called the “Nautilus.”&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;
This is the first in a series of posts based on a presentation I just did
last Friday at the &lt;a href="http://www.baruco.org"&gt;Barcelona Ruby Conference&lt;/a&gt;. I’ll
also post a link to the video recording when the Baruco team has time to edit
and post it online.  &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Let me start with a question: How many of you have actually read 20,000 Leagues
Under the Sea, either in the original French or in some translation? [ A few
people raised their hands, but most people in the audience did not. ] Yes, I’m
not surprised. 20,000 Leagues is one of those classic novels we have all heard
of, but few of us take the time to read.&lt;/p&gt;

&lt;p&gt;While thinking about this presentation over the Summer, I decided to actually
read the novel &amp;ndash; and I’m glad that I did! It blew my mind on a number of
different levels. Today I’m going to take the time to tell you a bit about the
novel itself as we go.&lt;/p&gt;

&lt;p&gt;However, actually I’m here today to talk about ActiveRecord. I’d like to explore
how ActiveRecord works internally; how it finds the information we ask for and
returns it to us as a Ruby object.&lt;/p&gt;

&lt;div style="clear: left"/&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/example1.png"/&gt;&lt;/p&gt;

&lt;p&gt;But why talk about ActiveRecord? We all know how to use ActiveRecord; most of
you understand exactly what this line of code does. You didn’t need to come to
Barcelona to learn how to use ActiveRecord.&lt;/p&gt;

&lt;p&gt;The reason why I want to discuss this is that ActiveRecord hooked me; it
first got me excited about using Rails. I came across Rails back in 2008, about
six years ago now. And I can still remember the moment when I first typed a
line of code similar to this one into the Rails console or into a Rails app
somewhere. It was amazing!  Before that I was using PHP or Java &amp;ndash; I’ve since
blocked out all memory of that so I’m not quite sure which it was :) &amp;ndash; and when
I saw how easy it was to use Rails to query a database I was very impressed.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/irb.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://localhost/assets/2014/9/17/underwater-walk.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo takes Professor Aronnax, Conseil and Ned Land&lt;br/&gt;on a hike through an underwater “forest.” Verne’s novel has&lt;br/&gt;many beautiful, detailed descriptions of underwater worlds&lt;br/&gt;he had never actually seen, and could only imagine.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Somehow Rails could take a simple, beautiful and readable line of Ruby code and
convert it into a SQL statement like this. How could this possibly work? It
seemed like magic!&lt;/p&gt;

&lt;p&gt;But it’s not magic. There are thousands of lines of code and years of computer
science research behind this simple line of code, the hard work behind the
scenes that makes ActiveRecord queries possible.&lt;/p&gt;

&lt;p&gt;Just as Professor Aronnax went on an underwater adventure with Captain Nemo,
I’d like to take you on an adventure inside of ActiveRecord to find out how it
works, how ActiveRecord generates and executes SQL statements.&lt;/p&gt;

&lt;p&gt;And why stop there? Later we’ll dive underneath ActiveRecord and inside an
actual database server to find out how it works too. How does it understand the SQL
statements we give it? How does it find the data we ask for and return it to
us? Let’s find out!&lt;/p&gt;

&lt;h2&gt;Agenda&lt;/h2&gt;

&lt;p&gt;Here’s our plan: First we’ll start with a look at &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;, the top, public API for
ActiveRecord many of you use everyday. Then, we’ll look deeper inside of
ActiveRecord to find out how it converts our Ruby queries into SQL statements.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/agenda.png"/&gt;&lt;/p&gt;

&lt;p&gt;Later, in the second half of the presentation we’ll dive even deeper and
directly into an actual relational database server (RDBMS); today I’ll use
PostgreSQL as an example. How does Postgres understand the SQL statement that
ActiveRecord sent it? How does it find the data we want? Finally, if we have
time we’ll look at the B-Tree Algorithm, which is part of the real magic that
allows database servers to work.&lt;/p&gt;

&lt;h2&gt;ActiveRecord::Relation&lt;/h2&gt;

&lt;p&gt;Let’s use my line of code from earlier as an example &amp;ndash; today we’ll be searching
for Captain Nemo together. Therefore, we’ll start with a &lt;span
class='code'&gt;User&lt;/span&gt; class, a subclass of &lt;span
class='code'&gt;ActiveRecord::Base&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/activerecord-base.png"/&gt;&lt;/p&gt;

&lt;p&gt;When I call &lt;span class='code'&gt;where&lt;/span&gt; what happens? It turns out the
&lt;span class='code'&gt;where&lt;/span&gt; method is defined in the &lt;span
class='code'&gt;ActiveRecord::Querying&lt;/span&gt; module:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/activerecord-querying.png"/&gt;&lt;/p&gt;

&lt;p&gt;But as you can see, ActiveRecord delegates the &lt;span class='code'&gt;where&lt;/span&gt;
method over to another method called &lt;span class='code'&gt;all&lt;/span&gt;, which
returns a new instance of a different class called &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;. In fact, my call to &lt;span
class='code'&gt;User.where&lt;/span&gt; is entirely equivalent to calling &lt;span
class='code'&gt;User.all.where&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/user-all.png"/&gt;&lt;/p&gt;

&lt;p&gt;ActiveRecord actually implements the &lt;span class='code'&gt;where&lt;/span&gt; method
using the new instance of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;.
Internally, &lt;span class='code'&gt;where&lt;/span&gt; is implemented by the &lt;span
class='code'&gt;ActiveRecord::QueryMethods&lt;/span&gt; module, included into &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;.  Next, &lt;span
class='code'&gt;ActiveRecord::QueryMethods#where&lt;/span&gt; returns, in turn, a second
new instance of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/activerecord-relation1.png"/&gt;&lt;/p&gt;

&lt;p&gt;If you look at the right, you can see the second &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object contains information about
what record we’re looking for, that we want the records where the name is
“Captain Nemo.”&lt;/p&gt;

&lt;p&gt;Of course, we don’t want all of the Captain Nemo users; we just
want the first one. Next, we call the &lt;span class='code'&gt;first&lt;/span&gt; method on
the new &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/activerecord-relation2.png"/&gt;&lt;/p&gt;

&lt;h2&gt;The Internal Implementation of ActiveRecord::FinderMethods#first&lt;/h2&gt;

&lt;p&gt;Now you can see ActiveRecord creates a third instance of &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;
&amp;ndash; this time with even more information about the query we’d like to execute.
  But what are all those other values: &lt;span class='code'&gt;order&lt;/span&gt;, &lt;span
  class='code'&gt;limit&lt;/span&gt; and &lt;span class='code'&gt;offset&lt;/span&gt;? Where do they
  come from? We can find out by taking a look at the implementation of &lt;span
  class='code'&gt;first&lt;/span&gt;. The &lt;span
  class='code'&gt;ActiveRecord::FinderMethods&lt;/span&gt; module implements this, which
  ActiveRecord includes into the &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; class.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/first1.png"/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see because we didn’t pass in a value for &lt;span class='code'&gt;limit&lt;/span&gt;, ActiveRecord
calls &lt;span class='code'&gt;find_nth&lt;/span&gt; and passes in a value of 0,
indicating we want the first record from the query result set. The second
argument, &lt;span class='code'&gt;offset_index&lt;/span&gt;, turns out to have a value of
zero, meaning we want to count into a window of records at the beginning of the
result set, not a window located somewhere farther along the result set.&lt;/p&gt;

&lt;p&gt;ActiveRecord implements a series of similar methods that will return the
second, third, fourth or even fifth record:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/second-fifth.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see the pattern here; the first argument is a zero-based index
indicating which record we want. And just in case we want the forty second
record from the result set, ActiveRecord implements this useful method&amp;hellip; :)&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/forty-second.png"/&gt;&lt;/p&gt;

&lt;p&gt;It’s no joke! &lt;span class='code'&gt;forty_two&lt;/span&gt; is actually in the
ActiveRecord source code; you can try it for yourself. Replacing &lt;span
class='code'&gt;first&lt;/span&gt; with the equivalent call to &lt;span
class='code'&gt;find_nth&lt;/span&gt;, here’s our example again:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/find-nth.png"/&gt;&lt;/p&gt;

&lt;p&gt;Following the code path through the &lt;span
class='code'&gt;ActiveRecord::FinderMethods&lt;/span&gt; module, we can see &lt;span
class='code'&gt;find_nth&lt;/span&gt; calls, in turn, &lt;span
class='code'&gt;find_nth_with_limit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/find-nth-with-limit.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now the arguments have been reversed; the first argument, 0, is now the offset
and the second, 1, is the number of records we want, or the limit value.&lt;/p&gt;

&lt;p&gt;Substituting one more time, let’s replace &lt;span
class='code'&gt;find_nth_with_limit&lt;/span&gt; with more detailed calls it makes to
&lt;span class='code'&gt;order&lt;/span&gt; and &lt;span class='code'&gt;limit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/detailed-calls.png"/&gt;&lt;/p&gt;

&lt;p&gt;Now you can see where all of the values in the final &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object come from. Each call to a
scoping method saves a new piece of information about our query, and returns a
new instance of the &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; class.
(We’ll see what &lt;span class='code'&gt;arel_table&lt;/span&gt; means in a minute.)&lt;/p&gt;

&lt;h2&gt;The Beauty of ActiveRecord::Relation&lt;/h2&gt;

&lt;p&gt;Taking a step back, we can see that our simple line of code, &lt;span
class='code'&gt;User.where(name: &amp;quot;Captain Nemo&amp;quot;).first&lt;/span&gt;, is creating a
series of &lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; objects like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/method-chain.png"/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 0px 30px; text-align: center;"&gt;
  &lt;img src="http://localhost/assets/2014/9/17/south-pacific.png"&gt;&lt;br/&gt;
  &lt;i&gt;Captain Nemo allowed Canadian harpoonist Ned Land&lt;br/&gt;to leave the submarine for a short time and explore a&lt;br/&gt;tropical island off the coast of Papua New Guinea.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;There are two interesting and beautiful things about this, I think. First,
notice the pattern that ActiveRecord uses: each call to a method returns a new
instance of the class that implemented that method. This is what allows us to
easily chain together different method calls. We can add on as many different
scopes as we wish; because each new object is also an &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt;, it implements all of the same
methods. You can use the same pattern in your own code. All you need to do is
create a new instance of the class that implements each method, and return
that. One reason to study internal code like this is to learn about and find
new ideas that you can use in your own code.&lt;/p&gt;

&lt;p&gt;The second beautiful thing about &lt;span
class='code'&gt;ActiveRecord::Relation&lt;/span&gt; is that it’s lazy.  Using this chain
of method calls we are building up metadata or information about our query,
without actually executing the query itself. It’s almost as if we were using a
functional programming language like Haskell or Lisp. Using this trick,
ActiveRecord allows us to specify exactly the query we want, without having to
worry about executing it until we’re ready.&lt;/p&gt;

&lt;p&gt;It’s not until we call the &lt;span class='code'&gt;to_a&lt;/span&gt; method, in other to convert the
&lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object into an array and access the result set, that
ActiveRecord executes the query:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost/assets/2014/9/17/to-a.png"/&gt;&lt;/p&gt;

&lt;p&gt;You can see here that &lt;span class='code'&gt;to_a&lt;/span&gt; calls &lt;span class='code'&gt;load&lt;/span&gt; internally,
which later calls the &lt;span class='code'&gt;ActiveRecord::ConnectionAdapters::DatabaseStatements#select_all&lt;/span&gt;
method.&lt;/p&gt;

&lt;h2&gt;Next time&lt;/h2&gt;

&lt;p&gt;In the next few days I’ll post &lt;a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements"&gt;the second part of my presentation from
Barcelona&lt;/a&gt;.
We’ll look at what “Relational Algebra” means and how the Arel gem converts our
&lt;span class='code'&gt;ActiveRecord::Relation&lt;/span&gt; object into a string
containing a SQL statement.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>A Rule of Thumb for Strong Parameters</title>
    <link href="http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters</id>
    <published>2014-06-16T03:00:00Z</published>
    <updated>2014-06-16T03:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/6/16/security.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;It can be hard to open the Strong Parameters&lt;br/&gt;door and let permitted values into your Rails 4 app.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last week I banged my head against the wall for a few hours trying to figure
out how to whitelist input values for my Rails 4 app</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/6/16/security.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;It can be hard to open the Strong Parameters&lt;br/&gt;door and let permitted values into your Rails 4 app.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Last week I banged my head against the wall for a few hours trying to figure
out how to whitelist input values for my Rails 4 app using the &lt;a href="http://edgeguides.rubyonrails.org/action_controller_overview.html#strong-parameters"&gt;Strong
Parameters&lt;/a&gt;
feature. Calling &lt;span class="code"&gt;permit&lt;/span&gt; when you have a simple
attributes hash for a single new object is straightforward, but figuring out
how to call &lt;span class="code"&gt;permit&lt;/span&gt; for a complex, nested set of attributes can be nearly
impossible.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;TL;DR:&lt;/b&gt; Use this rule of thumb when trying to figure out how to whitelist nested attributes:&lt;/p&gt;

&lt;blockquote&gt;To Permit a Hash, Pass an Array&lt;br/&gt;
  To Permit an Array, Pass a Hash&lt;/blockquote&gt;


&lt;p&gt;After studying the problem for a while, I noticed this curious pattern: To whitelist a simple hash of attributes, you pass
&lt;span class="code"&gt;permit&lt;/span&gt; an array. To whitelist an array of nested objects, you pass it a hash,
including that hash in the surrounding array.&lt;/p&gt;

&lt;p&gt;Not familiar with Strong Parameters yet? What do I mean by “whitelist?” Why do
you need this rule of thumb? My post today will explain.&lt;/p&gt;

&lt;h2&gt;To Permit a Hash, Pass an Array&lt;/h2&gt;

&lt;p&gt;Rails 4 requires you to whitelist or authorize input values for your app. This
important new feature, known as Strong Parameters, adds an extra layer of
security that prevents attackers from posting harmful or garbage information to
your site.&lt;/p&gt;

&lt;p&gt;Here’s how it works: Suppose you have a &lt;span class="code"&gt;Post&lt;/span&gt; model
with title and body columns. Using Rails 4, you would write a create controller
action like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/simple_controller.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you first tell Rails which attributes are allowed for new post objects &amp;ndash;
title and body in this example &amp;ndash; and then you create the new post. This is
simple enough and quite readable. You are telling Rails: “data for a post is
required and it’s attributes may only include title and body attributes.”&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/diagram1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In the diagram above you can see the post attribute hash on the left, and the
arguments for &lt;span class="code"&gt;permit&lt;/span&gt; on the right. Notice the arguments are actually a
single array (internally Rails processes the arguments as an array). Each key/value pair on the left maps to an array element on the
right. You permit a hash by passing an array.&lt;/p&gt;

&lt;h2&gt;Strong Parameters Confusion&lt;/h2&gt;

&lt;p&gt;However, now suppose you add a second model to your app, &lt;span
  class="code"&gt;Comment&lt;/span&gt;. Let’s suppose a post has many comments, and each
comment has a single text attribute.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/has-many.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because your app is a REST-ful JSON service (what else do people use Rails for
these days?) you have a requirement to create a post and its comments from a
single JSON string:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/json.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because the comment array is named “comments” you assume ActiveRecord will
create the associated comment models along with the new post. That is,
ActiveRecord should call &lt;span class="code"&gt;comments=&lt;/span&gt; on the new post
and pass in the comment attributes. But it doesn’t work. Instead, using the
code from earlier you get:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/warning.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Ah &amp;ndash; you forgot to whitelist the comments attribute. You try adjusting the call
to &lt;span class="code"&gt;permit&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/permit-comments.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;It still doesn’t work. You get the same warning:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/warning.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Clearly Rails isn’t listening! You just told it comments is permitted &amp;ndash; why
does Rails give you the same warning again? Maybe you need to create the
comment objects yourself, as a separate step:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/create-comments.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now things are even worse: Rails raises an exception!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/exception.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The problem here is that the &lt;span class="code"&gt;Comment&lt;/span&gt; model is
complaining that you haven’t whitelisted its attributes. Somehow each
ActiveRecord model has knowledge about which attributes were whitelisted and
which weren’t!&lt;/p&gt;

&lt;p&gt;If you happened to know that Rails 4 saves the parameters inside an &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object, you could try
creating a separate instance of this class for each comment, and whitelist it&amp;rsquo;s text attribute directly:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/permit-comments2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But you’ll still get the same “Unpermitted parameters” warning when you try to
create the post next &amp;ndash; not to mention that your code has become incredibly
confusing and verbose. What’s going on here? There must be some way of creating
nested objects without warnings or exceptions.&lt;/p&gt;

&lt;h2&gt;To Permit an Array, Pass a Hash&lt;/h2&gt;

&lt;p&gt;The solution is to permit all the post and comment attributes with a single
call to &lt;span class="code"&gt;ActionController::Parameters#permit&lt;/span&gt;, like
this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/nested-solution.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;What? What does the complex argument list to &lt;span class="code"&gt;permit&lt;/span&gt; mean? How in the world
would anyone know to pass that in?&lt;/p&gt;

&lt;p&gt;My rule of thumb can help. In this example, you are permitting an array of
comments by passing a hash. Imagine if your app received a post with two
comments, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/diagram2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left you see the nested attributes for the post and its comments. Rails
has parsed this for you from a JSON string. On the right are the arguments you
pass to &lt;span class="code"&gt;permit&lt;/span&gt;. Notice how the hash of post
attributes contains an array for the comments &amp;ndash; in the call to &lt;span class="code"&gt;permit&lt;/span&gt; you
replace this array with a hash! To permit an array, pass a hash.&lt;/p&gt;

&lt;p&gt;This hash, in turn, contains an array listing the attributes of each comment
object (just &lt;span class="code"&gt;[:text]&lt;/span&gt; here).&lt;/p&gt;

&lt;h2&gt;Whitelisting Rails Nested Attributes&lt;/h2&gt;

&lt;p&gt;Note: if your Rails app was in fact a web site, you might use the Rails nested
attributes feature with a complex HTML form. In this case, you would declare
that posts accept nested attributes for comments, directing ActiveRecord to
automatically create the comment objects for you:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/accepts-nested.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;To make this work you will need to adjust your call to &lt;span
class="code"&gt;permit&lt;/span&gt; slightly:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/nested-attribs-permit.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;With &lt;span class="code"&gt;accepts_nested_attribute_for&lt;/span&gt;, Rails expects the
comments to be saved as &lt;span class="code"&gt;comments_attributes&lt;/span&gt;. Also,
each comment must have an &lt;span class="code"&gt;id&lt;/span&gt; attribute in order for
the web forms to update existing comments properly. (Also, Rails represents the
comment array as a hash, with the id as the key for each comment.)&lt;/p&gt;

&lt;p&gt;But the syntax is almost the same, and the same rule applies: to permit an
array of comments you call &lt;span class="code"&gt;permit&lt;/span&gt; with a hash.&lt;/p&gt;

&lt;h2&gt;Under the Hood&lt;/h2&gt;

&lt;p&gt;Internally, Rails uses a trick to tell ActiveRecord which attributes were
permitted and which weren’t. Here’s how it works:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/hashes.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left is a normal hash &amp;ndash; you can create an ActiveRecord model using this
hash without worrying about whitelisting parameters. On the right is an &lt;span
class="code"&gt;ActionController::Parameters&lt;/span&gt; object; notice it looks almost
the same.  &lt;span class="code"&gt;ActionController::Parameters&lt;/span&gt; is actually a
subclass of &lt;span class="code"&gt;Hash&lt;/span&gt; (via &lt;span
class="code"&gt;ActiveSupport::HashWithIndifferentAccess&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;But on the right notice that the &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object contains a &lt;span class="code"&gt;permitted?&lt;/span&gt;
method. This tells ActiveRecord whether the attributes in that hash were
whitelisted or not.&lt;/p&gt;

&lt;p&gt;When you create a new post or any &lt;span class="code"&gt;ActiveRecord::Base&lt;/span&gt;
object, code inside of Rails checks whether the attributes hash implements the
&lt;span class="code"&gt;permitted?&lt;/span&gt; method or not:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/internals1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because a normal hash doesn’t respond to &lt;span class="code"&gt;permitted?&lt;/span&gt;,
ActiveRecord creates the new post without complaining.&lt;/p&gt;

&lt;p&gt;However, if you try to create a post from an &lt;span
  class="code"&gt;ActionController::Parameters&lt;/span&gt; object, Rails finds the
&lt;span class="code"&gt;permitted?&lt;/span&gt; method:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/internals2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;If you didn’t whitelist this hash using a call to &lt;span class="code"&gt;permit&lt;/span&gt;, &lt;span class="code"&gt;permitted?&lt;/span&gt; will
return &lt;span class="code"&gt;false&lt;/span&gt; and Rails will raise the &lt;span class="code"&gt;ActiveModel::ForbiddenAttributesError&lt;/span&gt;
exception.&lt;/p&gt;

&lt;h2&gt;Still Confused? Just Use a Normal Hash&lt;/h2&gt;

&lt;p&gt;If all of this is still confusing you &amp;ndash; if you’re still having trouble figuring
out the call to &lt;span class="code"&gt;permit&lt;/span&gt; properly for your complex JSON input &amp;ndash; then remember you
can always just use normal hashes instead of &lt;span class="code"&gt;ActionController::Parameters&lt;/span&gt;
objects.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/6/16/normal-hashes.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you are whitelisting or permitting each attribute manually by copying them
into normal hashes. Since &lt;span class="code"&gt;Hash&lt;/span&gt; doesn&amp;rsquo;t implement &lt;span
class="code"&gt;permitted?&lt;/span&gt;, ActiveRecord won’t raise a &lt;span
class="code"&gt;ActiveModel::ForbiddenAttributesError&lt;/span&gt; exception.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using a Ruby Class To Write Functional Code</title>
    <link href="http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code</id>
    <published>2014-04-08T03:00:00Z</published>
    <updated>2014-04-08T03:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet.jpg"&gt;&lt;br/&gt;
    &lt;i&gt;The time sheets I used at my first programming&lt;br/&gt;
    job in the Summer of 1986 looked just like this.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Recently I’ve been spending some of my free time studying Clojure and Haskell.
I’ve been learning how a program built with a</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet.jpg"&gt;&lt;br/&gt;
    &lt;i&gt;The time sheets I used at my first programming&lt;br/&gt;
    job in the Summer of 1986 looked just like this.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Recently I’ve been spending some of my free time studying Clojure and Haskell.
I’ve been learning how a program built with a series of small, pure functions
can be very robust and maintainable. However, I don’t want to give up on Ruby.
I want to keep the expressiveness, beauty and readability of Ruby, while
writing simple functions with no side effects.&lt;/p&gt;

&lt;p&gt;But how can this be possible? Unlike functional languages, Ruby encourages you
to hide state inside of objects, and to write functions (methods) that have
side effects, modifying an instance variable for example. Isn’t using an object
oriented language like Ruby, Python, or Java a decision to abandon the benefits
of functional programming?&lt;/p&gt;

&lt;p&gt;No. In fact, a couple of weeks ago Ruby’s object model helped me refactor one
confusing function into a series of small simple ones. Today I’ll show you what
happened, how using a Ruby class helped me write more functional code.&lt;/p&gt;

&lt;div style="clear: left"/&gt;&lt;/div&gt;


&lt;h2&gt;Parsing Timesheet Data&lt;/h2&gt;

&lt;p&gt;Let’s suppose you are a ScrumMaster&amp;trade; and want to make sure your team of
developers, including me, is putting in enough hours on your project (instead
of taking long lunches or writing blog posts). For example, suppose I report my
hours like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/timesheet-data.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You could parse my timesheet data using this simple Ruby program:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is simple enough to understand and works fine. &lt;span
class="code"&gt;parse1&lt;/span&gt; is small function; if you remove the calls to &lt;span class="code"&gt;puts&lt;/span&gt;
it only contains 3 lines of code, two simple calls to &lt;span class="code"&gt;split&lt;/span&gt;. How could this be
any simpler?&lt;/p&gt;

&lt;h2&gt;A First Pass at a Functional Solution&lt;/h2&gt;

&lt;p&gt;Next you decide to look for a more functional solution by &lt;a href="http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby"&gt;asking Ruby for what
you want, instead of telling it what to
do&lt;/a&gt;.
You try to break the problem up into small functions that return what you need.
But what functions should you write? What values should they return? In this
simple example, the answer is obvious: you can write a function to parse each
value in the timesheet data.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/asking.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You have divided the problem up into small pieces. Each function will return a
predictable value based on some input and doesn’t have any side effects. These
will be &lt;em&gt;pure&lt;/em&gt; functions: They will always return the same result given the same
arguments. You know that if you pass a line from my timesheet, &lt;span
  class="code"&gt;last_name&lt;/span&gt; will always return “Shaughnessy.” You’ve turned
the problem around; you’ve phrased the problem as a series of questions rather
than as a list of instructions.&lt;/p&gt;

&lt;p&gt;Refactoring &lt;span class="code"&gt;parse1&lt;/span&gt; above, you implement the
functions, at least in a somewhat verbose and ugly fashion:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/refactoring.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Testing Pure Functions&lt;/h2&gt;

&lt;p&gt;As a Certified ScrumMaster&amp;trade;, you believe in TDD and other extreme
programming practices. Originally, while writing &lt;span
  class="code"&gt;parse1&lt;/span&gt; above, it didn’t even occur to you to write tests
(and if it had, it would have been very difficult).  However, now after
breaking the problem up into a series of functions, it seems natural to write
tests for them.&lt;/p&gt;

&lt;p&gt;Next, you express your expectations for these functions using Minitest specs,
for example:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/spec.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Because the functions are small, the tests are small. Because the tests are
small, you actually take the time to write them. Because the functions are
decoupled from each other, it’s easy for you to decide which tests to write.&lt;/p&gt;

&lt;p&gt;To your surprise, you actually find a bug!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/spec-fails.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Earlier in &lt;span class="code"&gt;parse1&lt;/span&gt;, the extra space was lost in the
&lt;span class="code"&gt;puts&lt;/span&gt; output and you didn’t notice it. Separating this into a small function and
carefully testing it revealed a minor problem. You adjust two of the functions
to remove the extra space:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/fixing-bug.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Pushing Ruby Out Of Its Comfort Zone&lt;/h2&gt;

&lt;p&gt;You’re happy with your new tests. Ruby allowed you describe the behavior of the
functions in a very natural, readable way. Ruby at its best. As an added bonus,
the tests now also pass!&lt;/p&gt;

&lt;p&gt;However, your functions aren’t so pretty. There is a lot of obvious
duplication: The &lt;span class="code"&gt;office&lt;/span&gt;, &lt;span
  class="code"&gt;employee_id&lt;/span&gt; and &lt;span class="code"&gt;last_name&lt;/span&gt;
functions all call &lt;span class="code"&gt;line.split(&amp;#39;,&amp;#39;)&lt;/span&gt;. To fix this, you
decide to extract &lt;span class="code"&gt;line.split(&amp;#39;,&amp;#39;)&lt;/span&gt; into a separate
function, removing the duplication:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/extracting-method.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This doesn&amp;rsquo;t look any better; in fact, there’s a deeper problem here. To see
what I mean let’s refactor &lt;span class="code"&gt;parse1&lt;/span&gt; from earlier to use
our new functions:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is clean and easy to follow, but now you have a performance bug: Each time
around the loop, your code passes the same line to &lt;span
class="code"&gt;employee_id&lt;/span&gt;, &lt;span class="code"&gt;office&lt;/span&gt; and &lt;span
class="code"&gt;last_name&lt;/span&gt;. Now Ruby will call the &lt;span class="code"&gt;values&lt;/span&gt; function over and
over again. This is unnecessary and needless; in fact, our original &lt;span
  class="code"&gt;parse1&lt;/span&gt; code didn’t have this problem. By introducing
functions we have slowed down our code.&lt;/p&gt;

&lt;p&gt;However, because these are simple, pure functions, you know they will always
return the same value given the same input argument, the same line of text in
this example. This means theoretically you can avoid calling &lt;span
class="code"&gt;split&lt;/span&gt; over and over again by caching the results.&lt;/p&gt;

&lt;p&gt;At first, you try to cache the return value of &lt;span class="code"&gt;split&lt;/span&gt;
by using a hash table like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/hash1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This looks straightforward: The keys in &lt;span class="code"&gt;split_lines&lt;/span&gt;
are the lines and the values are the corresponding split lines. You use Ruby’s
elegant &lt;span class="code"&gt;||=&lt;/span&gt; operator either to return a cached value
from the hash or actually call &lt;span class="code"&gt;split&lt;/span&gt;, updating the
hash.&lt;/p&gt;

&lt;p&gt;The only problem with this is that it doesn’t work. The code inside of the
&lt;span class="code"&gt;values&lt;/span&gt; function can’t access the &lt;span
class="code"&gt;split_lines&lt;/span&gt; hash, located outside the method.  And if you
move &lt;span class="code"&gt;split_lines&lt;/span&gt; inside of &lt;span class="code"&gt;values&lt;/span&gt;, it would become a
local variable and not retain values across method calls.&lt;/p&gt;

&lt;p&gt;To work around this problem you could pass the cache as an additional argument
to &lt;span class="code"&gt;values&lt;/span&gt;, but this would make your program even more
verbose than it is now.  Or you could create the &lt;span
class="code"&gt;values&lt;/span&gt; method using &lt;span
class="code"&gt;define_method&lt;/span&gt;, instead of &lt;span class="code"&gt;def&lt;/span&gt;,
like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/hash2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This confusing Ruby syntax allows the code inside of the new &lt;span class="code"&gt;values&lt;/span&gt; method to
access the surrounding scope, including the hash table.&lt;/p&gt;

&lt;p&gt;However, taking a step back, something about your program now feels wrong.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/step-back.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Instead of making your code simpler and easier to understand, functional
programming has started to make your Ruby code more confusing and harder to
read. You’ve introduced a new data structure to cache results, and resorted to
confusing metaprogramming to make it work. And your functions are still quite
repetitive.&lt;/p&gt;

&lt;p&gt;What’s gone wrong? Possibly Ruby isn’t the right language to use with
functional programming.&lt;/p&gt;

&lt;h2&gt;Introducing a Ruby Class&lt;/h2&gt;

&lt;p&gt;Next, you decide to forget all about functional programming and to try again by
using a Ruby class. You write a &lt;span class="code"&gt;Line&lt;/span&gt; class,
representing a single line of text from the timesheet text file:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;And you decide to move your functions into the new &lt;span class="code"&gt;Line&lt;/span&gt; class:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now you have a lot less noise. The biggest improvement is that now there’s no
need to pass the line of text around as a parameter to each function. Instead,
you hide it away in an instance variable, making the code much easier to read.
Also, your functions have become methods. Now you know all the functions
related to parsing lines are in the &lt;span class="code"&gt;Line&lt;/span&gt; class. You
know where to find them, and more or less what they are for. Ruby has helped
you organize your code using a class, which is really just a collection of
functions.&lt;/p&gt;

&lt;p&gt;Continuing to simplify, you refactor the &lt;span class="code"&gt;value&lt;/span&gt; method at the bottom to remove
the confusing &lt;span class="code"&gt;define_method&lt;/span&gt; syntax:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/refactor-values.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now each instance of the &lt;span class="code"&gt;Line&lt;/span&gt; class, each line of text you program uses, will
have its own copy of &lt;span class="code"&gt;@values&lt;/span&gt;. By using a Ruby class, you don’t need to
resort to a hash table to map between lines (keys) and split lines (values).
Instead you employ a very common Ruby idiom, combining an instance variable
&lt;span class="code"&gt;@values&lt;/span&gt;, with the &lt;span class="code"&gt;||=&lt;/span&gt;
operator. Instance variables are the perfect place to cache information such as
method return values.&lt;/p&gt;

&lt;h2&gt;Breaking All the Rules&lt;/h2&gt;

&lt;p&gt;Now your code is much easier to read. Using an object oriented instead of a
functional design turned out to be a good idea.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/line3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;With your object oriented solution, you have broken some of the most important
rules of functional programming: First, you created hidden state, the &lt;span
class="code"&gt;@line&lt;/span&gt; instance variable, wrapping it up and hiding it
inside the &lt;span class="code"&gt;Line&lt;/span&gt; class. The &lt;span class="code"&gt;@values&lt;/span&gt; instance
variable holds even more state information. And second, the &lt;span class="code"&gt;initialize&lt;/span&gt; and
&lt;span class="code"&gt;values&lt;/span&gt; methods have side effects: They change the value of &lt;span
class="code"&gt;@line&lt;/span&gt; and &lt;span class="code"&gt;@values&lt;/span&gt;. Finally,
all the other methods of &lt;span class="code"&gt;Line&lt;/span&gt; are no longer pure functions! They return values
that depend on state located outside of each function: the &lt;span
class="code"&gt;@line&lt;/span&gt; variable. In fact, they can return different values
even though they take no arguments at all.&lt;/p&gt;

&lt;p&gt;But I believe these are technicalities. You haven’t lost the benefits of
functional programming with this refactoring. While the methods of &lt;span
  class="code"&gt;Line&lt;/span&gt; depend on external state (&lt;span
  class="code"&gt;@line&lt;/span&gt; and &lt;span class="code"&gt;@values&lt;/span&gt;), that state
  isn’t located very far away. It’s still easy to predict, understand and test
  what these small functions do. Also, while &lt;span class="code"&gt;@line&lt;/span&gt; is
  technically a mutable string that you change in your program, in practice it
  isn’t. You set it once using &lt;span class="code"&gt;initialize&lt;/span&gt; and then
  never change it again. While you may update &lt;span class="code"&gt;@values&lt;/span&gt;
  each time &lt;span class="code"&gt;values&lt;/span&gt; is called, it&amp;rsquo;s just a performance
  optimization. It doesn’t change the overall behavior of values.&lt;/p&gt;

&lt;p&gt;You’ve broken the rules and rewritten your pure, functional program is a more
idiomatic, Ruby manner. However, you haven’t lost the spirit of functional
programming. Your code is just as easy to understand, maintain and test.&lt;/p&gt;

&lt;h2&gt;Creating an Object Pipeline&lt;/h2&gt;

&lt;p&gt;Wrapping up, you refactor your original program to use your new &lt;span
class="code"&gt;Line&lt;/span&gt; class like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Of course, there’s not much difference here. You simply added a line of code to
create new line objects, and then called its methods instead of your original
functions.&lt;/p&gt;

&lt;p&gt;Finally, you decide to take one step further and refactor again by mapping the
array of text lines to an array of line objects:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/object-pipeline.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 80px 0px 25px 20px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/4/8/factory.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Again, not much difference in the code. However, the way you think about your
program has changed dramatically. Now your code implements a pipeline of sorts,
passing data through a series of operations or transformations. You start with
an array of text lines from a file, convert them into an array of Ruby objects,
and finally process each object using your parse functions.&lt;/p&gt;

&lt;p&gt;This pattern of passing data through a series of operations is common in
languages such as Haskell and Clojure. What’s interesting here is how Ruby
objects are the perfect target for these operations. You’ve used a Ruby class
to implement a functional programming pattern.&lt;/p&gt;

&lt;br/&gt;


&lt;br/&gt;


&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; &lt;a href="https://twitter.com/orend"&gt;Oren Dobzinski&lt;/a&gt; suggested adding a
&lt;span class="code"&gt;to_s&lt;/span&gt; method to &lt;span class="code"&gt;Line&lt;/span&gt;, which
would allow us to push the object pipeline idea even further. Thanks Oren! See
Dave Thomas&amp;rsquo;s article &lt;a href="http://pragdave.me/blog/2014/02/11/telling-asking-and-the-power-of-jargon/"&gt;Telling, Asking, and the Power of
Jargon&lt;/a&gt;
for more background on &amp;ldquo;Tell, Don&amp;rsquo;t Ask.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/4/8/parse5.png"&gt;&lt;br/&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Use An Ask, Don’t Tell Policy With Ruby</title>
    <link href="http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/2/10/use-an-ask-dont-tell-policy-with-ruby</id>
    <published>2014-02-10T04:00:00Z</published>
    <updated>2014-02-10T04:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/2/10/innisfree.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Innisfree is an actual island in Lough Gill, County Sligo, Ireland&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;The next time you need to develop a new algorithm, ask Ruby for what you want,
don’t tell it what to do. Don’t think of your code as a series of instructions
for t</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/2/10/innisfree.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;Innisfree is an actual island in Lough Gill, County Sligo, Ireland&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;The next time you need to develop a new algorithm, ask Ruby for what you want,
don’t tell it what to do. Don’t think of your code as a series of instructions
for the computer to follow. Instead, ask Ruby for what you need: Your code
should state the solution to your problem, even if you’re not sure what that
solution is yet! Then dive into more and more detail, filling in your
solution’s gaps as you do. This can lead to a more expressive, functional
solution that you might not find otherwise.&lt;/p&gt;

&lt;p&gt;Too often over the years I’ve written code that consists of instructions for
the computer to follow. Do this, do that, and then finish by doing this third
thing. As I write code I imagine I am the computer, in a way, asking myself:
What do I need to do first to solve this problem? When I decide, this becomes
the first line of code in my program. Then I continue, writing each line of
code as another instruction for the computer to follow.&lt;/p&gt;

&lt;p&gt;But what does “Ask, Don’t Tell” mean exactly? And how could Ruby possibly know
the answer when I ask it something? An example will help you understand what I
mean.&lt;/p&gt;

&lt;h2&gt;Parsing a Yeats Poem&lt;/h2&gt;

&lt;p&gt;Last week I needed to parse a text file to obtain the lines of text that
appeared after a certain word. My actual task was very boring (separating blog
articles from their metadata), so instead let’s work with something more
beautiful, &lt;em&gt;The Lake Isle Of Innisfree&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;




&lt;blockquote&gt;
  I will arise and go now, and go to Innisfree,&lt;br/&gt;
  And a small cabin build there, of clay and wattles made:&lt;br/&gt;
  Nine bean-rows will I have there, a hive for the honeybee,&lt;br/&gt;
  And live alone in the bee-loud glade.&lt;br/&gt;
  &lt;br/&gt;
  And I shall have some peace there, for peace comes dropping slow,&lt;br/&gt;
  Dropping from the veils of the morning to where the cricket sings;&lt;br/&gt;
  There midnight's all a glimmer, and noon a purple glow,&lt;br/&gt;
  And evening full of the linnet's wings.&lt;br/&gt;
  &lt;br/&gt;
  I will arise and go now, for always night and day&lt;br/&gt;
  I hear lake water lapping with low sounds by the shore;&lt;br/&gt;
  While I stand on the roadway, or on the pavements grey,&lt;br/&gt;
  I hear it in the deep heart's core.&lt;br/&gt;
&lt;/blockquote&gt;


&lt;p&gt;My task is to write a Ruby script to return the line that contains a given
word, along with the following lines:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/console.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Telling Ruby What To Do&lt;/h2&gt;

&lt;p&gt;When I first wrote this script, I put myself in the computer’s shoes: What do I
need to do to find the target word? I started writing instructions for Ruby to
follow.&lt;/p&gt;

&lt;p&gt;First I need to open the file and read in the poem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/one.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here &lt;span class="code"&gt;File#readlines&lt;/span&gt; saves all the lines of text into an array, which the &lt;span class="code"&gt;parse&lt;/span&gt;
method will process, returning the result in another array. Later I join the
result lines together and print them out.&lt;/p&gt;

&lt;p&gt;How do I implement &lt;span class="code"&gt;parse&lt;/span&gt;? Again, I imagine that I am the computer, that I am
Ruby. How do I find the lines that follow &lt;em&gt;glimmer&lt;/em&gt;? Well, obviously I need to
loop through the array looking for the target word.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/two.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Once I find the word, I’ll start saving the lines into a new array called
&lt;span class="code"&gt;result&lt;/span&gt;. Since I want to save all the following lines and not just the matching
line, I’ll also use a boolean flag to keep track of whether I’ve already seen
the target.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/three.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;What’s wrong with this code? Nothing really. It works just fine, and it’s
even somewhat idiomatic Ruby. In the past, I would have probably considered
this done and moved on.&lt;/p&gt;

&lt;p&gt;However, I can do better than this. I can ask Ruby for what I want, instead of
telling Ruby what to do.&lt;/p&gt;

&lt;h2&gt;Ask Ruby For What You Want&lt;/h2&gt;

&lt;p&gt;Don’t imagine you are the computer. Don’t think about how to solve a problem by
figuring out what Ruby should do and then writing down instructions for it to
follow. Instead, start by asking Ruby for the answer.&lt;/p&gt;

&lt;p&gt;What should my method return? An array of the lines that appear after the
target word. To reflect this, I’ll rename my method from &lt;span class="code"&gt;parse&lt;/span&gt; (telling Ruby
what to do) to &lt;span class="code"&gt;lines_after&lt;/span&gt; (asking Ruby for what I want).&lt;/p&gt;

&lt;p&gt;This might seem like an unimportant detail, but naming methods is one of the
most difficult and important things a programmer does. Picking a name for a
method gives the reader a hint about what the method does, about what your
intentions were when you wrote it. Think of writing code the same way you would
think of writing an essay or story. You want your readers to understand what
you are saying, and to be able to follow along. (You also want them to enjoy
reading enough that they consider the code to be their own someday.)&lt;/p&gt;

&lt;p&gt;To get started I’ll write the new method to return an empty array.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/four.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Notice on the left I changed the label from “Instructions:” to “What do I
want?” This reflects my new way of thinking about the problem.&lt;/p&gt;

&lt;p&gt;Now, what does “appear after the target word” mean exactly? It means the lines
that appear in the array after (and including) the line containing the target.
Ah… in other words, the &lt;span class="code"&gt;lines_after&lt;/span&gt; method should return a subset or slice of the
array. Rewriting the problem in a different way lead me towards a solution I
hadn&amp;rsquo;t thought of before.&lt;/p&gt;

&lt;p&gt;Now I can rewrite the “What do I want?” text like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/five.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I rewrote what I want from Ruby to be more specific: I want a “portion of the
array” and I want the portion “including and following the line containing the
target.” I haven’t written much code yet, but I’ve taken a big step forward in
how I think about the problem.&lt;/p&gt;

&lt;p&gt;On the right, I’ve written code to return a subset of the array,
&lt;span class="code"&gt;lines[target_index..-1]&lt;/span&gt;. But my solution is still incomplete; what should
&lt;span class="code"&gt;target_index&lt;/span&gt; be?&lt;/p&gt;

&lt;p&gt;Thinking about this a bit, it’s easy to see how to find the line containing the
target string: I can use &lt;span class="code"&gt;detect&lt;/span&gt; to find the line that includes the target word.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/six.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But I’m still not done. I need the index of the line containing the target, not
the line itself. How can I find &lt;span class="code"&gt;target_index&lt;/span&gt;? Again, I shouldn’t tell Ruby what
to do (maybe create a local variable and loop through the lines checking each
one). Instead, I should ask Ruby for what I need. What do I need? I need the
index which corresponds to the line containing the target. In other words, I
need to find (to detect) the target index, not the target line.&lt;/p&gt;

&lt;p&gt;Here’s how to do it:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/seven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here I use Ruby’s &lt;span class="code"&gt;detect&lt;/span&gt; method to search a range of index values, not lines.
Inside the block I check whether the line corresponding to each index
(&lt;span class="code"&gt;lines[i]&lt;/span&gt;) contains the target. At the bottom I return the correct slice of the
array if I found the target, or an empty array if I didn’t.&lt;/p&gt;

&lt;h2&gt;Learning From Functional Languages&lt;/h2&gt;

&lt;p&gt;In my opinion this code is better than what I showed earlier. Why? They both
work equally well. What’s the difference? Let&amp;rsquo;s take a look at them side-by-side.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/compare.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;First of all, I have simpler, more terse code. Less code is better. The &lt;span class="code"&gt;lines_after&lt;/span&gt;
method contains just 4 lines of code while the &lt;span class="code"&gt;parse&lt;/span&gt; method
contains 9. Of course, I could find ways to rewrite &lt;span class="code"&gt;parse&lt;/span&gt; to use
fewer lines, but any way you look at it &lt;span class="code"&gt;lines_after&lt;/span&gt; is simpler than &lt;span class="code"&gt;parse&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;parse&lt;/span&gt; method contains two local variables which are changed, or &lt;em&gt;mutated&lt;/em&gt;, by
code inside the loop. This makes the method harder to understand. What is the
value of &lt;span class="code"&gt;flag&lt;/span&gt;? What about &lt;span class="code"&gt;result&lt;/span&gt;? To really understand how &lt;span class="code"&gt;parse&lt;/span&gt; works you
almost need to simulate the loop inside your head, thinking about how the flag
and result values change over time.&lt;/p&gt;

&lt;p&gt;The &lt;span class="code"&gt;lines_after&lt;/span&gt; method also contains two local variables. However, they aren’t used
in the same way &amp;ndash; they aren’t changed as the program runs. The block
parameter, &lt;span class="code"&gt;i&lt;/span&gt;, while different each time the block is called, doesn’t change
inside the block. It’s meaning is clear and unambiguous while that block is
running. Similarly, the &lt;span class="code"&gt;target_index&lt;/span&gt; variable is set once to an intermediate
value, not changed once each time around a loop.&lt;/p&gt;

&lt;p&gt;Terse, simple code that doesn’t change values while it is running is the
hallmark of functional programming languages like Haskell or Clojure. While
these languages allow you to write concurrent code without using locks, their
chief benefit is that they encourage (Clojure) or even force you (Haskell) to write simple, terse
code. Code that asks the computer for what you need, not code that tells the
computer what to do.&lt;/p&gt;

&lt;p&gt;But, as we’ve seen, you don’t need to abandon Ruby to write functional code.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; Simon Kröger and Josh Cheek both suggested using &lt;span
  class="code"&gt;drop_while&lt;/span&gt;, which gives us an even more readable,
functional solution:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/2/10/eight.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I also decided to rename the &lt;span class="code"&gt;after&lt;/span&gt; method to &lt;span
  class="code"&gt;lines_after&lt;/span&gt;, based on the comments from TenderGlove and
John Kary. I agree with them &lt;span class="code"&gt;after&lt;/span&gt; would make more sense if I
called it as a method on an object containing the lines (e.g. &lt;span class="code"&gt;lines.after&lt;/span&gt;). But as a simple
function like in this example &lt;span class="code"&gt;lines_after&lt;/span&gt; is more
expressive.&lt;/p&gt;

&lt;p&gt;Thanks guys!&lt;/p&gt;

&lt;h2&gt;Learning From Sandi Metz&lt;/h2&gt;

&lt;p&gt;In her famous book, &lt;a href="http://www.poodr.com"&gt;Practical Object-Oriented Design in Ruby&lt;/a&gt;, Sandi Metz
mentions the Ask, Don’t Tell policy also, but using slightly different words.
With her brilliant bicycle examples, Sandy shows us in Chapter 4 of
POODR why we should be &lt;em&gt;Asking for &amp;ldquo;What&amp;rdquo; Instead of Telling &amp;ldquo;How&amp;rdquo;&lt;/em&gt;. When you
send a message to an object, you should ask it for what you want, not tell it
what to do or make assumptions about how it works internally. Sandi shows us
how this policy &amp;ndash; along with other important design principles &amp;ndash; helps us write
classes that are more independent and decoupled one from the other.&lt;/p&gt;

&lt;p&gt;The Ask, Don’t Tell policy applies equally well to functional programming and
object oriented programming. At a lower level, it helps us write more terse,
functional Ruby methods. Stepping back, it can also help us design object
oriented applications that are easier to maintain and extend.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update #2:&lt;/b&gt; Apparently I’ve (unknowingly) conflated “Ask, Don’t Tell” with the
“Tell, Don’t Ask,” advice Dave Thomas has been giving us for years to make a
different but related point about object oriented design.  Dave explains here:
&lt;a href="http://pragdave.me/blog/2014/02/11/telling-asking-and-the-power-of-jargon/"&gt;Telling, Asking, and the Power of
Jargon&lt;/a&gt;.
He also disagrees with my opinion that the &lt;span
  class="code"&gt;parse_lines&lt;/span&gt; example was written in a functional style.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What does (((λ f . (λ x . (f x))) (λ a . a)) (λ b . b)) mean?</title>
    <link href="http://patshaughnessy.net/2014/1/30/what-does-f-x-f-x-a-a-b-b-mean" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/1/30/what-does-f-x-f-x-a-a-b-b-mean</id>
    <published>2014-01-30T04:00:00Z</published>
    <updated>2014-01-30T04:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;p&gt;This week I’ve been spending some free time between projects working on my
function programming skills. I’m a Ruby developer but have always been
fascinated by functional languages such as Haskell, Clojure and of course Lisp.
I was excited this morning when I stumbled across a fascinating article called
&lt;a href="http://matt.might.net/articles/implementing-a-programming-language/"&gt;7 lines of code</summary>
    <content type="html">&lt;p&gt;This week I’ve been spending some free time between projects working on my
function programming skills. I’m a Ruby developer but have always been
fascinated by functional languages such as Haskell, Clojure and of course Lisp.
I was excited this morning when I stumbled across a fascinating article called
&lt;a href="http://matt.might.net/articles/implementing-a-programming-language/"&gt;7 lines of code, 3 minutes: Implement a programming language from scratch&lt;/a&gt;. The
author, &lt;a href="https://twitter.com/mattmight"&gt;Matthew Might&lt;/a&gt;, touches on Lambda Calculus notation before implementing
a simple interpreter for Lambda Calculus using just seven lines of Scheme code.
He later proceeds to write a Scheme interpreter in about 100 lines of code,
using a dialect of Scheme called &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Matthew starts by introducing the basics of Lambda Calculus notation like this:&lt;/p&gt;

&lt;div style="margin: 20px 0 0 100px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/30/basics.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Matthew explains that all of Lambda Calculus is based on these two simple
concepts, along with variable references. He then shows a couple of simple examples:&lt;/p&gt;

&lt;div style="margin: 20px 0 0 100px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/30/examples.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;&amp;hellip;and then asks the reader this simple question:&lt;/p&gt;

&lt;div style="margin: 20px 0 0 100px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/30/question.png"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;In this post I’ll try to answer this question using a series of diagrams. I’m a
visual learner, and teacher. For me drawing something makes it much easier to
understand and to explain to someone else. Lambda Calculus experts (“Lambda
Mathematicians?”) probably have accepted styles for drawing these concepts
which I’m not aware of. I’ll just draw what comes naturally to me.&lt;/p&gt;

&lt;h2&gt;Getting Rid of All Those Parentheses&lt;/h2&gt;

&lt;p&gt;If I had a whiteboard, I’d rewrite the complex Lambda Calculus expression above
with circles instead of parentheses. This makes it much easier for me to see
the nesting and order of operations. An even better visualization might be a tree structure, but I&amp;rsquo;ll keep things inline with cirlces today.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/one.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;For me, the biggest challenge to understanding Lisp or Scheme has always been
all the nested parentheses. This picture is still cryptic and meaningless, but
now at least I can see the order of operations and nesting more easily.&lt;/p&gt;

&lt;h2&gt;Start From the Inside and Work Your Way Out&lt;/h2&gt;

&lt;p&gt;To understand what’s going on here, I started with the innermost lambda
expression:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/two.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Referring to Matthew’s explanation above, &lt;span class="code"&gt;(f x)&lt;/span&gt; means evaluate the function &lt;span class="code"&gt;f&lt;/span&gt;
on the argument &lt;span class="code"&gt;x&lt;/span&gt;. Therefore, this expression represents an anonymous function
that applies some function &lt;span class="code"&gt;f&lt;/span&gt; to its argument, &lt;span class="code"&gt;x&lt;/span&gt;. The oval on the left is the
function and I’ve written this explanation on the right: what the function
does.&lt;/p&gt;

&lt;p&gt;I usually visualize functions with inputs and outputs, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/three.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see the input &lt;span class="code"&gt;x&lt;/span&gt; comes from the left, and I’ve shown the anonymous
function in the center using a half-oval. It applies a function &lt;span class="code"&gt;f&lt;/span&gt;, which is
almost like a second input value, to &lt;span class="code"&gt;x&lt;/span&gt; and returns an output value on the
right.&lt;/p&gt;

&lt;h2&gt;Higher Order Functions&lt;/h2&gt;

&lt;p&gt;Now let’s substitute this simple function back into the complex expression:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/four.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see I’ve pasted the text “Apply f to my argument” into the center of
the expression where the previous lambda was located. Working my way out, let’s
take a look at what the next lambda expression means:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/five.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here you can see a definition for another anonymous function, another lambda
expression, which takes &lt;span class="code"&gt;f&lt;/span&gt; as an argument. The body of the function is our
previous expression.&lt;/p&gt;

&lt;p&gt;What this boils down to, therefore, is a function that takes a function as an
argument and returns a second function as a result. Here’s what this might look
like using my input/output diagram style:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/six.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left you can see the function takes a function, &lt;span class="code"&gt;f&lt;/span&gt;, as input. On the
right the dashed rectangle represents a single output value: another function.
This is an example of a higher order function, a function that can use other
functions as inputs or outputs.&lt;/p&gt;

&lt;p&gt;In this example, the output is a new function which applies &lt;span class="code"&gt;f&lt;/span&gt;, the input of the
higher order function, to its argument &lt;span class="code"&gt;x&lt;/span&gt;. We don’t have a value for &lt;span class="code"&gt;x&lt;/span&gt; yet, but
we have a new function which later can take an input &lt;span class="code"&gt;x&lt;/span&gt;. It will apply the
present input, &lt;span class="code"&gt;f&lt;/span&gt;, to whatever argument it receives later, &lt;span class="code"&gt;x&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The other subtle detail to think about here is that above, when we looked at
the innermost lambda expression, the value &lt;span class="code"&gt;f&lt;/span&gt; was undefined. The inner lambda
applied &lt;span class="code"&gt;f&lt;/span&gt; to its input &lt;span class="code"&gt;x&lt;/span&gt;, not knowing what &lt;span class="code"&gt;f&lt;/span&gt; was. Now &lt;span class="code"&gt;f&lt;/span&gt; has been provided by
the surrounding expression, the outer lambda. &lt;span class="code"&gt;f&lt;/span&gt; is the input to the outer
lambda. I’m not sure about this, but I suspect lambda mathematicians would say
the outer lambda is a closure around the free variable, &lt;span class="code"&gt;f&lt;/span&gt;.&lt;/p&gt;

&lt;h2&gt;Identity Functions&lt;/h2&gt;

&lt;p&gt;Substituting again, here’s the entire expression simplified:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/seven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The two lambdas on the right are easier to follow. These are examples of the
identity function, a function that returns its argument. Matthew showed this
syntax as one of his examples.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/eight.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see here the identity function simply passes its input along as an
output:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/nine.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Evaluating a Function&lt;/h2&gt;

&lt;p&gt;Substituting again, here’s what we have now:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/ten.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Earlier we saw the higher order function on the left returns a function that
will later operate on an argument, which I showed as &lt;span class="code"&gt;x&lt;/span&gt;. Now its time has come.
Recall that &lt;span class="code"&gt;(f x)&lt;/span&gt; in Lambda Calculus means “evaluate the function &lt;span class="code"&gt;f&lt;/span&gt; on the
argument &lt;span class="code"&gt;x&lt;/span&gt;.”&lt;/p&gt;

&lt;p&gt;In other words, this expression:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/eleven.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;… means: “evaluate the higher order function on the left, providing the
function on the right as an argument.”&lt;/p&gt;

&lt;p&gt;The higher order function will take one function (the identity function) and
return another:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/twelve.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The output is a new function which will apply the identity function (the
argument) to its own argument &lt;span class="code"&gt;x&lt;/span&gt;. Of course, this is equivalent to the identity
function itself!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/thirteen.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;There must be some Lambda Calculus axiom (the “lambda identity axiom?”) behind
this deduction, but I’m not sure. I’ll consider it obvious and just move on.&lt;/p&gt;

&lt;h2&gt;The Result&lt;/h2&gt;

&lt;p&gt;Substituting this result back into the original expression, we’re left with
this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/fourteen.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Reapplying the “lambda identity axiom” again it’s
obvious this is equivalent to the identity function:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/30/fifteen.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;That is, the identity function is also a higher order function. It returns the
same functions you pass to it, unchanged.&lt;/p&gt;

&lt;p&gt;Stepping back and taking stock, we’ve deduced that:&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;(((λ f . (λ x . (f x))) (λ a . a)) (λ b . b))&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Is equivalent to:&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;(λ x . x)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Or the identity function.&lt;/p&gt;

&lt;h2&gt;What Did I Get Wrong?&lt;/h2&gt;

&lt;p&gt;As I mentioned, I’m just learning about functional programming and lambda
calculus. If you have some computer science training and see something wrong
here, let me know. Or if you know the real name for the “lambda identity axiom”
or have examples of better diagrams for representing lambda expressions, please
pass along a link.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby Multiplies Like a Fourth Grader</title>
    <link href="http://patshaughnessy.net/2014/1/24/ruby-multiplies-like-a-fourth-grader" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/1/24/ruby-multiplies-like-a-fourth-grader</id>
    <published>2014-01-24T04:00:00Z</published>
    <updated>2014-01-24T04:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 40px 0px; text-align: center;"&gt; &lt;img
  src="http://patshaughnessy.net/assets/2014/1/24/multiply.jpg"&gt;&lt;br/&gt; &lt;i&gt;Ruby
    multiplies large integers using the same&lt;br/&gt; algorithm we learned in
    elementary school.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;Imagine yourself as an 8 or 9 year old at a chalkboard learning to multiply.
Your teacher asks you to write one number over anothe</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 40px 0px; text-align: center;"&gt; &lt;img
  src="http://patshaughnessy.net/assets/2014/1/24/multiply.jpg"&gt;&lt;br/&gt; &lt;i&gt;Ruby
    multiplies large integers using the same&lt;br/&gt; algorithm we learned in
    elementary school.&lt;/i&gt; &lt;/div&gt;


&lt;p&gt;Imagine yourself as an 8 or 9 year old at a chalkboard learning to multiply.
Your teacher asks you to write one number over another, and then to draw an “x”
and a line below. Next you multiply the numbers one digit at a time, using the
multiplication table you memorized the year before. Your teacher also shows you
how to “carry” values from one column to the next when they don’t fit as a
single digit.&lt;/p&gt;

&lt;p&gt;After studying Ruby’s multiplication algorithm, I was surprised to find out
that Ruby multiplies large numbers (&lt;span class="code"&gt;Bignum&lt;/span&gt;’s) the
same way you learned in fourth grade: one “digit” at a time. My post today will
give you a quick refresher course on fourth grade math, and then explain how
Ruby’s &lt;span class="code"&gt;Bignum&lt;/span&gt; class uses the same classic, long
multiplication algorithm you learned in elementary school!&lt;/p&gt;

&lt;h2&gt;A Crash Course in Fourth Grade Math&lt;/h2&gt;

&lt;p&gt;We all remember multiplication tables: memorizing them was either a fun mental
exercise &amp;ndash; or a painful form of torture &amp;ndash; depending on our mathematical
aptitude and the personality of our grade school teacher. Regardless, there
were two reasons for memorizing simple products such as 5 x 6 = 30 or 9 x 7 =
63.  First, these simple problems occur frequently; and second, they help us
later when multiplying larger numbers.&lt;/p&gt;

&lt;p&gt;Maybe you flunked out of school before the fourth grade, or more likely you’ve
become so dependent on your iPhone’s calculator app you don’t remember how to
multiply by hand. Before we look at how Ruby multiplies numbers, let’s review
the classic long multiplication algorithm.&lt;/p&gt;

&lt;p&gt;Here’s a sample problem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now walk up to the chalkboard and write the two numbers one above the other,
the larger number on top:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 40px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/24/mult-tables.jpg"&gt;&lt;br/&gt;
&lt;/div&gt;


&lt;p&gt;Remember what to do next? For me fourth grade was in the 1970s, but somehow it
still comes back to me! Start by multiplying the rightmost digits from each
number together (2 x 9 = 18), placing the product below the line:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;However, since 18 is too large to fit into a single digit you “carry” the 1 up
to the top of the next column, and leave the 8 behind:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Next multiply 9 again by the next digit from the top number, 3 in this example,
adding  the 1 you carried from the last step. So you calculate (9x3)+1 = 28.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here I’ve written the 28 below the line, to the left of the previous 8 value.
So far you’ve calculated that 9x32 = 288.&lt;/p&gt;

&lt;p&gt;Remember what to do next? I know it’s been a long time! Repeat the process with
the next digit from the lower number, 2. In other words, you calculate 2x32=64.
However, this time you write the product farther below, shifted to the left
like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample6.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You shift the numbers to the left because the 2 from 29 is actually a 20. Now
all you need to do is add the two intermediate products together, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/sample7.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Drop the first 8 down, add 8+4=12, carry the 1 and finally calculate 1+2+6 = 9.
You have the answer, 928. Congratulations, you’ve managed to multiply two
numbers by hand without a calculator!&lt;/p&gt;

&lt;h2&gt;Ruby’s Multiplication Table&lt;/h2&gt;

&lt;div style="float: right; padding: 7px 0px 40px 30px; text-align: center;"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/24/intel.jpg"&gt;&lt;br/&gt;
  &lt;i&gt;The Intel 4004 was the first&lt;br/&gt;
    commercially available microprocessor&lt;br/&gt;(source: &lt;a href="http://commons.wikimedia.org/wiki/File:Intel_4004.jpg"&gt;wikimedia commons&lt;/a&gt;)&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;To multiply small numbers Ruby doesn’t implement a software algorithm. Instead,
Ruby relies on your computer’s microprocessor’s hardware circuits to perform
the calculation. Your microprocessor, in a sense, plays the role of a
multiplication table for Ruby. By using a machine language instruction to
multiply numbers, Ruby can get simple products very quickly. This is loosely
analogous to you or I memorizing the simple products from the multiplication
table in our heads.&lt;/p&gt;

&lt;p&gt;As I discussed in &lt;a href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum"&gt;my last article&lt;/a&gt;, Ruby stores small integers as native 64-bit
values using the &lt;span class="code"&gt;Fixnum&lt;/span&gt; class. For example, in Ruby we could multiply two
numbers like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/five-six-ruby.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;When you execute this program, Ruby’s internal C code represents these two
numbers as &lt;span class="code"&gt;Fixnum&lt;/span&gt; objects:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/fixnums.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;As you can see, Ruby represents each &lt;span class="code"&gt;Fixnum&lt;/span&gt; with a 64-bit binary value with the
least significant bit (FIXNUM_FLAG) set. When it needs to multiply, Ruby first removes the FIXNUM_FLAG bit and is
left with the actual binary values 5 and 6. Now it can perform the
multiplication using a native machine language instruction.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/fixnums-multiply.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above &lt;span class="code"&gt;imulq&lt;/span&gt; is the Intel x86-64 assembly language
instruction for multiplying integers. Ruby relies on the microprocessor to
calculate 5x6 and to return the product 30, shown as binary at the bottom.&lt;/p&gt;

&lt;h2&gt;A Fourth Grader That Knows Hexadecimal&lt;/h2&gt;

&lt;p&gt;Ruby multiplies large numbers exactly the same way you and I do, using the
classic long multiplication algorithm. We use long multiplication to multiply
numbers larger than 12, since the multiplication tables we memorized went up to
12. Ruby uses long multiplication for numbers that don’t fit into a &lt;span class="code"&gt;Fixnum&lt;/span&gt;
object &amp;ndash; numbers so large that a single machine language instruction can’t
process them.&lt;/p&gt;

&lt;p&gt;Here’s an example problem:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample1.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The number 29 fits into a &lt;span class="code"&gt;Fixnum&lt;/span&gt; no problem, but 10000000000000000000 does not.
Instead, Ruby represents this large integer using a &lt;span class="code"&gt;Bignum&lt;/span&gt; object, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/bignum.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see a simplified view of the &lt;span class="code"&gt;RBignum&lt;/span&gt; C structure at the top. The &lt;span class="code"&gt;digits&lt;/span&gt;
pointer saves the location of an array of 32-bit values, the “digits.” As I
explained in &lt;a href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum"&gt;my last article&lt;/a&gt;, the digits are actually out of order, with the
lower 32 bits on the left and the top 32 bits on the right.&lt;/p&gt;

&lt;p&gt;Since Ruby represents &lt;span class="code"&gt;Bignum&lt;/span&gt;’s with a complex data structure and not simple
64-bit integers, it can’t use machine language instructions to perform
mathematical operations on them. What does Ruby do instead? How did it
calculate 10000000000000000000 * 29 above?&lt;/p&gt;

&lt;p&gt;It turns out Ruby uses long multiplication, just as we did in fourth grade! The
only difference is that Ruby uses 32-bit “digits,” instead of digits that
contain decimal values from 0-9.&lt;/p&gt;

&lt;p&gt;To see what I mean, here’s another look at the 32x29 problem we did earlier:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/another-look.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Above I show a rectangle around each 0-9 decimal digit. Remember the long
multiplication algorithm works on one pair of digits at a time. The 0-9
notation means that each digit can hold a value between 0 and 9.&lt;/p&gt;

&lt;p&gt;Now let’s take another look at the large integer multiplication Ruby executed
above:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample2.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;If I redraw this using 32-bit “digits,” I get this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample3.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Each rectangle is a 32-bit word present in a &lt;span class="code"&gt;Bignum&lt;/span&gt; &lt;span class="code"&gt;digit&lt;/span&gt; data structure. At the bottom
we see 0x1d, which is 29. (This does fit into a &lt;span class="code"&gt;Fixnum&lt;/span&gt; but Ruby moves it to a &lt;span class="code"&gt;Bignum&lt;/span&gt; before the multiplication starts.) Above that are the bits from the &lt;span class="code"&gt;RBignum&lt;/span&gt; structure, shown in the proper order. 0x8ac72304 are the most significant 32 bits
and 0x89e80000 are the least significant 32 bits. In order words, the
hexadecimal value 0x8ac7230489e80000 is equivalent to 10000000000000000000.&lt;/p&gt;

&lt;p&gt;It might seem bizarre to show a multiplication problem this way, but remember
Ruby is a  very special fourth grader, one that knows how to perform binary
math and can understand hexadecimal.&lt;/p&gt;

&lt;h2&gt;Multiplying Bignums Using Long Multiplication&lt;/h2&gt;

&lt;p&gt;Once we’ve drawn the problem using 32-bit hexadecimal digits, we’ll be able to
see that Ruby performs long multiplication just like you or I did back in school.
First, it multiplies the rightmost digits from each number.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample4.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;So we have 0x89e80000 * 0x1d = 0xf9f480000. But now the top 4 bits, the 0xf,
doesn’t fit into a single 32-bit value. So Ruby “carries” the 0xf to the next
column.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample5.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You can see above the carried value 0xf at the top left, and the remaining bits
in the 32-bit digit at the bottom right.&lt;/p&gt;

&lt;p&gt;Now Ruby calculates 0x8ac72304 * 0x1d + 0xf and gets 0xfb88ef783.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample6.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Once again, 0xfb88ef783 doesn’t fit into 32 bits, so Ruby carries the extra 0xf
to the next column. Since this was the last column, Ruby is done and just moves
the extra 0xf into a new 32-bit digit:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample7.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;And now we have our answer:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/24/hex-sample8.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Multiplication of Extremely Large Numbers&lt;/h2&gt;

&lt;p&gt;This was a very simple example, because 29 was actually a small integer. This
meant Ruby didn’t need to use multiple rows in the long multiplication process,
adding them together to get the final result. But Ruby would use multiple rows in
long multiplication just the way we would if both numbers were large.&lt;/p&gt;

&lt;p&gt;However, Ruby’s &lt;span class="code"&gt;Bignum&lt;/span&gt; class was also designed to handle extremely large numbers
that might contain thousands of digits. You might need these for certain
scientific applications or in cryptography, for example. To handle extremely
large numbers, the &lt;span class="code"&gt;Bignum&lt;/span&gt; class also contains some alternative, advanced
mathematical algorithms for multiplication, division and more. Ruby 2.1 also now optionally supports the GMP, the &lt;a href="https://gmplib.org"&gt;GNU
Multiple Precision Arithmetic Library&lt;/a&gt;. In my next post I’ll take a look at how
to enable GMP support and how to use it.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How Big is a Bignum?</title>
    <link href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum" rel="alternate"/>
    <id>http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum</id>
    <published>2014-01-09T04:00:00Z</published>
    <updated>2014-01-09T04:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/9/classes.png"&gt;&lt;br/&gt;
  &lt;i&gt;Ruby represents small integers using Fixnum&lt;br/&gt;
    and large integers using Bignum.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Most of us don’t use Ruby to perform complex calculations for science,
engineering or cryptography applications; instead, we migh</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 20px 0px; text-align: center; margin-top: 20px"&gt;
  &lt;img src="http://patshaughnessy.net/assets/2014/1/9/classes.png"&gt;&lt;br/&gt;
  &lt;i&gt;Ruby represents small integers using Fixnum&lt;br/&gt;
    and large integers using Bignum.&lt;/i&gt;
&lt;/div&gt;


&lt;p&gt;Most of us don’t use Ruby to perform complex calculations for science,
engineering or cryptography applications; instead, we might turn to R, Matlab
or some other programming language or tool for that sort of thing. When we calculate
values using Ruby, it’s often to process simple values while generating a web
page using ERB or Haml, or to handle the result of a database query using
ActiveRecord. Almost all of the time, Ruby’s &lt;span class="code"&gt;Fixnum&lt;/span&gt;
class is more than sufficient.&lt;/p&gt;

&lt;p&gt;For most Ruby developers, therefore, the &lt;span class="code"&gt;Bignum&lt;/span&gt; class is a dark, unfamiliar
corner of the language. Today I’d like to shed some light on &lt;span class="code"&gt;Bignum&lt;/span&gt; by looking
at how Ruby represents integers internally inside the &lt;span class="code"&gt;Fixnum&lt;/span&gt; and &lt;span class="code"&gt;Bignum&lt;/span&gt;
classes. What’s the largest integer that fits inside a &lt;span
  class="code"&gt;Fixnum&lt;/span&gt;; just how big is a &lt;span
  class="code"&gt;Bignum&lt;/span&gt;?&lt;/p&gt;

&lt;p&gt;Also, it turns out that Ruby 2.1 contains an important new change for the
&lt;span class="code"&gt;Bignum&lt;/span&gt; class: support for the &lt;a href="https://gmplib.org"&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; library.
In my next post, I’ll take a look at mathematical theory and history behind
some of the algorithms used by &lt;span class="code"&gt;Bignum&lt;/span&gt; internally and how Ruby 2.1 works
with GMP. But for now, let’s start with the basics.&lt;/p&gt;

&lt;h2&gt;64-Bit Integers&lt;/h2&gt;

&lt;p&gt;Most computers these days represent numbers as 64 digit binary values
internally. For example, the number ten thousand looks like this expressed as a
binary value:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/64-bits.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;My rectangle here represents how a 64-bit computer would save an integer in a
microprocessor register or a RAM memory location. The numbers 63 and 0 indicate
that there are spaces for 64 binary digits, each of which can contain a zero or
one. The most significant binary digit, #63, is on the left, while the least
significant digit, #0, is on the right. I’m not showing all of the leading
zeroes here to keep things simple.&lt;/p&gt;

&lt;p&gt;The term &lt;em&gt;64-bit architecture&lt;/em&gt; means the logic gates, transistors and circuits
located on your microprocessor chip are designed to process binary values using
64 binary digits like this, in parallel. Whenever your code uses an integer,
the microprocessor retrieves all of these on/off values from one of the RAM
chips in your CPU using a “bus” or set of 64 parallel connections.&lt;/p&gt;

&lt;h2&gt;64-Bit Integers in MRI Ruby&lt;/h2&gt;

&lt;p&gt;The standard implementation of Ruby, Matz’s Ruby Interpreter (MRI), saves
integers using a slightly different, custom format; it hard codes the least
significant digit (on the right in my diagram) to one and shifts the actual
integer value one bit to the left. As we’ll see in a moment, if this bit were
zero Ruby would instead consider the integer to be a pointer to some Ruby
object.&lt;/p&gt;

&lt;p&gt;Here’s how Ruby represents ten thousand
internally:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/64-bits-ruby.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;=1 indicates this integer represents an instance of the &lt;span class="code"&gt;Fixnum&lt;/span&gt;
class. The flag is a performance optimization, removing the need for Ruby to
create a separate C structure the way it normally would for other types of
objects. (Ruby uses a similar trick for symbols and special values such as
&lt;span class="code"&gt;true&lt;/span&gt;, &lt;span class="code"&gt;false&lt;/span&gt; and &lt;span class="code"&gt;nil&lt;/span&gt;.)&lt;/p&gt;

&lt;h2&gt;Two’s Complement in Ruby&lt;/h2&gt;

&lt;p&gt;Like most other computer languages and also like your microprocessor’s actual hardware
circuits, Ruby uses a binary format called &lt;a href="http://en.wikipedia.org/wiki/Two's_complement"&gt;two’s complement&lt;/a&gt; to save negative
integers. Here’s how the value -10,000 would be saved inside your Ruby program:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/twos-complement-ruby.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Note the first bit on the left, the sign bit, is set to 1. This indicates this
is a negative integer. Ruby still sets the lowest bit, &lt;span
  class="code"&gt;FIXNUM_FLAG&lt;/span&gt;, to 1. The other bits contain the value
itself. To calculate a two’s complement value for a negative integer, your
microprocessor adds one to the absolute value (getting 10,001 in this example)
and then reverses the zeroes and ones. This is equivalent to subtracting the
absolute value from the next highest power of two. Ruby uses two’s complement
in the same way, except it adds &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt; on the
right and shifts the rest of the value to the left.&lt;/p&gt;

&lt;h2&gt;The Largest Fixnum Value: 4611686018427387903&lt;/h2&gt;

&lt;p&gt;Using 64-bit binary values with &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;, Ruby is able to take advantage of
your computer’s microprocessor to represent integer values efficiently. Addition,
subtraction and other integer operations can be handled using the
corresponding assembly language instructions by removing and then re-adding
&lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt; internally as needed. This design only
works, however, for integer values that are small enough to fit into a single
64-bit word. We can see what the largest positive &lt;span
  class="code"&gt;Fixnum&lt;/span&gt; integer must be by setting all 62 of the middle
bits to one, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/largest-value.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Here we have a zero on the left (indicating this is a positive integer) and a
one on the right (for &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;). The remaining 62 bits in the middle hold
this binary number:&lt;br/&gt;
11111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;

&lt;p&gt;Converting this to decimal we get: 4611686018427387903, the largest integer
that fits into a &lt;span class="code"&gt;Fixnum&lt;/span&gt; object. (If you compiled Ruby on a 32-bit computer, of
course, the largest &lt;span class="code"&gt;Fixnum&lt;/span&gt; would be much smaller than this, only 30-bits wide.)&lt;/p&gt;

&lt;h2&gt;The Smallest Bignum: 4611686018427387904&lt;/h2&gt;

&lt;p&gt;But what does Ruby do if we want to use larger numbers? For example, this Ruby
program works just fine:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/code.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;But now the sum doesn’t fit into a 64-bit &lt;span class="code"&gt;Fixnum&lt;/span&gt; value, since expressing
4611686018427387904 as a binary value requires 63 digits, not 62:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/doesnt-fit.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;This is where the &lt;span class="code"&gt;Bignum&lt;/span&gt; class comes in. While calculating
4611686018427387903+1, Ruby has to create a new type of object to represent
4611686018427387904 &amp;ndash; an instance of the &lt;span class="code"&gt;Bignum&lt;/span&gt; class. Here’s how that looks
inside of Ruby:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/pointer.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the right you can see Ruby has reset the &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt; to zero, indicating
this value is not a &lt;span class="code"&gt;Fixnum&lt;/span&gt; but instead a pointer to some other type of object.
(C programs like MRI Ruby that use &lt;span class="code"&gt;malloc&lt;/span&gt; to allocate memory always get
addresses that end in zero, that are &lt;em&gt;aligned&lt;/em&gt;. This means the &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;, a
zero, is actually also part of the pointer’s value.)&lt;/p&gt;

&lt;h2&gt;The RBignum Structure&lt;/h2&gt;

&lt;p&gt;Now let’s take a closer look at the &lt;span class="code"&gt;RBignum&lt;/span&gt; C structure and find out what’s
inside it. Here’s how Ruby saves the value 4611686018427387904 internally:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/closer-look.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;On the left, you can see &lt;span class="code"&gt;RBignum&lt;/span&gt; contains an inner structure called &lt;span class="code"&gt;RBasic&lt;/span&gt;,
which contains internal, technical values used by all Ruby objects. Below that
I show values specific to &lt;span class="code"&gt;Bignum&lt;/span&gt; objects: &lt;span class="code"&gt;digits&lt;/span&gt; and &lt;span class="code"&gt;len&lt;/span&gt;. &lt;span class="code"&gt;digits&lt;/span&gt; is a pointer
to an array of 32-bit values that contain the actual big integer’s bits grouped
into sets of 32. &lt;span class="code"&gt;len&lt;/span&gt; records how many 32-bit groups are in the &lt;span class="code"&gt;digits&lt;/span&gt; array.
Since there can be any number of groups in the &lt;span class="code"&gt;digits&lt;/span&gt; array, Ruby can represent
arbitrarily large integers using &lt;span class="code"&gt;RBignum&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Ruby divides up the bits of the big integer into 32-bit pieces. On the left,
the first 32-bit value contains the least significant 32 bits from the big
integer, bit 31 down to bit 0. Following that, the second value contains bits
63-32. If the big integer were larger, the third value would contain bits
95-64, etc. Therefore, the large integer’s bits are actually not in order: The
groups of bits are in reverse order, while the bits inside each group are in
the proper order.&lt;/p&gt;

&lt;p&gt;To save a &lt;span class="code"&gt;Bignum&lt;/span&gt; value, Ruby starts by saving the
least significant bits of the target integer into the first 32-bit digit group.
Then it shifts the remaining bits 32 places to the right and saves the next 32
least significant bits into the next group. Ruby continues shifting and saving
until the entire big integer has been processed.&lt;/p&gt;

&lt;p&gt;Ruby allocates enough 32-bit pieces in the &lt;span class="code"&gt;digits&lt;/span&gt; array to provide enough room
for the entire large integer. For example, for an extremely large number
requiring 320 bits, Ruby could use 10 32-bit values by setting &lt;span class="code"&gt;len&lt;/span&gt; to 10 and
allocating more memory:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/ten-digits.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In my example Ruby needs just two 32-bit values. This makes sense because, as
we saw above, 4611686018427387903 is a 62-bit integer (all ones) and when I add one I get a 63-bit value. When I add
one, Ruby first copies the 62 bits in the target value into a new &lt;span class="code"&gt;Bignum&lt;/span&gt; structure, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/copy-to-bignum.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Ruby copies the least significant 32 bits into the first digit
value on the left, and the most significant 30 into the second digit value on
the right (there is space for two leading zeroes in the second digit value).&lt;/p&gt;

&lt;p&gt;Once Ruby has copied 4611686018427387903 into a new &lt;span
  class="code"&gt;RBignum&lt;/span&gt; structure, it can then use a special algorithm
implemented in bignum.c to perform an addition operation on the new Bignum. Now
there is enough room to hold the 63-bit result, 4611686018427387904 (diagram copied from above):&lt;/p&gt;

&lt;p&gt;&lt;img src="http://patshaughnessy.net/assets/2014/1/9/closer-look.png"&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;A few other minor details to learn about this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ruby saves the sign bit inside the &lt;span class="code"&gt;RBasic&lt;/span&gt;
  structure, and not in the binary digit values themselves. This saves a bit of
  space, and makes the code inside bignum.c simpler.&lt;/li&gt;

  &lt;li&gt;Ruby also doesn’t need to save the &lt;span class="code"&gt;FIXNUM_FLAG&lt;/span&gt;
  in the digits, since it already knows this is a &lt;span
    class="code"&gt;Bignum&lt;/span&gt; value and not a &lt;span class="code"&gt;Fixnum&lt;/span&gt;.&lt;/li&gt;

  &lt;li&gt;For small &lt;span class="code"&gt;Bignum&lt;/span&gt;’s, Ruby saves memory and time
by storing the digits values right inside the &lt;span class="code"&gt;RBignum&lt;/span&gt; structure itself, using a
C &lt;i&gt;union&lt;/i&gt; trick. I don’t have time to explain that here today, but you can see
how the same optimization works for strings in my article &lt;a href="http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters"&gt;Never create Ruby strings longer than 23 characters&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Next time&lt;/h2&gt;

&lt;p&gt;In my next post I’ll look at how Ruby performs an actual mathematical operation
using &lt;span class="code"&gt;Bignum&lt;/span&gt; objects. It turns out there’s more to multiplication that you
might think: Ruby uses one of a few different multiplication algorithms
depending on how large the integers are, each with a different history behind
it. And Ruby 2.1 adds yet another new algorithm to the mix with GMP.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Three RubyConf Surprises</title>
    <link href="http://patshaughnessy.net/2013/12/4/three-rubyconf-surprises" rel="alternate"/>
    <id>http://patshaughnessy.net/2013/12/4/three-rubyconf-surprises</id>
    <published>2013-12-04T04:00:00Z</published>
    <updated>2013-12-04T04:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px"&gt;
   &lt;img src="http://patshaughnessy.net/assets/2013/11/26/heading-to-the-beach.png"/&gt;
&lt;/div&gt;




&lt;p&gt;This year &lt;a href="http://rubyconf.org"&gt;RubyConf&lt;/a&gt; was an inspiring, enthusiastic and fun experience. If you weren&amp;apos;t lucky enough to be able to attend in person, I would highly recommend taking a look at &lt;a href="http://rubyconf13.multifacete</summary>
    <content type="html">&lt;div style="float: left; padding: 7px 30px 0px 0px"&gt;
   &lt;img src="http://patshaughnessy.net/assets/2013/11/26/heading-to-the-beach.png"/&gt;
&lt;/div&gt;




&lt;p&gt;This year &lt;a href="http://rubyconf.org"&gt;RubyConf&lt;/a&gt; was an inspiring, enthusiastic and fun experience. If you weren&amp;apos;t lucky enough to be able to attend in person, I would highly recommend taking a look at &lt;a href="http://rubyconf13.multifaceted.io"&gt;http://rubyconf13.multifaceted.io&lt;/a&gt;, a multimedia site about RubyConf put together by &lt;a href="http://www.ninefold.com"&gt;Ninefold&lt;/a&gt;, a Sydney Rails hosting firm. They collected an amazing set of speaker interviews, slides, talk summaries, and tweets from the conference. And just this week Confreaks has started posting the &lt;a href="http://www.confreaks.com/events/rubyconf2013"&gt;session videos online&lt;/a&gt;; there are many sessions I missed in person that I can’t wait to see.&lt;/p&gt;




&lt;p&gt;Today, however, I'd like to pass along a few tidbits of technical knowledge I learned during the conference that &lt;em&gt;surprised&lt;/em&gt; me. Aside from all the great people I met during hallway, dinner and lunch conversations, the surprising bits of knowledge are what stand out in my memory as I write this, three weeks after the conference ended.&lt;/p&gt;


&lt;p&gt;Read the full article on &lt;a href="http://www.sitepoint.com/three-rubyconf-surprises/"&gt;sitepoint.com&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Expanded Ruby Under a Microscope Available in Print!</title>
    <link href="http://patshaughnessy.net/2013/11/7/expanded-ruby-under-a-microscope-available-in-print" rel="alternate"/>
    <id>http://patshaughnessy.net/2013/11/7/expanded-ruby-under-a-microscope-available-in-print</id>
    <published>2013-11-07T04:00:00Z</published>
    <updated>2013-11-07T04:00:00Z</updated>
    <category>ruby</category>
    <author>
      <name></name>
    </author>
    <summary type="html">&lt;div style="float: left; padding: 0px 30px 10px 0px; text-align: center; margin-top: 8px; margin-bottom: 9px"&gt;
  &lt;a href="http://nostarch.com/rum"&gt;&lt;img src="http://patshaughnessy.net/assets/2013/11/7/RUM_coverfront.png"&gt;&lt;br/&gt;&lt;i&gt;Order your copy today at NoStarch.com&lt;/a&gt;.&lt;br/&gt;
    Use coupon code LENS to get a 40% discount!&lt;/i&gt;&lt;/a&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;I’m happy to announce &lt;em&gt;Ruby Under a Microscope&lt;/em&gt;</summary>
    <content type="html">&lt;div style="float: left; padding: 0px 30px 10px 0px; text-align: center; margin-top: 8px; margin-bottom: 9px"&gt;
  &lt;a href="http://nostarch.com/rum"&gt;&lt;img src="http://patshaughnessy.net/assets/2013/11/7/RUM_coverfront.png"&gt;&lt;br/&gt;&lt;i&gt;Order your copy today at NoStarch.com&lt;/a&gt;.&lt;br/&gt;
    Use coupon code LENS to get a 40% discount!&lt;/i&gt;&lt;/a&gt;
&lt;/div&gt;


&lt;p&gt;&lt;b&gt;I’m happy to announce &lt;em&gt;Ruby Under a Microscope&lt;/em&gt; is now available in print!&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ruby Under a Microscope&lt;/em&gt; gives you a hands-on look at Ruby’s core, using
extensive diagrams and thorough explanations to show you how Ruby is
implemented (no C skills required). I take a scientific approach, laying out a
series of experiments with Ruby code to take you behind the scenes of how
programming languages work. You’ll even find information on JRuby and Rubinius
(two alternative implementations of Ruby), as well as in-depth explorations of
Ruby’s garbage collection algorithm.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ruby Under a Microscope&lt;/em&gt; will teach you:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How a few computer science concepts underpin Ruby’s complex implementation&lt;/li&gt;
&lt;li&gt;How Ruby executes your code using a virtual machine&lt;/li&gt;
&lt;li&gt;How classes and modules are the same inside Ruby&lt;/li&gt;
&lt;li&gt;How Ruby employs algorithms originally developed for Lisp&lt;/li&gt;
&lt;li&gt;How Ruby uses grammar rules to parse and understand your code&lt;/li&gt;
&lt;li&gt;How your Ruby code is translated into a different language by a compiler.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;No programming language needs to be a black box. Whether you’re already
intrigued by language implementation or just want to dig deeper into Ruby,
you’ll find &lt;em&gt;Ruby Under a Microscope&lt;/em&gt; a fascinating way to become a better
programmer.&lt;/p&gt;

&lt;h2&gt;What’s New in the Expanded Book?&lt;/h2&gt;

&lt;p&gt;Professionally edited and produced, the expanded book covers important new
features introduced with Ruby 2.0: &lt;span class="code"&gt;Module#prepend&lt;/span&gt;,
keyword arguments, refinements and more. You’ll learn how to use them… and even
how Ruby 2.0 implements them internally! I also updated the text and diagrams
from my 2012 eBook to account for important changes to Ruby&amp;rsquo;s virtual machine
(YARV) made during 2.0 release, and added new chapters covering JRuby, Rubinius
and garbage collection.&lt;/p&gt;

&lt;p&gt;I had the honor of working with &lt;a href="https://twitter.com/tenderlove"&gt;Aaron “tenderlove”
Patterson&lt;/a&gt; on the project, who was the
technical reviewer.  Thanks to Aaron, the expanded book is both more accurate and
more interesting: Aaron had a number of great suggestions for new content which
I included as well.&lt;/p&gt;

&lt;div style="float: right; padding: 7px 0px 10px 30px; text-align: center; margin-top: 20px"&gt;
  &lt;a href="http://nostarch.com/download/samples/RUM_CH6_excerpt.pdf"&gt;&lt;img src="http://patshaughnessy.net/assets/2013/11/7/ch6.png"&gt;&lt;br/&gt;&lt;i&gt;Download Chapter 6 as a free PDF&lt;/i&gt;&lt;/a&gt;.
&lt;/div&gt;


&lt;h2&gt;A 40% Discount&lt;/h2&gt;

&lt;p&gt;For the next seven days only, I’m offering a special discount: &lt;b&gt;Use coupon
  code “LENS” on &lt;a href="http://nostarch.com/rum"&gt;NoStarch.com&lt;/a&gt; to get a 40%
  discount.&lt;/b&gt; The LENS code will be valid for one week only, so be sure to
order your copy today! No Starch plans to start shipping the new books Monday,
Nov. 11th.&lt;/p&gt;

&lt;h2&gt;A Free Chapter Online&lt;/h2&gt;

&lt;p&gt;No Starch has posted Chapter 6, “Module Lookup and Constant Lookup,” as a &lt;a href="http://nostarch.com/download/samples/RUM_CH6_excerpt.pdf"&gt;free
online PDF&lt;/a&gt;. It
discusses how internally Ruby implements modules as classes, how Ruby finds
methods you call, and how Ruby uses lexical scope to find constants.&lt;/p&gt;

&lt;h2&gt;Expanded Table of Contents&lt;/h2&gt;

&lt;table id='toc'&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Foreword by Aaron Patterson&lt;/td&gt;
    &lt;td&gt;xv&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Acknowledgments&lt;/td&gt;
    &lt;td&gt;xvii&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Introduction&lt;/td&gt;
    &lt;td&gt;xix&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 1: Tokenization and Parsing&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 2: Compilation&lt;/td&gt;
    &lt;td&gt;31&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 3: How Ruby Executes Your Code&lt;/td&gt;
    &lt;td&gt;55&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 4: Control Structures and Method Dispatch&lt;/td&gt;
    &lt;td&gt;83&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 5: Objects and Classes&lt;/td&gt;
    &lt;td&gt;105&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;&lt;a href="http://nostarch.com/download/samples/RUM_CH6_excerpt.pdf"&gt;Chapter 6: Method Lookup and Constant Lookup&lt;/a&gt;&lt;/td&gt;
    &lt;td&gt;133&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 7: The Hash Table: The Workhorse of Ruby Internals&lt;/td&gt;
    &lt;td&gt;167&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 8: How Ruby Borrowed a Decades-Old Idea from Lisp&lt;/td&gt;
    &lt;td&gt;191&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 9: Metaprogramming&lt;/td&gt;
    &lt;td&gt;219&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 10: JRuby: Ruby on the JVM&lt;/td&gt;
    &lt;td&gt;251&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 11: Rubinius: Ruby Implemented with Ruby&lt;/td&gt;
    &lt;td&gt;273&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Chapter 12: Garbage Collection in MRI, JRuby, and Rubinius&lt;/td&gt;
    &lt;td&gt;295&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class='main'&gt;Index&lt;/td&gt;
    &lt;td&gt;327&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

</content>
  </entry>
</feed>
